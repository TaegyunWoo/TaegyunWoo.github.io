---
category: JPA
tags: [JPA, 영속성관리]
title: "[JPA] 영속성 관리 - 1"
date:   2021-10-09 19:06:00 
lastmod : 2021-10-09 19:06:00
sitemap :
  changefreq : daily
  priority : 1.0
---

<br/><br/>

# JPA 영속성 관리

## 개요

### 다룰 내용

JPA가 제공하는 기능은 크게 두 가지로 나눌 수 있다. 이는 아래와 같다.

- 엔티티와 테이블을 매핑하는 설계 부분
- 매핑한 엔티티를 실제로 사용하는 부분

이번 포스팅은 엔티티 매니저를 통해 매필한 엔티티를 다루는 방법에 대해 설명한다.

엔티티 매니저는 엔티티의 CRUD 작업 등의 엔티티와 관련된 모든 일을 처리한다.

<br/><br/>

## 엔티티 매니저 팩토리와 엔티티 매니저

### 엔티티 매니저 팩토리

- 엔티티 매니저 팩토리 생성 코드
    
    ```java
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("영속성 유닛 이름");
    ```
    
    - 영속성 유닛 이름은 `persistence.xml` 에서 작성한 유닛 이름과 동일하다.

- 엔티티 매니저 팩토리 기능
    - `META-INF/persistence.xml` 에 있는 정보를 바탕으로 `EntityManagerFactory` 를 생성한다.
    - 이렇게 생성된 `EntityManagerFactory`를 통해, `EntityManager` 를 생성하면 된다.

- 엔티티 매니저 팩토리 특징
    - 생성시, 비용이 매우 많이 든다.
    - **따라서 `EntityManagerFactory` 는 한 개만 생성해서 애플리케이션 전체가 공유하도록 설계되어있다.**
    - 여러 쓰레드가 동시에 접근해도 안전하기 때문에, 서로 다른 쓰레드 간 공유가 가능하다.

<br/>

### 엔티티 매니저

- 엔티티 매니저 생성 코드
    
    ```java
    EntityManager em = emf.createEntityManager();
    ```
    

- 엔티티 매니저 기능
    - 생성된 `EntityManagerFactory` 인스턴스를 통해, `EntityManager` 를 생성한다.
    - 엔티티와 관련된 모든 일을 처리한다.

- 엔티티 매니저 팩토리 특징
    - 생성시, 비용이 거의 들지 않는다.
    - 여러 쓰레드가 동시에 접근하면 동시성 문제가 발생하므로, 쓰레드 간 공유를 하면 안된다.

<br/>

### 엔티티매니저팩토리 vs 엔티티매니저

아래 그림을 통해 설명을 계속 하도록 하겠다.

![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%203.png)

- 하나의 `EntityManagerFactory` 에서 다수의 엔티티 매니저를 생성했다.
- `EntityManager 1` 은 아직 커넥션을 얻지 않았다.
    - 엔티티 매니저는 DB 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
    - 예를 들어, 트랜잭션을 시작할 때 커넥션을 획득한다.
- 각 사용자마다 사용하는 `EntityManager` 가 다르다.
    - 이는 `EntityManager` 가 쓰레드 간 공유를 하면 안되는 이유와 같다.
- JPA 구현체(하이버네이트 포함)들은 EntityManagerFactory를 생성할 때 커넥션 풀도 같이 만든다.
    - 이것은 J2SE 환경에서 사용하는 방법이다.
    - J2SE에 대해선 추후에 포스팅할 계획이다.

<br/><br/>

## 영속성 컨텍스트

### 영속성 컨텍스트란?

- JPA를 이해하는데 가장 중요한 용어가 바로 영속성 컨텍스트이다.
- 영속성 컨텍스트는 "엔티티를 영구 저장하는 환경" 정도로 해석할 수 있다.
- **엔티티 매니저로 엔티티를 저장하거나 조회하면, 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.**
- 엔티티 매니저를 생성 할 때, 하나 만들어진다.
- 엔티티 매니저를 통해, 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

<br/>

### 트랜잭션 개념

본격적인 설명 이전에, 트랜잭션에 대해 간단히 알아보자.

- DB 작업의 논리적 단위
- 트랜잭션 커밋: 만약 트랜잭션이 오류없이 수행되었다면, 실제 DB에 반영하는 것이다. 트랜잭션 커밋시, ROLLBACK이 불가능하다.

![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%204.png)

<br/><br/>

## 엔티티 생명주기

### 엔티티 생명주기 종류

엔티티에는 총 네 가지의 상태가 존재한다. 이는 다음과 같다.

- **비영속**
    - 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 주로 엔티티 인스턴스를 직접 `new` 연산자를 통해 생성했을 때의 상태를 뜻한다.
- **영속**
    - 영속성 컨텍스트에 저장된 상태
    - 영속성 컨텍스트가 해당 엔티티를 관리할 수 있는 상태이다.
- **준영속**
    - 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 즉, 영속 상태였다가 분리된 엔티티의 상태이다.
- **삭제**
    - 삭제된 상태

지금부터 각 상태들에 대해 자세히 설명하도록 하겠다.

<br/>

### 비영속

- 엔티티 객체를 생성한 직후의 상태이다.
- 아직 순수한 객체 상태이며, 저장되지 않은 상태이다.
- 따라서 영속성 컨텍스트나 DB와는 전혀 관련이 없다.
- 예시 코드
    
    ```java
    //객체를 생성한 상태 => 비영속 상태
    Member member = new Member(); // Member는 엔티티 클래스이다.
    member.setId("member1");
    member.setUsername("회원1");
    ```
    
- 비영속 상태 시각화
    
    ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%205.png)
    
<br/>

### 영속

- 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태이다.
- 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라고 한다.
- `em.persist(엔티티)` 로 엔티티를 등록하거나,
- `em.find(ID)` 로 엔티티를 찾은 엔티티는 영속 상태로 변환된다.
- 예시 코드
    
    ```java
    //객체를 저장한 상태 => 영속 상태
    em.persist(member);
    ```
    
- 영속 상태 시각화
    
    ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%206.png)
    
<br/>

### 준영속

- '영속성 컨텍스트가 관리하던 영속 상태의 엔티티'를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
- 즉, 영속 상태였던 엔티티를 영속성 컨텍스트가 관리하지 않게 되면, 해당 엔티티는 준영속 상태가 된다.
- 준영속 상태의 엔티티는 영속성 컨텍스트의 관리를 받지 못한다.
- `em.detach(엔티티)` 를 호출하거나,
- `em.clear()` 로 영속성 컨텍스트의 내용을 모두 초기화하거나,
- `em.close()` 로 엔티티 매니저를 닫으면, 해당 영속성 컨텍스트에 영속 상태로 관리되던 엔티티는 준영속 상태로 변환된다.
- 예시 코드
    
    ```java
    //회원 엔티티를 영속성 컨텍스트에서 분리 => 준영속 상태
    em.detach(member);
    em.clear();
    em.close();
    ```
    
<br/>

### 삭제

- 엔티티를 영속성 컨텍스트와 DB에서 삭제한다.
- 예시 코드
    
    ```java
    //객체를 삭제한 상태 => 삭제
    em.remove(member);
    ```
    
<br/>

## 영속성 컨텍스트 특징

### 영속성 컨텍스트 특징

- **영속성 컨텍스트와 식별자 값**
    - 영속성 컨텍스트는 **엔티티를 식별자 값으로 구분**한다.
        - 식별자: `@Id` 를 통해, 기본키와 매핑된 프로퍼티
    - 따라서, 영속 상태는 식별자 값이 반드시 존재해야 한다.
- **영속성 컨텍스트와 DB 저장**
    - JPA는 보통 **트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영**한다.
    - 이것을 **플러시(Flush)** 라고 한다.

<br/>

### 영속성 컨텍스트의 장점

영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.

- **1차 캐시**
- **동일성 보장**
- **트랜잭션을 지원하는 쓰기 지연**
- **변경 감지**
- **지연 로딩**

지금부터 엔티티 CRUD 작업을 통해 알아보자.

<br/>

### 엔티티 조회

- 영속성 컨텍스트는 내부에 캐시를 가지고 있다.
    - 이것을 **1차 캐시**라고 한다.
- 영속 상태의 엔티티는 모두 이곳에 저장된다.
- 즉, 영속성 컨텍스트 내부에 `Map`이 하나 있는데, `Key=@Id로 매핑한 식별자(프로퍼티)` , `Value=엔티티 인스턴스` 라고 생각하면 된다.

<br/>

- 예시 코드
    1. 엔티티 영속상태 전환
    
    ```java
    //엔티티를 생성한 상태
    //비영속 상태
    Member member = new Member();
    member.setId("member1");
    member.setUsername("회원1");
    
    //엔티티 영속
    em.persist(member);
    ```
    
    1. 위 코드를 실행하면 아래 그림의 상태가 된다.
        
        ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%207.png)
        
        - 1차 캐시의 Key = 식별자 값(`@Id`와 매핑된 프로퍼티)
    2. **따라서, 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 DB의 기본 키 값이다.**
    3. 엔티티 조회
        
        ```java
        Member member = em.find(Member.class, "member1");
        ```
        
    4. 위 코드를 실행하면, **1차 캐시에서 엔티티를 찾는다.**
    5. 만약 찾는 엔티티가 1차 캐시에 존재하지 않으면, **DB에서 조회한다.**
        - 이때 Flush가 수행된다.
        - 자세한 것은 나중에 이어서 설명하도록 하겠다.

<br/>

- **1차 캐시에서 조회하기**
    - `em.find()` 을 호출하면, 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다.
    - 만약 찾는 엔티티가 있으면, **DB를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.** 이는 아래 그림과 같다.
        
        ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%208.png)
        
    - 아래 코드는 1차 캐시에 있는 엔티티를 조회한다.
        
        ```java
        //엔티티를 생성한 상태
        //비영속 상태
        Member member = new Member();
        member.setId("member1");
        member.setUsername("회원1");
        
        //1차 캐시에 저장됨
        em.persist(member);
        
        //1차 캐시에서 조회함
        em.find(Member.class, "member1")
        ```
        
<br/>

- **DB에서 조회하기**
    - 엔티티가 1차 캐시에 없으면, **엔티티 매니저는 DB를 조회해서 엔티티를 생성**한다.
    - 그리고 **1차 캐시에 저장한 뒤, 영속 상태의 엔티티를 반환**한다. 이는 아래 그림과 같다.
        
        ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%209.png)
        
        1. `em.find(Member.class, "member2")` 를 실행한다.
        2. `member2` 가 1차 캐시에 없으므로 DB에서 조회한다.
        3. 조회한 데이터로 `member2` 엔티티를 생성해서 1차 캐시에 저장한다. ⇒ 영속상태
        4. 조회한 엔티티를 반환한다.
    - 이제 `member2` 엔티티가 영속 컨텍스트의 1차 캐시에 존재하므로, 나중에 다시 `member2` 엔티티를 조회했을 때, 1차 캐시에서 바로 불러오게 된다.
    - 따라서, 성능상 이점을 누릴 수 있다.

<br/>

### 동일성 보장

- 아래 코드를 통해 식별자가 같은 엔티티 인스턴스를 조회해보자.
    
    ```java
    //member1과 member2의 식별자가 같다.
    member1 = em.find(Member.class, "member1");
    member2 = em.find(Member.class, "member1");
    
    //동일성 비교
    System.out.println(member1 == member2);
    //결과: true
    ```
    
    - `member1` 과 `member2` 는 서로 같은 엔티티를 조회했으므로, true라는 결과가 도출된다.
- 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.
- 따라서, 둘은 같은 인스턴스이며, 결과는 당연히 참이 나온다.
- **영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.**

> 동일성: == 비교  
동등성: equals() 비교

<br/>

### 엔티티 등록

- 엔티티 매니저를 사용해서 엔티티를 영속성 컨텍스트에 등록해보자.
    
    ```java
    EntityManager em = emf.createEntityManager();
    EntityTransaction transaction = em.getTransaction();
    
    //엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야한다.
    transaction.begin(); // [트랜잭션-시작]
    
    em.persist(memberA);
    em.persist(memberB);
    //아직 INSERT SQL을 DB에 보내지 않는다.
    
    //커밋하는 순산 DB에 INSERT SQL을 보낸다.
    transaction.commit(); // [트랜잭션-커밋]
    ```
    

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 모아둔다. 아래 그림은 이 과정을 `memberA` 엔티티에 대해 수행한 것과 같다.
    
    ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%2010.png)
    
    - **영속 컨텍스트가 `memberA` 엔티티를 1차 캐시에 저장함과 동시에, 관련 INSERT SQL을 쓰기 지연 SQL 저장소에 저장한다.**

- 이번에는 `memberB` 엔티티에 대해 수행해보자.
    
    ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%2011.png)
    
    - 이것도 마찬가지로 회원 엔티티 정보로 등록 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보관한다.
    - **쓰기 지연 SQL 저장소에는 총 2개의 등록쿼리가 저장되었다.**

- 이번에는 트랜잭션을 commit 해보자.
    
    ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%2012.png)
    
    - 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다.
        - **플러시는 영속성 컨텍스트의 변경내용을 DB에 동기화하는 작업이다.**
        - 플러시는 CRUD 작업한 엔티티를 DB에 반영한다.
        - 즉, 쓰기 지연 SQL 저장소에 모인 쿼리를 DB에 보낸다.
        - **플러시를 해도, 트랜잭션이 완료되어 종료되는 것은 아니다. 단지, DB에 변경 사항을 반영하는 것이다.**

- **트랜잭션을 지원하는 쓰기 지연이 가능한 이유**
    - 다음 로직을 2가지 경우로 생각해볼 수 있다.
        
        ```java
        begin(); //트랜잭션 시작
        
        save(A);
        save(B);
        save(C);
        
        commit(); //트랜잭션 커밋
        ```
        
        1. **데이터를 저장하는 즉시, 등록 쿼리를 DB에 보내고 마지막에 트랜잭션을 커밋하는 경우**
            - 위 코드에서 `save()` 마다 쿼리를 보내는 것과 동일하다.
            - 단순히 쿼리를 DB에 보내는 것일 뿐, 확정(commit)하는 것은 아니다.
            - 즉 다음과 같다.
            
            ```java
            begin(); //트랜잭션 시작
            
            save(A); //DB에 쿼리 보내기
            save(B); //DB에 쿼리 보내기
            save(C); //DB에 쿼리 보내기
            
            commit(); //트랜잭션 커밋
            ```
            
        2. **트랜잭션을 커밋할 때 모아둔 등록 쿼리를 DB에 보낸 후 커밋하는 경우**
            - 즉 다음과 같다.
            
            ```java
            begin(); //트랜잭션 시작
            
            save(A); //다른 곳(쓰기 지연 SQL 저장소)에 쿼리를 모아둔다.
            save(B); //다른 곳(쓰기 지연 SQL 저장소)에 쿼리를 모아둔다.
            save(C); //다른 곳(쓰기 지연 SQL 저장소)에 쿼리를 모아둔다.
            
            commit(); //트랜잭션 커밋 직전에, 미리 쿼리를 DB에 보낸다.
            ```
            
    - **위 두 가지의 경우는 결과가 모두 같다.**
    - **등록 쿼리를 그때 그때 DB에 전달해도(1번 경우), 결국 트랜잭션을 커밋해야만 의미가 있다. 따라서, 어떻게든 커밋 직전에만 DB에 쿼리를 전달하면 된다!**
        - 백날 SQL을 DB에 전달해도, 전달사항이 커밋되지 않으면 의미가 없다.
    - 바로 이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유이다.

<br/>

### 엔티티 수정

- SQL 수정 쿼리의 문제점
    - SQL을 사용하여, 수정 쿼리를 직접 입력한다면 어떤 문제가 발생할까? 아래 가정을 통해 알아보자.
    - 기존에 작성해둔 수정 쿼리
        
        ```sql
        UPDATE MEMBER SET NAME=?, AGE=? WHERE id=?
        ```
        
    - 변경된 요구사항에 의해 변경된 수정 쿼리
        
        ```sql
        UPDATE MEMBER SET NAME=?, AGE=?, GRADE=? WHERE id=?
        ```
        
    - 만약 새로이 변경된 수정 쿼리를 사용하여, "이름과 나이를 변경하는 데 실수로 등급 정보를 입력하지 않거나", "등급을 변경하는데 실수로 이름과 나이를 입력하지 않을 수" 있다.
    - 그렇다면 해당 상황을 해결하기 위해, 아래와 같은 쿼리를 추가하게 된다.
        - 이름만 수정하는 쿼리
        - 나이만 수정하는 쿼리
        - 등급만 수정하는 쿼리
    - **결국 직접적이든 간접적이든 비즈니스 로직이 SQL에 의존하게 된다.**

<br/>

- **변경 감지**
    - JPA는 이런 상황을 타개하기 위해, 변경 감지(Dirty Checking)를 통해 엔티티를 수정한다.
    - 예시 코드
        
        ```java
        EntityManager em = emf.createEntityManager();
        EntityTransaction transaction = em.getTransaction();
        transaction.begin(); //[트랜잭션 - 시작]
        
        //영속 엔티티 조회
        Member memberA = em.find(Member.class, "memberA");
        
        //영속 엔티티 데이터 수정
        memberA.setUsername("hi");
        memberA.setAge(10);
        
        //em.update(member); 이런 코드는 존재하지 않는다.
        
        transaction.commit(); //[트랜잭션 - 커밋]
        ```
        
        - 위 코드를 통해서 엔티티를 수정하고 DB에도 반영할 수 있다.
    - JPA로 엔티티를 수정할 때는, **단순히 엔티티를 조회해서 데이터만 변경하면 된다.**
    - 이러한 기능을 바로 **변경 감지(Dirty Checking)**이라고 한다.
    - 변경 감지 수행과정은 아래 그림과 같다.
        
        ![Untitled](/assets/img/2021-10-09-JPA_Persistence1/Untitled%2013.png)
        
        1. 트랜잭션을 커밋하면, 엔티티 매니저 내부에서 먼저 플러시(`flush()`)가 호출된다.
        2. 엔티티(현상태)와 스냅샷(원본상태)를 비교해서 변경된 엔티티를 찾는다.
        3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
        4. 쓰기 지연 저장소의 SQL을 DB에 보낸다.
        5. DB 트랜잭션을 커밋한다.
    - JPA는 엔티티를 **영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷(Snapshot)** 이라고 한다.
        - 즉, 스냅샷은 **엔티티가 처음으로 1차 캐시에 저장될 때의 모습을 저장해둔 것**이다.
    - 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
    - **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.**
        - 비영속, 준영속처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경해도 DB에 반영되지 않는다.

<br/>

- **변경 감지(Dirty Checking)에 의한, UPDATE 쿼리 형식**
    - 만약 아래와 같은 코드를 통해, 엔티티를 수정한다면 어떤 SQL이 DB에 전달될까?
        
        ```java
        transaction.begin();
        
        memberA = em.find(Member.class, "memberA");
        memberA.setUsername("변경된 이름");
        
        transaction.commit();
        ```
        
    - 예상한 SQL
        
        ```sql
        UPDATE MEMBER SET NAME=? WHERE id=?
        ```
        
        - 수정된 칼럼의 값만 변경되지 않을까?
    - 실제 SQL
        
        ```sql
        UPDATE MEMBER SET NAME=?, AGE=?, GRADE=?, ... WHERE id=?
        ```
        
        - 실제로는 수정하지 않은 칼럼을 포함한 모든 칼럼의 값이 변경된다.
    - 그렇다면 왜 이렇게 수정 SQL을 처리할까?
    - 이때의 장점은 다음과 같다.
        - 모든 필드를 사용하면 수정 쿼리가 항상 같다.(바인딩되는 데이터는 당연히 제외) 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 **재사용**할 수 있다.
        - DB에 동일한 쿼리를 보내면, DB는 이전에 한번 파싱된 쿼리를 **재사용**할 수 있다.
    - 하지만 필드가 많거나 저장되는 내용이 너무 크면, '수정된 필드만 사용해서' 동적으로 UPDATE SQL을 생성하는 전략을 선택할 수 있다.
        - 단 이때는 하이버네이트 확장 기능을 사용해야 한다.
        
        ```java
        @Entity
        @org.hibernate.annotations.DynamicUpdate // 수정 쿼리 동적 생성 설정
        @Table(name = "Member")
        public class Member { // 엔티티 클래스
        	...
        }
        ```
        
<br/>

### 엔티티 삭제

- 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.
- 예시 코드
    
    ```java
    Member memberA = em.find(Member.class, "memberA"); //엔티티 조회
    em.remove(memberA); //엔티티 삭제
    ```
    
- `em.remove(삭제할_엔티티)` 를 실행하면 해당 엔티티를 삭제할 수 있다.
- 엔티티 삭제 과정
    1. 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다.
    2. 나중에 트랜잭션이 커밋되어서, 플러시를 호출하면 실제 DB에 삭제 쿼리를 전달한다.
- **이렇게 삭제된 엔티티는 재사용하지 말고, 자연스럽게 가비지 컬렉터가 처리하도록 두는 것이 좋다.**

<br/><br/>

아직 영속성 관리에 대해 설명할 내용이 많이 남았다. 하지만, 본 포스팅 글이 너무 길어지기에 나눠서 포스팅하도록 하겠다.

<br><br>

---

<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>