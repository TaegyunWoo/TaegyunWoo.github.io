---
category: Interview
tags: [Interview]
title: "[CS Study] CPU 작동 원리"
date:   2023-01-26 22:50:00 
lastmod : 2022-01-26 22:50:00
sitemap :
  changefreq : daily
  priority : 1.0
---

# CPU 작동 원리

## CPU의 구성

![Untitled](/assets/img/2023-01-26-Interview_CPU/Untitled.png)

CPU는 크게 `연산장치` , `제어장치` , `레지스터` 로 구성된다.

### 연산장치 (ALU) 요약

- **산술연산과 논리연산을 수행**한다.
    > 그래서 산술논리연산장치라고도 불린다.
- 연산에 필요한 데이터를 `레지스터` 에서 가져오고, 연산 결과를 다시 `레지스터` 로 보낸다.
    - CPU 내부 버스를 통해, `ALU` 와 `레지스터` 가 통신한다.

### 제어장치 (Control Unit) 요약

- **명령어를 순서대로 실행할 수 있도록 제어**하는 장치이다.  
즉 컴퓨터 전체를 작동시키는 **엔진 역할**을 한다.
- **`주기억장치`에서 프로그램 명령어를 꺼내 해독**하고, 그 결과에 따라 **명령어 실행에 필요한 제어 신호를 `기억장치`, `연산장치`, `입출력장치`** 로 보낸다.
- 여러 장치가 보낸 신호를 받아, **다음에 수행할 동작을 결정**한다.

### 레지스터 요약

- 고속 기억장치
    > 컴퓨터에 존재하는 기억장치 중 가장 빠르다.
- 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장한다.
- 용도에 따라 `범용 레지스터` 와 `특수목적 레지스터` 로 구분된다.
    - `범용 레지스터` : 연산에 필요한 데이터나 연산 결과를 임시로 저장하는 레지스터
    - `특수목적 레지스터` : 특별한 용도로 사용하는 레지스터
- 주요 특수목적 레지스터
    - **MAR (메모리 주소 레지스터)**
        - 읽기와 쓰기 연산을 수행할 주기억장치의 주소를 저장한다.
        - 시스템 버스 중 하나인 **`주소 버스` 에 연결된 유일한 레지스터**이다.
        - 따라서 주소 정보를 가져올 때, 무조건 MAR을 사용해야 한다.
    - **PC (프로그램 카운터)**
        - 다음에 수행할 명령어의 주소를 저장한다.
    - **IR (명령어 레지스터)**
        - 현재 실행 중인 명령어를 저장한다.
    - **MBR (메모리 버퍼 레지스터)**
        - 주기억장치에서 읽어온 데이터 혹은 저장할 데이터를 임시로 저장한다.
    - **AC (누산기)**
        - 연산 결과를 임시로 저장한다.

<br/><br/>

## CPU의 동작 과정

### 동작 과정 개요

1. 주기억장치는 `입력장치에서 입력받은 데이터` 나, `보조기억장치에 저장된 프로그램` 을 읽어온다.
2. CPU는 프로그램을 실행하기 위해, `주기억장치에 저장된 프로그램 명령어와 데이터` 를 읽어와 처리하고, `처리결과` 를 다시 주기억장치에 저장한다.
3. 주기억장치는 `처리 결과` 를 보조기억장치에 저장하거나 출력장치로 보낸다.

**CPU의 제어장치가 위 과정을 순서대로 실행하도록 장치들을 제어한다.**

### 명령어 세트란?

명령어 세트란, **CPU가 실행할 명령어의 집합**이다.

명령어는 아래와 같이 구성된다

- **연산 코드 (OpCode)**
    - 실행할 연산
- **피연산자 (Operand)**
    - 필요한 데이터 or 저장 위치

### 명령어 처리 구조 (명령어 사이클)

`명령어 사이클` 이란, **CPU가 하나의 명령어를 처리하는 과정**을 뜻한다.

`명령어 사이클` 은 크게 아래와 같이 구분할 수 있다.

![Untitled](/assets/img/2023-01-26-Interview_CPU/Untitled%201.png)

1. **인출**
    - 수행할 다음 명령어를 가져온다.
2. **실행**
    - 가져온 명령어를 실행한다.
    - 만약 실행 이후에, 인터럽트가 발생하지 않았다면 다시 “인출” 전단계로 돌아간다.
3. **인터럽트**
    - 어떠한 예외가 발생하여, 기존의 프로세스가 중단된 상태
    - 인터럽트를 처리하기 위해, **`인터럽트 서비스 루틴 (ISR)` 을 호출**한다.
        - `인터럽트 서비스 루틴 (ISR)` : 인터럽트를 처리하기 위한 명령어들의 모음
    - 인터럽트가 처리되었다면, 다시 “인출” 전단계로 돌아간다.

아래는 인터럽트가 포함된 명령어 사이클의 상태도이다.

![Untitled](/assets/img/2023-01-26-Interview_CPU/Untitled%202.png)

### 명령어 인출 과정

1. `PC` 에 저장된 주소를 `MAR (기억장치 주소 레지스터)` 로 옮긴다.
    > `MAR` 은 시스템 버스 중 주소 버스에 연결된 유일한 레지스터이다.
2. ‘`MAR` 로 옮겨진 주소’에 저장된 명령어를 주기억장치에서 인출한다.
3. 인출한 명령어를 `MBR (기억장치 버퍼 레지스터)` 에 저장한다.
4. 다음 명령어를 인출하기 위해 `PC` 값 (다음 명령어의 주소) 을 1 증가시킨다.
5. `MBR` 에 저장된 명령어를 `IR (명령어 레지스터)` 에 전달한다.

```text
[T0]
MAR ← PC

[T1]
MBR ← Main Memory ('MAR로 옮긴 주소'에 저장된 명령어 데이터)
PC ← PC + 1

[T2]
IR ← MBR
```

### 명령어 실행 과정

`ADD AC, B` 명령어를 실행하는 과정을 예로 들어 설명하겠다.

1. `IR` 에 저장된 **“Operand(피연산자)인 B 데이터가 저장된 주소”** 를 `MAR` 로 옮긴다.
2. ‘`MAR` 로 옮겨진 B의 주소’로 주기억장치에 접근하여, B 데이터를 `MBR` 로 옮긴다.
3. `AC + B` 연산 결과를 `AC` 에 저장한다.

```text
[T0]
MAR ← IR (Operand B의 주소)

[T1]
MBR ← Main Memory ('MAR로 옮긴 B의 주소'에 저장된 데이터)

[T2]
AC ← AC + MBR

```

이미 인출이 진행되었고, 명령어만 실행하면 되기 때문에 `PC` 의 값은 건드릴 필요가 없다.

### 인터럽트 처리 과정

1. 현재 수행 중인 프로그램 실행을 중단하고, 그 문맥 (context) 를 저장한다.
    - 문맥 : 현재 수행 중인 상태 (`PC` , `연산결과` 등의 값)
2. `PC` 에 인터럽트 처리기 루틴 (`ISR`)의 시작주소를 세팅한다.
    - `PC` 에는 항상 다음 명령어의 주소가 저장된다.
    - 인터럽트를 처리하기 위해 `ISR` 이 다음에 수행되어야 하므로, `PC` 에 `ISR` 의 시작주소를 세팅해야 한다.
3. `ISR` 을 수행하며 인터럽트를 처리한다.
4. `ISR` 을 모두 처리한 후, 문맥을 복원하고 인터럽트된 기존 프로그램을 다시 수행한다.

### 인터럽트가 필요한 이유

- 인터럽트를 사용하여, 프로세서를 효율적으로 사용할 수 있다.
- **인터럽트가 없는 경우**, I/O 작업에 대해 CPU는 아래와 같이 동작할 것이다.
    
    ![Untitled](/assets/img/2023-01-26-Interview_CPU/Untitled%203.png)
    
    - CPU는 무조건 모든 작업을 **순차적으로(동기적으로) 수행**해야 한다.
    - 따라서 I/O 장치가 작업을 마칠 때까지 기다린 후, 다음 작업을 수행한다.
- **인터럽트가 있는 경우**, 아래와 같이 동작할 수 있다.
    
    ![Untitled](/assets/img/2023-01-26-Interview_CPU/Untitled%204.png)
    
    - 인터럽트가 있다면, CPU가 비동기적으로 작업을 할 수 있다.
    - **I/O 장치에게 일을 맡기고** 다음 작업을 이어서 수행할 수 있다.
    - 만약 I/O 장치의 작업이 종료되면, **인터럽트를 통해 CPU에게 이 사실을 알려주고, 필요한 추가 작업(인터럽트 처리)을 먼저 수행**할 수 있다.