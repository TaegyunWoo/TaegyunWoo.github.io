---
category: OS
tags: [OS]
title: "[OS] 운영체제 구조"
date:   2021-09-28 17:00:00 
lastmod : 2021-09-28 17:00:00
sitemap :
  changefreq : daily
  priority : 1.0
---

<br/><br/>

# 운영체제 구조

## 운영체제 서비스

### 개요

- 운영체제는 사용자(or 프로그램)에게 프로그램의 실행 환경을 제공한다.

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2028.png)

- **user interfaces**
    - 사용자 인터페이스
    - GUI, batch파일, command line 모두 user interface에 해당된다.
- **system calls**
    - 운영체제의 커널모드로 동작하는 중개자(관리자)역할을 수행한다.
- **services**
    - 프로그램 개발과 실행에 대해 편리한 환경을 제공한다.

<br/>

## 운영체제 서비스: 사용자 업무 서비스

### 개요

- 사용자 업무를 수행하는 데 필요한 기능을 제공하는 운영체제 서비스에 대해 설명하도록 하겠다.

<br/>

### 사용자 인터페이스

- **명령어 라인 인터페이스 (CLI: Command Line Interface)**
- **배치 인터페이스**
- **GUI**

<br/>

### 프로그램 실행

- Program Execute
- 프로그램을 메모리에 적재, 실행, 실행 종료하는 서비스이다.

<br/>

### 입출력 연산

- 프로그램 실행에서 요구하는 파일 또는 입출력 장치 등의 입출력 서비스이다.

<br/>

### 파일 시스템

- 파일 조작, 관리를 수행하는 서비스이다.

<br/>

### 통신

- 동일한 컴퓨터 또는 네트워크로 연결된 컴퓨터에 있는 **프로세스 간 정보 교환**을 수행한다.
- **통신 기법**
    - 메시지 전달 기법
        - 운영체제(Kernel)이 관여한다.
        
        ![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2029.png)
        
    - **공유 메모리 기법**
        - 공유 메모리 기법 == 생산자/소비자 모델
        - 버퍼 관리를 잘 해주어야 한다.
        
        ![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2030.png)
        
<br/>

### 오류 탐지

- 운영체제는 가능한 모든 오류를 인지하고 있어야 한다.

> 하지만, 모든 오류를 인지하기란 어렵다.

<br/><br/>

## 운영체제 서비스: 시스템 자원 서비스

### 개요

- 시스템의 자원을 공유하여 시스템의 효율적인 운영을 보장하는 서비스

<br/>

### 자원 할당

- 다수의 사용자나 다수의 작업들이 동시에 실행될 때 각각에 자원을 할당해주는 서비스이다.
- 자원의 종류
    - CPU cycles
    - main memory
    - file storage
    - I/O devices

<br/>

### 회계

- 어떤 사용자가 어떤 자원을 얼마나 사용하는지 기록하고 관리하는 서비스이다.

<br/>

### 보호와 보안

- **보호**
    - 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 서비스이다.
    - 즉, 파일에 대한 접근 권한 권리를 뜻한다.
- **보안**
    - 외부로부터 시스템 보안을 유지하기 위해 사용자 인증, 부적합한 접근 방지 등을 수행하는 서비스이다.

<br/><br/>

## 사용자 인터페이스

### 사용자 인터페이스 종류

- **명령어 라인 인터페이스 (CLI: Command Line Interface)**
- **배치 인터페이스**
- **GUI**

<br/>

### Command Line Interface (CLI)

- CLI나 명령어 해석기를 통해 명령어를 직접 입력한다.
- CLI는 커널이나 시스템 프로그램으로 구현된다.
- 선택 가능한 여러 개의 명령어 해석기를 제공한다.
    - ex) 리눅스의 본쉘, c쉘 등

- **명령어 해석기**
    - 역할
        - 사용자의 명령어를 가져와 실행한다.
    - 명령어 해석기의 종류
        - **명령어 해석기가 명령어 코드를 포함하는 경우**
            - 이때, 명령어의 개수가 명령어 해석기의 크기를 결정한다.
            
            ![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2031.png)
            
        - **명령어 해석기가 명령어 목록만 가지고 있는 경우**
            - 명령어 해석기의 크기가 작아진다.
            
            ![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2032.png)

<br/>

### GUI

- 사용자 친화적인 상징 인터페이스이다.
- 많은 시스템들이 CLI와 GUI 인터페이스를 모두 지원한다.
    - Microsoft Windows
        - CLI 명령어 셸을 가지고 있는 GUI이다.
    - Apple Mac OS
        - UNIX 커널과 셸을 가지고 있는 Aqua GUI이다.
    - Unix, Linux
        - 선택적인 GUI를 가진 CLI이다.

<br/><br/>

## 시스템 콜

### 시스템 콜이란?

- 시스템 콜은 **'운영체제가 제공하는 서비스에 대한 인터페이스'를 사용자에게 제공**한다.
- 일반적으로 고급 언어 (c , c++)로 작성된 루틴 형태로 제공된다.
- 대부분의 경우, '직접적인 시스템 콜 사용' 대신 'API(Application Program Interface)'를 통해 접근한다.
    - 사용자 프로그램이 운영체제가 제공하는 서비스에 접근하고자 한다. ⇒ 이때, API를 사용한다. ⇒ API를 통해, 시스템 콜을 요청하여 운영체제 서비스의 기능을 수행하도록 할 수 있다.
    
    > 이때 API는 시스템 콜을 사용할 수 있도록 하는 API를 뜻한다.
    > 

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2033.png)

<br/>

### 시스템 콜 API의 대표 종류

- Windows
    - Win32 API
- UNIX, LINUX, Mac OS
    - POSIX API
- Java Virtual Machine
    - Java API

> POSIX: Portable Operating System Interface (이식 가능 운영체제 인터페이스)

<br/>

### 시스템 콜 예시

아래 그림은 `cp in.txt out.txt` 명령(파일 복사 명령어)에 대한 시스템 콜 API 호출 순서에 대한 예시이다.

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2034.png)

<br/>

### 시스템 콜 구현

- **각 시스템 콜에 대해, 숫자(index)가 부여된다.**
- **시스템 콜 인터페이스가 '시스템 콜 테이블'을 관리한다.**
- 시스템 콜 인터페이스
    - 운영체제 커널 내에 있는 요청된 시스템 콜을 요청한다.
    - 시스템 콜의 반환 상태와 해당 반환 값을 반환한다.

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2035.png)

<br/>

### 시스템 콜 특징

- **개발자는 시스템 콜이 어떻게 구현되는지 알 필요가 없다.**
    - 개발자는 API를 제대로 사용하고, 운영체제가 시스템 콜의 결과로 무슨 일을 하는지만 알면 된다.
    - 운영체제 인터페이스의 구현부는 API에 의해 숨겨진다.

<br/>

### 시스템 콜 유형(종류)

- 프로세서 제어
- 파일 관리
- 장치 관리
- 정보 관리
- 통신
- 보호

<br/><br/>

## 시스템 콜에 파라미터 전달하기

### 운영체제에 매개변수를 전달하는 방법의 종류

- 매개변수를 레지스터에 전달하는 방법
- **매개변수를 메모리의 블럭, 테이블에 저장하는 방법**
- 프로그램이 매개변수를 스택에 넣는 방법

<br/>

### 매개변수를 레지스터에 전달하기

- 가장 단순한 방법이다.
- 하지만, 레지스터 개수보다 더 많은 매개변수가 있는 경우, 한계가 있다.

<br/>

### 매개변수를 메모리의 블럭, 테이블에 저장하는 방법

- 블럭의 **메모리 주소**가 레지스터에 매개변수로 전달된다.

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2036.png)

<br/>

### 프로그램이 매개변수를 스택에 넣는 방법

- 운영체제가 스택으로부터 매개변수를 꺼낸다.
- **위에서 설명한 블럭 방식과 스택 방식은 매개변수의 개수나 길이에 제약을 받지 않는다.**

<br/><br/>

## 시스템 프로그램

### 시스템 프로그램이란?

- 시스템 프로그램은 프로그램 개발과 실행에 편리한 환경을 제공한다.
- 운영체제에 대한 대부분 사용자의 인식은 시스템 콜보다는 시스템 프로그램에 의해 결정된다.

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2037.png)

<br/>

### 시스템 프로그램의 종류

- 파일 관리
- 상태 정보
- 프로그래밍 언어 지원
- 프로그램 적재와 실행
- 통신
- 백그라운드 서비스
    - 부팅시 살아나는 서비스
    - 백그라운드 서비스의 종류
        - 시스템 시작시 실행됐다가 다시 종료되는 서비스
        - 시스템 시작해서 종료시까지 살아있는 서비스

<br/><br/>

## 운영체제 설계 및 구현

### 개요

- 정형화된 해결책은 존재하지 않는다. 하지만 성공적인 접근 방법들이 존재한다.
- 운영체제 별로 내부 구조는 매우 다르다.
- 운영체제 설계 내용은 **하드웨어**와 **시스템 타입**에 따라 달라진다.

<br/>

### 정책과 기법

- 중요한 원칙
    - **'정책'과 '메커니즘'의 분리가 필수이다.**
    - **정책**
        - 무엇을 할 것인가?
    - **기법**
        - 어떻게 할 것인가?
- **정책과 기법을 분리해야한다.**
    - 그래야 나중에 정책이 변경될 때 최대한의 융통성이 생긴다.
    - 예시
        - 기법: CPU를 계속 점유하는 것을 방지하기 위해 Timer 사용한다.
        - 정책: 특정 사용자에게 타이머를 얼마나 오랫동안 설정할 것인지 결정한다.

<br/>

### 구현

- 다양성
    - 초기: 어셈블리어
    - 현재: C, C++ 사용
- 언어 혼합 사용
    - 하위 수준: 어셈블리어
    - 중요 부분: C
    - 시스템 프로그램: C, C++, PERL, Python과 같은 스크립트 언어

<br/><br/>

## 운영체제 구조

### 개요

- 범용 운영체제는 매우 큰 프로그램이다.
- 다양한 방법으로 운영체제의 구성을 할 수 있다.

<br/>

### MS-DOS

- 최소의 공간에 최대의 기능을 제공하도록 작성되어있다.
- 특징
    - 모듈로 제대로 분할되지 않았다.
    - 인터페이스와 기능 계층이 잘 분리되지 않았다.

> BIOS: Basic Input/Output System  
UEFI: Unified Extensible Firmware Interface (BIOS 대체제)

<br/>

### UNIX

- UNIX는 아래 두 가지 부분으로 분리되어있다.
    - 시스템 프로그램
    - 커널 (Kernel)
- 특징
    - 단순하지도 않지만 계층 구조도 없는 형태이다. (초기 UNIX)

<br/>

### 계층적 접근

- 운영체제는 여러 갱의 계층으로 구분된다.
- 각 계층은 하위 계층 위에 만들어진다.
- 최하위 계층: 하드웨어
- 최상위 계층: 사용자 인터페이스

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2038.png)

<br/>

### 마이크로 커널 시스템 구조

- 커널이 커져서 관리가 어려워졌다.
    - 따라서, '가능한 많은 기능'을 커널에서 사용자 공간으로 옮겨 커널을 최소화한다.
- 사용자 모듈 간의 통신은 **message passing**을 사용한다.
- **Mach** : 첫 마이크로 커널
- 장점
    - 마이크로커널은 확장하기 좋다.
    - 새로운 하드웨어에 이식이 쉽다.
    - 신뢰성 향상 (커널 모드가 작다.)
    - 보안성 향상
- 단점
    - 사용자와 커널 간의 통신으로 인한 성능 오버헤드 발생(지연)

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2039.png)

<br/>

### 모듈

- 대부분의 현대 운영체제 시스템은 적재 가능한 모듈로 구현된다.
    - 핵심(core)커널이 다른 모듈의 기능을 필요로 할 때, 해당 모듈과 연결하여 기능을 사용한다.
    
    ![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2040.png)
    
- LKM: Loadable Kernel Modules
- 모듈은 객체 지향 기법이다.

<br/><br/>

## 하이브리드 시스템

### 개요

- 대부분의 현대 운영체제는 오직 한가지 모델만을 사용하지 않는다.
- Linux, Solaris의 커널은 단일구조이지만, 함수의 동적 적재는 모듈화 기법을 사용한다.
- 윈도우도 대부분이 단일구조이지만, 다른 서브시스템의 특징에 따라 마이크로커널을 채택한다.

<br/>

### Mac OS 구조

![Untitled](/assets/img/2021-09-28-OS_Structure/Untitled%2041.png)

<br/><br/>

## 운영체제 디버깅

- 운영체제는 오류 정보를 포함하는 log file을 생성한다.
- 애플리케이션이 죽으면 프로세스의 메모리를 캡처한 코어 덤프를 생성한다.
- **운영체제가 죽으면 커널 메모리를 캡처한 "비정상 종료 덤프"를 생성한다.**
    - 해당 덤프를 통하여, 운영체제가 죽은 원인을 분석한다.

<br><br>

---

<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>