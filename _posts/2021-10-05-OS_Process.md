---
category: OS
tags: [OS]
title: "[OS] 프로세스"
date:   2021-10-05 22:00:00 
lastmod : 2021-10-05 22:00:00
sitemap :
  changefreq : daily
  priority : 1.0
---

<br/><br/>

# 프로세스

## 개요

### 프로세스 개념

- 프로세스는 과거와 현재에 따라, 용어의 차이가 존재한다.
- 과거
    - 일괄처리 시스템: 한번에 하나의 프로세스 밖에 안된다.
    - 프로세스 = Job
- 현재
    - 시분할 시스템
    - 프로세스 = Task
- 프로세스와 Job, Task 를 동일한 개념으로 사용한다.

<br/>

### 프로그램 vs 프로세스

- 프로그램
    - 수동적
- 프로세스
    - 능동적
    - 실행 가능 파일(프로그램)이 메모리에 올라가면 프로세스가 된다.
- 한 프로그램은 여러 프로세스가 될 수 있다.
    - 어떤 프로세스의 공유 가능한 부분을 여러 사용자가 사용시, 여러 프로세스가 된다.
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2042.png)

<br/><br/>

## 프로세스와 메모리

### 프로세스 구성요소

- **PC (Program Counter)**
    - 다음에 수행할 명령어를 가리킨다.
- **Registers**
    - 추후에 자세히 설명한다.
- **stack**
    - 임시자료 저장
    - Ex) 함수 콜스택 등
- **heap**
    - 동적으로 할당되는 메모리
    - 자바의 **new**
    - C의 **malloc()**
- **data**
    - 전역변수
- **text (code)**
    - 프로그램 코드

<br/>

### 메모리에 프로세스가 배치된 형태

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2043.png)

- **stack**
    - 임시자료 저장
    - Ex) 함수 콜스택 등
- **heap**
    - 동적으로 할당되는 메모리
    - 자바의 **new**
    - C의 **malloc()**
- **data**
    - 전역변수
- **text (code)**
    - 프로그램 코드

<br/><br/>

## 프로세스 상태

### 프로세스 상태 종류

- **new**
    - 프로세스 생성 상태
- **running**
    - 프로세스 실행 상태
- **waiting**
    - 프로세스 대기 상태
    - 어떤 이벤트가 발생할 때까지 대기한다.
- **ready**
    - 프로세스 준비 상태
    - 실행 준비 완료 상태이다.
    - **무조건 프로세스 실행 전에 거쳐야 하는 단계이다.**
    - **즉 이 상태를 건너뛰고, 다른 상태에서 바로 running 상태가 될 수 없다.**
- **terminated**
    - 프로세스 종료 상태

<br/>

### 프로세스 상태도

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2044.png)

- **반드시 ready 상태에서만 running 상태로 변경될 수 있다.**
- 아래 그림은 보다 보기 쉽게 번역한 것이다.

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2045.png)

<br/><br/>

## 프로세스 제어 블록 (PCB)

### 프로세스 제어 블록이란?

- **프로세스 제어 블록 = PCB(Process Control Block)**
- PCB는 프로세스의 정보를 담고있다.
- 개별 프로세스마다 PCB가 존재한다.

<br/>

### PCB 구조

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2046.png)

<br/>

### 프로세스간 CPU 전환

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2047.png)

<br/><br/>

## 쓰레드

### 쓰레드란?

- 쓰레드는 **프로세스보다 작은 독립된 실행 단위**이다.
- 프로세스가 한 개 이상의 쓰레드를 갖을 수 있다.
- 여러 쓰레드를 가진 프로세스는 한 순간에 하나 이상의 일을 할 수 있다.
- 현대의 운영체제
    - PCB가 확장되어 쓰레드에 관한 정보를 포함한다.

<br/>

### 쓰레드 예시

- 자동 오타 검사 기능 ⇒ 쓰레드 1
- 자동 저장 기능 ⇒ 쓰레드 2

위 두 가지를 동시에 수행하는 문서편집 프로세스

<br/>

### 쓰레드 구조

- 싱글 쓰레드
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2048.png)
    
- 멀티 쓰레드
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2049.png)

<br/>

## 프로세스 스케줄링

### 개요

- 다중 프로그래밍의 목적은 프로세스를 항상 실행하여, CPU 이용을 최대화하는 것이다.
- 따라서, 프로세스 스케줄링을 통해 적절히 프로세스를 실행한다.

<br/>

### 프로세스 스케줄러

- **프로세스 스케줄러는 'ready' 상태인 여러 프로세스 중에서 CPU에 다음 실행할 프로세스를 선택한다.**

<br/>

### 스케줄링 큐

- **Job Queue**
    - 모든 프로세스에 대한 큐
- **Ready Queue**
    - 메인 메모리에 있고, ready 상태인 프로세스에 대한 큐
- **Device Queue**
    - I/O 장치에 대한 큐

<br/>

### Ready Queue

- 연결 리스트 구조를 갖는다.

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2050.png)

<br/>

### 프로세스 스케줄링 과정

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2051.png)

<br/>

### 스케줄러 종류

- **Short-term scheduler**
    - CPU scheduler 와 동일한 것이다.
    - **다음에 실행할 프로세스를 선택하고 CPU를 할당한다.**
    - **따라서, "ready 상태에서 running 상태"로 변경될 때 사용된다.**
- **Long-term scheduler**
    - Job scheduler 와 동일한 것이다.
    - **준비완료 큐에 넣을 프로세스를 선택한다.**
    - **따라서, "new 상태에서 ready 상태"로 변경될 때 사용된다.**
    - 동시에 실행가능한 프로세스의 개수를 제한할 수 있다.
- **Medium-term scheduler**
    - 하이브리드 시스템에서 사용된다.
    - 일종의 Job scheduler이다.
    - 스와핑 기법을 사용한다.
        - 메인 메모리에 너무 많은 프로세스가 있을 때 사용되는 기법
        - 일부 프로세스를 메인 메모리에서 해제하고, 하드디스크에 넣는다. ⇒ **Swap in**
        - 하드디스크에 있는 프로세스가 필요할 땐, 다시 메인 메모리에 로드한다. ⇒ **Swap out**

<br/><br/>

## 문맥 교환

### 문맥 교환이란?

- CPU가 다른 프로세스로 전환되려면, 시스템은 현재 프로세스의 상태를 저장(백업)해야한다.
- 그리고 전환하려고 하는 새로운 프로세스를 찾아서 로딩해야한다.
- **즉 PCB 저장 및 로드 과정이 필요하다.**
- **이러한 과정을 문맥 교환이라고 한다.**

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2052.png)

<br/>

### 문맥교환 오버헤드

- 문맥 교환을 진행하는 동안은 일을 안하는 것과 같다. 즉, 오버헤드가 발생한다.

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2053.png)

<br/>

### 문맥 교환 원리

- 문맥 교환은 H/W를 통해 수행된다.
    - 왜냐하면, S/W보다 H/W가 더 빠르기 때문이다.
- **문맥 교환은 현행 레지스터 집합에 대한 포인터를 변경하는 것을 의미한다.**
    - **하지만 레지스터 집합보다 활성 프로세스가 많다면, 레지스터 자료를 메모리에 복사해야 한다.**

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2054.png)

<br/><br/>

## 프로세스에 대한 연산

프로세스 생성 연산을 집중적으로 알아보자.

### 프로세스 생성 연산

- 부모 프로세스가 자식 프로세스를 만드는 연산이다.
- 이러한 과정으로 다른 프로세서를 생성하면서 프로세스의 트리를 만든다.
- 프로세스 트리
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2055.png)
    
    > 최상단 init 프로세스의 pid는 항상 1이다.

<br/>

### 상세 설명

- 일반적으로 Process ID (PID)를 통해, 프로세스를 식별하고 관리한다.
- 부모, 자식 프로세스 간의 자원 공유 방법
    - **모두 공유**
    - **부분 공유**
    - **공유 안함**
- 부모, 자식 프로세스 실행 유형
    - **병행 수행**
        - 부모 프로세스와 자식 프로세스가 동시에 독립적으로 실행된다.
    - **부모가 자식이 종료될 때 까지 기다림**

<br/>

### 프로세스에 생성

- 새로운 프로세스의 Address space (주소공간) 사용방법 종류
    - 자식이 부모와 동일한 프로그램과 데이터를 사용하는 방법
    - 자식이 새 프로그램으로 로드되는 방법
- Unix 예시
    - 부모와 자식 프로세스는 'fork' 명령문에서부터 실행된다.
    - 해당 명령문(`fork()`)을 호출한 프로세스가 부모 프로세스가 되고, 새로운 자식 프로세스를 생성한다.
    - fork 함수에 의해 생성된 자식 프로세스는 부모 프로세스의 메모리를 그대로 복사하여 갖는다.
    - fork 함수 호출 이후 코드부터 각자의 메모리를 사용하여 실행한다.
    - **'fork' 명령문의 반환값**
        - fork() ⇒ 본인의 자식 PID를 반환한다.
        - fork() 의 반환값이 0일 땐, 이미 본인이 자식 프로세스인 경우이다.

![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2056.png)

- 예시
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2057.png)

<br/>

### 프로세스 종료

- 프로세스 종료( **exit()** ) 시, 자식에게서 부모로 상태 데이터(실행 결과)가 반환된다.
- 운영체제가 자원을 회수한다.
- 부모가 자식을 강제 종료하는 경우들 ( **abort()** )
    - **자식이 할당받은 자원을 초과 사용하려는 경우**
    - **자식에게 할당한 Task가 더 이상 필요하지 않을 경우**
    - **부모가 먼저 exit할 경우**
        - 부모가 exit시 나머지 자식들은 모두 exit된다. ⇒ 연쇄 종료
- **좀비 프로세스**
    - 자식 종료 후, 부모가 wait를 불러주지 않아, 리소스가 반환되지 않는 경우
    - 자식 종료 후, 부모가 wait를 부르는 시간 동안 자식은 좀비 상태가 된다.
    
    ![Untitled](/assets/img/2021-10-05-OS_Process/Untitled%2058.png)
    
- **고아 프로세스**
    - 부모가 먼저 exit되어, wait를 부르지 못하여 자식처리가 불가한 상황에 자식이 고아 프로세스가 된다.
- **부모의 wait란?**
    - 자식이 종료된 후, 호출되는 것이다.
    - 자식의 자원 반환, 리턴값 가져오기 등을 수행한다.

<br><br>

---

<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>