I"b\<p><br/><br/></p>
<h1 id="section">제어 유닛</h1>
<h2 id="section-1">개요</h2>
<h3 id="cpu-">CPU 구조</h3>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled.png" alt="Untitled" /></p>
<br/>
<h3 id="section-2">프로세서의 기능 정의</h3>
<ul>
<li>명령어 세트
<ul>
<li>연산 코드</li>
<li>주소지정 방식</li>
<li>레지스터</li>
</ul>
</li>
<li>시스템 버스
<ul>
<li>I/O 모듈 인터페이스</li>
<li>기억장치 모듈 인터페이스</li>
</ul>
</li>
<li>시스템 버스와 운영체제
<ul>
<li>인터럽트 처리 조직</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">제어 유닛</h3>
<ul>
<li>제어 유닛이란?
<ul>
<li>프로세서 내의 여러가지 요소들을 제어한다.</li>
<li>컴퓨터 전체를 작동시키는 엔진이다.</li>
</ul>
</li>
<li><strong>프로세서의 한 부분으로서 실제로 어떤 일이 일어나게끔 한다.</strong>
<ul>
<li>실행될 프로그램에 의해 결정되는 순서대로 <strong>마이크로 연산</strong>을 실행한다.
<ul>
<li>마이크로 연산: 기계 명령어가 실행되는 과정 (자세한 것은 조금있다 다룬다.)</li>
</ul>
</li>
<li>제어유닛은 각 마이크로 연산을 실행시키기 위한 <strong>제어신호</strong>를 발생시킨다.</li>
</ul>
</li>
<li>제어 유닛이 생성하는 제어신호의 종류
<ul>
<li><strong>프로세서 외부로의 제어신호</strong>
<ul>
<li>기억장치 및 I/O 모듈과의 데이터 교환</li>
</ul>
</li>
<li><strong>프로세서 내부로의 제어신호</strong>
<ul>
<li>레지스터들 간에 데이터 이동</li>
<li>ALU 연산</li>
<li>내부 연산 통제</li>
</ul>
</li>
</ul>
</li>
<li>제어 유닛 구현 방법
<ul>
<li>
<p><strong>하드 와이어</strong></p>
<ul>
<li>H/W 기반 제어 방식</li>
</ul>
</li>
<li>
<p><strong>마이크로 프로그래밍</strong></p>
<ul>
<li>S/W 기반 제어 방식</li>
</ul>
<blockquote>
<p>우리는 마이크로 프로그래밍을 위주로 알아볼 것이다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-4">마이크로 연산</h2>
<h3 id="section-5">마이크로 연산?</h3>
<ul>
<li>프로그램
<ul>
<li>일련의 <strong>명령어 사이클</strong>로 구성되어 실행된다.</li>
</ul>
</li>
<li>명령어 사이클
<ul>
<li>다수의 더 작은 단위(<strong>서브 사이클</strong>)들로 구성된다.</li>
</ul>
</li>
<li>서브 사이클
<ul>
<li>프로세서 레지스터를 포함하고 있는 일련의 단위로 구성된다.</li>
<li>이것을 <strong>마이크로 연산</strong>이라고 한다.</li>
<li>가장 세분화된 프로세서의 기능적 or 원자 연산이다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%201.png" alt="Untitled" /></p>
<br/>
<h3 id="section-6">명령어 인출 과정</h3>
<ol>
<li>
<p>PC에 저장된 주소를 MAR(기억장치 주소 레지스터)로 옮긴다.</p>
<ul>
<li>MAR이 시스템 버스의 주소 버스에 연결된 유일한 레지스터이다.</li>
</ul>
</li>
<li>
<p>명령어를 가져온다.</p>
<ol>
<li>(MAR 내에 있는) 원하는 주소가 주소 버스로 내보내지고, 제어 유닛은 제어 버스로 READ 명령을 보낸다.</li>
<li>그 결과로, 기억장치로부터 읽혀진 명령어는 데이터 버스를 통하여 MBR(기억장치 버퍼 레지스터)에 저장된다.</li>
<li>다음 명령어의 실행 준비를 위해 PC가 1 증가한다.</li>
</ol>
</li>
<li>
<p>MBR의 내용을 IR(명령어 레지스터)로 이동시킨다.</p>
<ul>
<li>간접 사이클이 수행될 경우를 위해 MBR을 비워두기 위함이다.</li>
</ul>
<blockquote>
<p>간접 사이클에 대한 내용은 <a href="https://taegyunwoo.github.io/comput-struct/ComputerStructure_ProcessorGroupAndFunction#14">이전 게시글</a>을 참고하자.</p>
</blockquote>
</li>
</ol>
<br/>
<h3 id="section-7">마이크로 연산: 명령어 인출 사이클</h3>
<ul>
<li>
<p>명령어 인출의 마이크로 연산 절차</p>
<ul>
<li>
<p>t1</p>
<ul>
<li><strong>MAR ← (PC)</strong></li>
</ul>
</li>
<li>
<p>t2</p>
<ul>
<li><strong>MBR ← memory</strong></li>
<li><strong>PC ← (PC) + I</strong></li>
</ul>
<blockquote>
<p>I : 명령어의 길이</p>
</blockquote>
</li>
<li>
<p>t3</p>
<ul>
<li><strong>IR ← (MBR)</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>한 클록 사이클</p>
<ul>
<li>t1, t2, t3 은 각각 하나의 클록 사이클 시간을 나타낸다.</li>
<li>t1 : 첫번째 클록 사이클 시간</li>
<li>t2 : 두번째 클록 사이클 시간</li>
<li>t3 : 세번째 클록 사이클 시간</li>
</ul>
</li>
<li>
<p>인출 사이클 구성</p>
<ul>
<li>3단계의 클록(t)</li>
<li>4개의 마이크로 연산</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%202.png" alt="Untitled" /></p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%203.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-8">마이크로 연산: 간접 사이클</h3>
<ul>
<li>명령어가 인출되면, 제어 유닛은 <strong>간접 주소지정 방식을 사용한 오퍼랜드</strong>가 있는지 확인한다.
<ul>
<li>명령어가 간접 주소지정 방식을 사용할 때
<ul>
<li><strong>간접 사이클이 실행 사이클보다 먼저 수행되어야 한다.</strong></li>
</ul>
</li>
</ul>
</li>
<li>간접 사이클의 마이크로 연산 절차
<ul>
<li>t1
<ul>
<li>
<p><strong>MAR ← (IR(address))</strong></p>
<ul>
<li>address : 유효 주소가 담긴 곳의 주소</li>
</ul>
<blockquote>
<p>유효 주소에 대한 내용은 <a href="https://taegyunwoo.github.io/comput-struct/ComputerStructure_InstructionSet#33">이전 게시글</a>을 참고하자.</p>
</blockquote>
</li>
</ul>
</li>
<li>t2
<ul>
<li><strong>MBR ← memory</strong>
<ul>
<li>memory에서 유효 주소값을 가져온다.</li>
</ul>
</li>
</ul>
</li>
<li>t3
<ul>
<li><strong>IR(address) ← (MBR(address))</strong>
<ul>
<li>address : 유효주소값</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>상세 설명
<ul>
<li><strong>IR의 주소 필드가 MBR로부터 들어오는 주소로 갱신된다.</strong>
<ul>
<li>이때 들어오는 주소는 직접주소(유효주소)이다.</li>
</ul>
</li>
<li><strong>그러면 IR은 이제 간접 주소 지정방식이 사용되지 않은 상태가 된다.</strong>
<ul>
<li>실제로 원하는 명령어의 주소가 IR에 담기기 때문이다.</li>
</ul>
</li>
<li><strong>간접 사이클을 마치고나면, 최종적으로 실행 사이클을 위한 준비가 완료된다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-9">마이크로 연산: 인터럽트 사이클</h3>
<ul>
<li>
<p>인터럽트 사이클이란?</p>
<ul>
<li>인터럽트가 발생했을 때, 수행되는 사이클이다.</li>
</ul>
</li>
<li>
<p>인터럽트 사이클의 마이크로 연산 절차</p>
<ul>
<li>t1
<ul>
<li><strong>MBR ← (PC)</strong>
<ul>
<li>복귀할 주소값을 백업할 준비를 한다.</li>
<li>참고로, <strong>주소값을 데이터처럼 처리</strong>하기 때문에 MBR에 넘긴다.</li>
</ul>
</li>
</ul>
</li>
<li>t2
<ul>
<li><strong>MAR ← save-address</strong>
<ul>
<li>save-address: 복귀할 주소가 저장된 곳의 주소</li>
</ul>
</li>
<li><strong>PC ← routine-address</strong>
<ul>
<li>routine-address: ISR의 시작주소</li>
</ul>
</li>
</ul>
</li>
<li>t3
<ul>
<li><strong>memory ← (MBR)</strong>
<ul>
<li>MBR에 담긴 복귀 주소값을 메모리에 저장한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%204.png" alt="Untitled" /></p>
</li>
<li>
<p>상세 설명</p>
<ul>
<li>PC의 내용이 MBR로 보내져, 인터럽트 수행이 끝난 후에 복귀할 때 사용할 수 있게끔 한다.</li>
<li>MAR에는 PC의 내용이 저장될 위치의 주소가 적재된다. 그리고 PC에는 인터럽트 처리 루틴의 시작 주소가 적재된다.</li>
<li>PC의 이전 값을 가지고 있는 MBR의 내용을 기억장치에 저장한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="add">마이크로 연산: 실행 사이클 - ADD</h3>
<ul>
<li>인출·간접·인터럽트 사이클과 실행 사이클의 차이점
<ul>
<li>인출·간접·인터럽트 사이클은 매번 동일한 마이크로 연산이 반복된다.</li>
<li>실행 사이클은 N개의 서로 다른 연산코드(실행 명령어)를 위해, N가지 마이크로 연산들이 존재한다.
<ul>
<li>즉, 실행 사이클은 어떤 실행인지에 따라 <strong>마이크로 연산들이 다양하게 사용</strong>된다.</li>
</ul>
</li>
</ul>
</li>
<li><code>ADD R1, X</code> 의 마이크로 연산 절차
<ul>
<li><code>ADD R1, X</code> 의 의미: R1(레지스터1)의 값과 X값을 더하고, R1에 결과를 저장한다.</li>
<li>t1
<ul>
<li><strong>MAR ← (IR(address))</strong>
<ul>
<li>address: 연산할 X의 주소</li>
</ul>
</li>
</ul>
</li>
<li>t2
<ul>
<li><strong>MBR ← memory</strong>
<ul>
<li>X에 저장된 값을 MBR에 전달한다.</li>
</ul>
</li>
</ul>
</li>
<li>t3
<ul>
<li><strong>R1 ← (R1) + (MBR)</strong>
<ul>
<li>ALU를 통해, 값을 계산한 뒤 R1에 저장한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>상세설명
<ul>
<li>만약 레지스터(R1)가 아닌 다른 메모리 공간에 결과를 저장한다면, 결과 저장 위치 계산 등의 과정이 추가적으로 필요해진다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="isz">마이크로 연산: 실행 사이클 - ISZ</h3>
<ul>
<li><code>ISZ X</code> 의 마이크로 연산 절차
<ul>
<li><code>ISZ X</code> 의 의미: X의 값을 1 증가시키고, 결과가 0이면 바로 다음 명령어를 스킵한다.</li>
<li>t1
<ul>
<li><strong>MAR ← (IR(address))</strong>
<ul>
<li>address: 1 증가시킬 값이 저장된 X의 주소</li>
</ul>
</li>
</ul>
</li>
<li>t2
<ul>
<li><strong>MBR ← memory</strong>
<ul>
<li>X에 저장된 값을 MBR에 전달한다.</li>
</ul>
</li>
</ul>
</li>
<li>t3
<ul>
<li><strong>MBR ← (MBR) + 1</strong></li>
</ul>
</li>
<li>t4
<ul>
<li><strong>memory ← (MBR)</strong></li>
<li><strong>if (MBR) == 0 then PC ← (PC) + I</strong>
<ul>
<li>(PC) : 다음에 수행할 명령어의 주소가 담겨있다.</li>
<li>I : 명령어 하나의 길이</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">명령어 사이클 정리</h3>
<ul>
<li>
<p>명령어 사이클의 각 단계는 마이크로 연산으로 구성된다.</p>
<ul>
<li>인출, 간접, 인터럽트, 실행 사이클</li>
</ul>
</li>
<li>
<p><strong>명령어 사이클 코드 (Instruction Cycle Code: ICC)</strong></p>
<ul>
<li>ICC를 이용하여 프로세서의 실행 위치를 확인한다.</li>
<li>즉 ICC를 통해, 제어 유닛이 어떤 제어를 해야하는지 판단한다.</li>
<li>ICC=00 : 인출</li>
<li>ICC=01 : 간접</li>
<li>ICC=10 : 실행</li>
<li>ICC=11 : 인터럽트</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%205.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-11">프로세서의 제어</h2>
<h3 id="section-12">제어 유닛의 특성을 결정하는 요소</h3>
<p>아래 요소들이 제어 유닛의 특성을 결정한다.</p>
<ul>
<li><strong>프로세서의 기본 구성요소</strong>
<ul>
<li>ALU, 레지스터, 내부/외부 데이터 통로, 제어 유닛</li>
</ul>
</li>
<li><strong>프로세서가 실행할 마이크로 연산</strong></li>
<li><strong>마이크로 연산이 실행되기 위해 제어 유닛이 수행해야 할 기능</strong></li>
</ul>
<br/>
<h3 id="section-13">제어 유닛의 기능</h3>
<ul>
<li><strong>순서 제어</strong>
<ul>
<li>실행될 프로그램에 근거하여, 프로세서가 일련의 마이크로 연산을 적절한 순서대로 처리하도록 해준다.</li>
</ul>
</li>
<li><strong>실행</strong>
<ul>
<li>각 마이크로 연산이 실행되도록 해준다.</li>
</ul>
</li>
</ul>
<p><strong>제어신호에 의해서 ‘순서제어’와 ‘실행’이 처리된다.</strong></p>
<br/>
<h3 id="section-14">제어 신호</h3>
<ul>
<li>제어 유닛이 기능을 수행하려면 아래 항목들이 필요하다.
<ul>
<li><strong>입력</strong>
<ul>
<li>시스템의 상태를 결정해주는 것</li>
</ul>
</li>
<li><strong>출력</strong>
<ul>
<li>시스템 동작을 제어하는 것</li>
</ul>
</li>
</ul>
</li>
<li>제어 신호의 종류
<ul>
<li>제어유닛 input 신호</li>
<li>제어유닛 output 신호</li>
</ul>
</li>
<li><strong>매 클록마다 제어 유닛은 모든 입력을 읽어들이고 제어신호를 발생시킨다.</strong></li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%206.png" alt="Untitled" /></p>
<p>하나씩 자세히 알아보자.</p>
<br/>
<h3 id="section-15">입력 제어 신호</h3>
<ul>
<li><strong>클록</strong>
<ul>
<li>제어 유닛이 시간을 지키도록 하는데 사용된다.</li>
<li>t1, t2, … 을 구분한다.</li>
<li>프로세서 사이클 시간 or 클록 사이클 시간</li>
</ul>
</li>
<li><strong>명령어 레지스터</strong>
<ul>
<li>Opcode에 따라, 어떤 마이크로 연산을 실행할지 결정한다.</li>
</ul>
</li>
<li><strong>플래그</strong>
<ul>
<li>프로세서의 상태와 이전 ALU 연산의 결과를 검사한 결과를 나타낸다.</li>
</ul>
</li>
<li><strong>제어 버스로부토 들어오는 제어 신호들</strong>
<ul>
<li>인터럽트 신호와 확인 신호 등</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-16">출력 제어 신호</h3>
<ul>
<li><strong>프로세서 내의 제어 신호</strong>
<ul>
<li>레지스터들 간의 데이터 전송을 발생시키는 신호이다.</li>
<li>특정 ALU 기능들을 활성화시키는 신호들이다.</li>
</ul>
</li>
<li><strong>제어 버스로 나가는 제어 신호</strong>
<ul>
<li>기억장치로 보내지는 제어 신호나</li>
<li>I/O 모듈로 보내지는 제어 신호가 있다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-17">마이크로 연산에 필요한 제어 신호들</h3>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%207.png" alt="Untitled" /></p>
<br/>
<h3 id="section-18">제어 신호 예시</h3>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%208.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-19">마이크로프로그램 방식의 제어 유닛</h2>
<h3 id="section-20">마이크로프로그램 방식이란?</h3>
<ul>
<li>제어 기억장치에 저장된 마이크로 프로그램을 실행하는 방식으로 제어 유닛을 동작시키는 것이다.</li>
<li>마이크로프로그램?
<ul>
<li>마이크로 명령어들의 집합</li>
</ul>
</li>
<li>마이크로 명령어?
<ul>
<li>명령어 사이클에서 ‘각 주기(t1, t2, …)에서 실행되는 각 마이크로-연산’을 지정해주는 2진 비트들</li>
<li>마이크로 명령어 == 제어 단어</li>
<li>마이크로명령어의 실행 결과로 제어 신호를 발생시킨다.</li>
</ul>
</li>
<li>마이크로프로그램 방식을 사용하면, 명령어 설계가 바뀌어도 제어 메모리에 저장된 프로그램만 변경하면 된다.</li>
</ul>
<br/>
<h3 id="section-21">제어 유닛의 구성</h3>
<ul>
<li>
<p><strong>명령어 해독기 (Decoder)</strong></p>
<ul>
<li>명령어 레지스터(IR)로부터 들어오는 명령어의 연산코드를 해독하여, 해당 연산을 수행하기 위한 루틴의 시작 주소를 계산한다.</li>
</ul>
</li>
<li>
<p><strong>제어 주소 레지스터 (Control Address Register, CAR)</strong></p>
<ul>
<li>다음에 실행할 마이크로명령어의 주소를 저장한다.</li>
</ul>
<blockquote>
<p>Program Counter와 유사하다.</p>
</blockquote>
</li>
<li>
<p><strong>제어 기억장치 (Control Memory)</strong></p>
<ul>
<li>마이크로 프로그램이 저장되는 공간이다.</li>
</ul>
</li>
<li>
<p><strong>제어 버퍼 레지스터 (Control Buffer Register, CBR)</strong></p>
<ul>
<li>제어 기억장치로부터 읽혀진 마이크로명령어를 일시 저장한다.</li>
</ul>
</li>
<li>
<p><strong>순서 제어 유닛 (Sequencing Logic)</strong></p>
<ul>
<li>마이크로명령어의 실행순서를 결정한다.</li>
<li>제어 주소 레지스터에 주소를 적재한다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%209.png" alt="Untitled" /></p>
<br/>
<h3 id="section-22">제어 기억장치</h3>
<ul>
<li>
<p>제어 단어 (or 마이크로 명령어)들이 저장되어 있다.</p>
</li>
<li>
<p>각 루틴 내의 마이크로명령어들은 순차적으로 진행된다.</p>
</li>
<li>
<p>예시</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2010.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-23">제어 유닛 동작 순서</h3>
<ol>
<li>명령어 레지스터에 들어온 명령어(Main Memory에 저장된 기계명령어)를 해독해, 연산코드(opcode)를 구한다.</li>
<li>연산코드에서 해당 명령에 필요한 <strong>제어 서브루틴</strong>의 시작주소를 계산한다.</li>
<li>명령어를 실행하기 위해, 순서제어 논리 유닛(Sequencing Logic)이 제어 기억장치로 READ 명령을 보낸다.</li>
<li>제어 주소 레지스터(CAR)에 명시된 제어 기억장치의 주소에 저장되어 있는 단어가 읽혀져서 제어 버퍼 레지스터(CBR)로 보내진다.</li>
<li>CBR의 내용에 따라, 제어 신호들과 다음 주소 정보가 발생된다.</li>
<li>순서제어 유닛은 CBR과 ALU 플래그에 근거하여 새로운 주소를 CAR에 적재한다.</li>
</ol>
<br/>
<h3 id="section-24">마이크로프로그램 제어 방식</h3>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2011.png" alt="Untitled" /></p>
<br/>
<h3 id="section-25">제어 서브루틴의 시작 주소 계산</h3>
<ul>
<li>명령어 해독기(Decoder)는 연산코드를 이용하여 <strong>제어 기억장치 내 해당 실행 사이클 루틴의 시작주소</strong> 를 찾는다.</li>
<li>시작 주소 해독 방법
<ul>
<li>
<p>명령어의 연산 코드를 특정 비트 패턴과 혼합시킴으로써, 그 연산의 수행에 필요한 실행 사이클 루틴의 시작 주소를 찾아낸다.</p>
</li>
<li>
<p>예시</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2012.png" alt="Untitled" /></p>
<ul>
<li>OPCODE 앞에 ‘1’을 추가하고, 뒤에 ‘00’을 추가한다. ⇒ 이것이 해당 명령어가 포함된 루틴의 시작 주소이다.</li>
<li>연산 코드 = 0001 ⇒ 시작주소 = 1000100</li>
<li>연산 코드 = 0100 ⇒ 시작주소 = 1010000</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-26">마이크로명령어의 형식 예시</h3>
<ul>
<li><strong>연산 필드가 두 개이면, 두 개의 마이크로-연산들을 동시에 수행할 수 있다.</strong></li>
<li><strong>조건 필드 (CD)</strong>
<ul>
<li>분기에 사용될 조건 플래그를 지정한다.</li>
</ul>
</li>
<li><strong>분기 필드 (BR)</strong>
<ul>
<li>분기의 종류와 다음에 실행할 마이크로명령어의 주소를 결정하는 방법을 명시한다.</li>
</ul>
</li>
<li><strong>주소 필드 (ADF)</strong>
<ul>
<li>분기가 발생하는 경우: 목적지 마이크로명령어의 주소</li>
<li>분기가 발생하지 않는 경우: 다음에 실행할 마이크로명령어의 주소</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2013.png" alt="Untitled" /></p>
<blockquote>
<p>위 경우, 연산필드가 2개이다.</p>
</blockquote>
<ul>
<li>
<p>마이크로명령어 코드 예시</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2014.png" alt="Untitled" /></p>
</li>
<li>
<p>조건 필드 예시</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2015.png" alt="Untitled" /></p>
</li>
<li>
<p>분기 필드 예시</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2016.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-27">마이크로프로그래밍 예시</h3>
<ul>
<li>
<p><strong>인출 사이클 루틴</strong></p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2017.png" alt="Untitled" /></p>
<ul>
<li>변환된 마이크로명령어 형태</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2018.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>간접 사이클 루틴</strong></p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2019.png" alt="Untitled" /></p>
<ul>
<li>
<p>변환된 마이크로명령어 형태</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2020.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-28">실행 사이클 루틴</h3>
<ul>
<li>
<p>사상 방식을 이용하여, 각 연산 코드에 대한 실행 사이클 루틴의 시작 주소를 결정하고, 각 명령어 실행을 위한 루틴을 작성한다.</p>
</li>
<li>
<p>각 연산 코드에 대한 사상 결과</p>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2021.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-29">마이크로 명령어 구조</h2>
<h3 id="section-30">수직적 마이크로명령어</h3>
<ul>
<li>코드화된 비트들을 이용해, 마이크로명령어의 각 기능 코드를 구성하는 구조이다.</li>
<li>해독기(Decoder)를 이용해, 그 코드를 필요한 수만큼의 제어 신호로 확장한다.
<ul>
<li>n개 비트의 연산 코드 ⇒ 총 <img src="https://latex.codecogs.com/svg.image?2%5En" alt="math" /> 개의 제어 신호를 생성할 수 있다.</li>
</ul>
</li>
<li><strong>수행될 각 동작에 대해, 하나의 코드를 사용한다.</strong></li>
<li>특징
<ul>
<li>제어 기억장치의 용량 절감
<ul>
<li>코드화되어있으므로</li>
</ul>
</li>
<li>약간의 논리회로와 시간 지연 추가</li>
<li>수평적 마이크로명령어보다 간결</li>
<li>병렬 처리에 제약</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-12-02-ComputerStructure_ControlUnit/Untitled%2022.png" alt="Untitled" /></p>
<br/>
<h3 id="section-31">수평적 마이크로명령어</h3>
<ul>
<li>마이크로명령어의 각 필드의 비트가 제어 신호에 대응된다.</li>
<li>마이크로명령어는 병렬로 수행될 수 있는 다수의 마이크로-연산을 지정한다.</li>
<li>‘프로세서 내부의 각 제어선’과 ‘시스템 버스의 각 제어선’에 대해 한 비트씩 할당한다.
<ul>
<li>비트값이 1인 모든 제어선을 on 시키고, 0인 제어선을 off시킨다.</li>
<li>조건 비트에 따라, 마이크로명령어의 순서를 제어한다.</li>
</ul>
</li>
<li>특징
<ul>
<li>하드웨어가 간단하고, 해독에 따른 지연이 없다.</li>
<li>마이크로명령어 비트수가 길기 때문에, 큰 용량의 제어 기억장치가 필요하다.</li>
<li>병렬 처리가 가능하다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 최정열 교수님 (2021)</li>
    <li>William Stalling, 『컴퓨터시스템구조론(10판)』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET