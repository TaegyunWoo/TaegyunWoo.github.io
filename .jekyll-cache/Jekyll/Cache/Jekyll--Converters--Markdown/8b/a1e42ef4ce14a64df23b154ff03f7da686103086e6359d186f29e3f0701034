I"6/<p><br/><br/></p>
<h1 id="section">덱</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">덱이란?</h3>
<ul>
<li><strong>전단(front)과 후단(rear)</strong> 에서 모두 삽입, 삭제가 가능한 큐</li>
</ul>
<p><img src="/assets/img/2021-07-03-DATASTRUCTURE_Deque/Untitled_33.png" alt="덱 개요" /></p>
<br/>
<h3 id="section-3">덱 연산 예시</h3>
<p><img src="/assets/img/2021-07-03-DATASTRUCTURE_Deque/Untitled_34.png" alt="덱 연산 예시" /></p>
<br/>
<h3 id="section-4">특징</h3>
<ul>
<li>덱(deque) 구현
<ul>
<li>배열</li>
</ul>
</li>
<li>큐와 유사함</li>
<li>입력 방향이 쌍방이다</li>
</ul>
<p><br/><br/></p>
<h2 id="adt">덱 ADT</h2>
<h3 id="section-5">데이터</h3>
<ul>
<li>전단과 후단을 통한 접근을 허용하는 요소들의 모음</li>
</ul>
<h3 id="section-6">연산</h3>
<ul>
<li><strong>init()</strong> : 덱 초기화</li>
<li><strong>add_front(e)</strong> : 요소 e를 덱 맨 앞에 추가</li>
<li><strong>delete_front()</strong> : 전단 요소 삭제 후 반환</li>
<li><strong>add_rear(e)</strong> : 요소 e를 덱 맨 뒤에 추가</li>
<li><strong>delete_rear()</strong> : 후단 요소 삭제 후 반환</li>
<li><strong>get_front()</strong> : 전단 요소를 삭제하지 않고 반환</li>
<li><strong>get_rear()</strong> : 후단 요소를 삭제하지 않고 반환</li>
<li><strong>is_empty()</strong> : 공백 상태 → true</li>
<li><strong>is_full()</strong> : 포화 상태 → true</li>
<li><strong>size()</strong> : 덱 내의 모든 요소들의 개수</li>
</ul>
<p><br/><br/></p>
<h2 id="section-7">원형 덱</h2>
<h3 id="section-8">큐와 동일한 연산</h3>
<ul>
<li>init()</li>
<li>delete_front()</li>
<li>add_rear(e)</li>
<li>get_front()</li>
<li>is_empty()</li>
<li>is_full()</li>
<li>size()</li>
</ul>
<br/>
<h3 id="section-9">덱에서 추가된 연산(큐에 없는 연산)</h3>
<ul>
<li><strong>delete_rear()</strong></li>
<li><strong>add_front()</strong></li>
<li><strong>get_rear()</strong></li>
</ul>
<blockquote>
<ul>
<li>add_rear() == 큐의 enqueue()</li>
<li>delete_front() == 큐의 dequeue()</li>
</ul>
</blockquote>
<br/>
<h3 id="deleterear-addfront-">delete_rear(), add_front() 공식</h3>
<ul>
<li>delete_rear() 실행시 rear값
<ul>
<li><strong>rear = (rear - 1 + MAX_DEQUE_SIZE) % MAX_DEQUE_SIZE</strong></li>
</ul>
</li>
<li>add_front() 실행시 front값
<ul>
<li><strong>front = (front - 1 + MAX_DEQUE_SIZE) % MAX_DEQUE_SIZE</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>&lt;MAX_DEQUE_SIZE을 더하는 이유&gt;<br />
rear값, front값이 0일때, 음수가 나오지 않게 하기 위해</p>
</blockquote>
<br/>
<h3 id="section-10">구현 코드</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#define Element int
#define MAX_DEQUE_SIZE 100
</span>
<span class="n">Element</span> <span class="n">deque</span><span class="p">[</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init_deque</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">front</span><span class="o">=</span><span class="n">rear</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size_deque</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rear</span><span class="o">-</span><span class="n">front</span><span class="o">+</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">front</span><span class="o">==</span><span class="n">rear</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_full</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">front</span><span class="o">==</span><span class="p">(</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_rear</span><span class="p">(</span><span class="n">Element</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_full</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Overflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
	<span class="n">deque</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">delete_rear</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Underflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">rear</span><span class="p">;</span>
	<span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">deque</span><span class="p">[</span><span class="n">temp</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_front</span><span class="p">(</span><span class="n">Element</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_full</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Overflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">deque</span><span class="p">[</span><span class="n">front</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">delete_front</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Underflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">deque</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">get_rear</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Underflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">deque</span><span class="p">[</span><span class="n">rear</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">get_front</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Deque Underflow"</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">deque</span><span class="p">[(</span><span class="n">front</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_DEQUE_SIZE</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">init_deque</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_front</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">add_rear</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">delete_front</span><span class="p">());</span>
	<span class="p">}</span>
		
<span class="p">}</span>
</code></pre></div></div>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 박미옥 교수님 (2021)</li>
    <li>최영규, 『두근두근 자료구조』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET