I"+<p><br/><br/></p>
<h1 id="section">분할 정복 : 최근접 점의 쌍 찾기</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">최근접 점의 쌍 문제란?</h3>
<ul>
<li>2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제</li>
</ul>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_37.png" alt="최근접 점의 쌍 문제" /></p>
<br>
<h3 id="section-3">기본 해결 방식</h3>
<ul>
<li>
<p>모든 점에 대하여 각각의 두 점 사이의 거리를 계산하여 가장 가까운 점의 쌍 찾는다.<br />
⇒ <img src="https://latex.codecogs.com/svg.image?O(n%5E2)" alt="O(n^2)" /></p>
</li>
<li>
<p>n개의 점을 각각 (n-1)번씩 비교한다.</p>
</li>
</ul>
<h3 id="section-4">보다 나은 해결 방식</h3>
<ol>
<li>n개의 점을 1/2로 분할한다.</li>
<li>각 부분해 중 최근접 점 쌍을 찾는다.</li>
<li>분할한 영역 사이의 중간영역에서 최근접 점 쌍을 찾는다.</li>
<li>찾은 3개의 쌍 중 가장 작은 쌍 반환한다.</li>
</ol>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_38.png" alt="해결방식" /></p>
<br>
<h3 id="section-5">고려사항</h3>
<ul>
<li>반드시 중간 영역의 최근접 점까지 찾아야함</li>
</ul>
<p><br><br></p>
<h2 id="section-6">중간 영역</h2>
<h3 id="section-7">범위 설정</h3>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_39.png" alt="범위 설정" /></p>
<ul>
<li>중간 영역의 범위 = d</li>
<li>d = min{“왼쪽 부분의 최근접 점의 쌍 거리”, “오른쪽 부분의 최근접 점의 쌍 거리”}</li>
</ul>
<br>
<h3 id="section-8">속한 점 찾는 방법</h3>
<ol>
<li>
<p>x좌표 기준 정렬 후, 분할기준을 찾는다.
<img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_40.png" alt="속한 점 찾기" /></p>
</li>
<li>
<p>중간 영역에 속한 점</p>
<ul>
<li>‘왼쪽 부분 문제의 가장 오른쪽 점의 x좌표’ - d</li>
<li>‘오른쪽 부분 문제의 가장 왼쪽 점의 x좌표’ + d</li>
<li>중간 영역에 속한 점 = <strong>위 두 x값 사이</strong>의 “x값을 가진 점들”</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>예시</p>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_41.png" alt="속한점 예시" /></p>
<ul>
<li>d=10 일 때</li>
</ul>
<blockquote>
<p>즉, 16 ~ 38 사이의 값을 x좌표로 가지는 점 == 중간 영역의 점</p>
</blockquote>
</li>
</ul>
<br>
<h3 id="section-9">속한 점 비교 방법</h3>
<ul>
<li>한 쪽의 각 점마다 반대편의 각 점을 비교한다.</li>
</ul>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_42.png" alt="속한 점 비교 방법" /></p>
<ul>
<li><strong>하지만 중간영역의 범위(주황색 영역)를 넘지 않는 범위 안에서만 비교한다.</strong></li>
</ul>
<blockquote>
<p>아래에서 자세히 설명한다.</p>
</blockquote>
<p><br><br></p>
<h2 id="section-10">알고리즘</h2>
<h3 id="section-11">의사코드</h3>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_43.png" alt="의사코드" /></p>
<br>
<h3 id="section-12">절차 : 1번 라인</h3>
<ul>
<li>
<p>점의 개수가 3 이하라면 아래 항목 수행</p>
<ul>
<li>“점의 개수 == 3”인 경우
<ul>
<li>3개의 점들 사이의 최근접 쌍 반환</li>
</ul>
</li>
<li>“점의 개수 == 2”인 경우
<ul>
<li>2개의 점 쌍 반환</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h3 id="section-13">절차 : 2번 라인</h3>
<ul>
<li>문제를 부분 문제로 분할하는 라인</li>
</ul>
<br>
<h3 id="section-14">절차 : 3, 4번 라인</h3>
<ul>
<li>재귀호출을 통해 왼쪽, 오른쪽의 최근접 점의 쌍을 구한다.</li>
</ul>
<br>
<h3 id="section-15">절차 : 5번 라인</h3>
<ol>
<li>반환된 “왼쪽, 오른쪽 최근접 점의 거리” 중 작은 값을 d로 설정한다.</li>
<li>중간 영역에 속하는 점들 중 최근접 점의 쌍을 구한다.</li>
</ol>
<br>
<h3 id="section-16">절차 : 6번 라인</h3>
<ul>
<li>정답 반환</li>
</ul>
<p><br><br></p>
<h2 id="section-17">시간 복잡도</h2>
<h3 id="section-18">배경 전재</h3>
<ul>
<li>입력 s에 총 n개의 점이 존재한다고 가정한다.</li>
</ul>
<br>
<h3 id="section-19">전처리 과정 : 정렬</h3>
<ul>
<li>s의 점들을 x좌표의 오름차순으로 정렬</li>
<li>참고로, 퀵 정렬의 시간복잡도는 <img src="https://latex.codecogs.com/svg.image?O(nlogn)" alt="O(nlogn)" />이다.<br />
∴ <img src="https://latex.codecogs.com/svg.image?O(nlogn)" alt="O(nlogn)" /></li>
</ul>
<br>
<h3 id="line--1">line : 1</h3>
<ul>
<li>
<p>3개 이하의 점들의 최근접 점 구하기</p>
<ul>
<li>점의 개수가 2개인 경우
<ul>
<li>거리 계산 총 1번 ⇒ <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></li>
</ul>
</li>
<li>점의 개수가 3 개인 경우
<ul>
<li>거리 계산 총 3번 ⇒ <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></li>
</ul>
</li>
</ul>
<blockquote>
<p>계산을 1번하나, 3번하나 차이가 없다.</p>
</blockquote>
<p>∴ line1의 시간복잡도 = <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></p>
</li>
</ul>
<br>
<h3 id="line--2">line : 2</h3>
<ul>
<li>동일한 크기로 분할하기
<ul>
<li>정렬된 s를 분할할 때
<ul>
<li>이미 정렬이 되어있으므로, s의 중간 인덱스로 분할하면 됨<br />
⇒ <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>∴ line2의 시간복잡도 = <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></p>
<br>
<h3 id="line--3-4">line : 3, 4</h3>
<ul>
<li>
<p>재귀적 호출을 수행한다.</p>
</li>
<li>
<p>호출과정</p>
<ul>
<li>합병정렬과 동일한 과정</li>
</ul>
<p>∴ 고려X (호출자체는 시간소요X)</p>
</li>
<li>
<p>단, 가장 마지막 부분해의 계산이 끝난 후,<br />
합병할때의 시간복잡도 =
층수*입력개수 = <img src="https://latex.codecogs.com/svg.image?O(log_2n)*n=O(nlog_2n)=O(nlogn)" alt="O(log_2n)*n=O(nlog_2n)=O(nlogn)" /></p>
</li>
</ul>
<br>
<h3 id="line--5">line : 5</h3>
<ul>
<li>중간영역의 범위를 구한다.</li>
<li>중간영역의 최근접 점을 찾는다.</li>
</ul>
<br>
<ul>
<li>중간영역의 최근접 점 찾는 과정
<ol>
<li>
<p>중간영역에 있는 점들을 y좌표의 오름차순으로 정렬한다.</p>
</li>
<li>
<p>“아래에서 위” or “위에서 아래”로 각 점들을 기준으로 거리를 비교한다.</p>
<blockquote>
<p>이때, 각 점을 기준으로 거리가 d 이내인 주변의 점들 사이의 거리만 계산</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<br>
<ul>
<li>
<p>시간복잡도</p>
<ul>
<li>y좌표 오름차순 정렬<br />
⇒ <img src="https://latex.codecogs.com/svg.image?O(nlogn)" alt="O(nlogn)" /></li>
<li>각 점들의 거리 비교
<ul>
<li>
<p>주변 점들의 거리 계산시, d보다 먼 거리의 점들은 고려할 필요가 없다.</p>
</li>
<li>
<p>d보다 먼 거리에 있는 점들은 어차피 “왼쪽, 오른쪽 부분해를 구할 때” 계산되어 제외되기 때문이다.
(즉, 결과에 영향을 미치지 않음)</p>
</li>
<li>
<p>따라서, 비교할 점들의 개수는 d로 인해 제한된다.<br />
⇒ <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></p>
</li>
<li>
<p>그러므로 각 점들간의 거리를 비교할 때의 시간복잡도는 <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /> 이다.</p>
</li>
</ul>
</li>
</ul>
<p>∴ line5의 시간복잡도 = <img src="https://latex.codecogs.com/svg.image?O(nlogn)+O(1)" alt="O(nlogn)+O(1)" /></p>
</li>
</ul>
<br>
<h3 id="line--6">line : 6</h3>
<ul>
<li>
<p><img src="https://latex.codecogs.com/svg.image?min(CP_L,CP_R,CP_C)" alt="min(CP_L,CP_R,CP_C)" /> 을 수행한다.</p>
</li>
<li>
<p>3개 중 가장 작은 값을 구하는 시간복잡도<br />
⇒ <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></p>
</li>
</ul>
<p>∴ line6의 시간복잡도 = <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" /></p>
<br>
<h3 id="section-20">합병</h3>
<ul>
<li>
<p>층수 구하기</p>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_44.png" alt="층수 구하기" /></p>
</li>
</ul>
<br>
<ul>
<li>
<p>각 층 계산 시간복잡도</p>
<p><img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_45.png" alt="각 층 계산 시간복잡도" /></p>
</li>
</ul>
<br>
<p>line1복잡도 + line2복잡도 + line3복잡도 + line4복잡도 + line5복잡도 + line6복잡도 =<br />
<img src="https://latex.codecogs.com/svg.image?O(1)+O(1)+none+none+%5BO(nlogn)+O(1)%5D+O(1)=O(nlogn)" alt="O(1)+O(1)+none+none+[O(nlogn)+O(1)]+O(1)=O(nlogn)" /></p>
<p>따라서,<br />
<strong>(각층_시간복잡도) * (층수) = (최근접 점 알고리즘 시간복잡도)</strong></p>
<br>
<h3 id="section-21">시간복잡도 결론</h3>
<p>(각층_시간복잡도) * (층수) = (최근접 점 알고리즘 시간복잡도) =<br />
<img src="https://latex.codecogs.com/svg.image?O(nlogn)*3log_2n=O(nlogn)*O(logn)=O(nlog%5E2n)" alt="O(nlogn)*3log_2n=O(nlogn)*O(logn)=O(nlog^2n)" /></p>
<br>
<h3 id="section-22">중간영역 점들의 거리 계산 시간복잡도 증명</h3>
<ul>
<li>
<p>중간영역을 ‘변의 크기가 d/2인 정사각형’으로 쪼갠다.</p>
</li>
<li>
<p>각 정사각형에는 점이 하나씩만 들어있다.</p>
<ul>
<li>
<p>&lt;증명&gt;</p>
<ul>
<li>가정: 정사각형마다 점이 2개있다.</li>
</ul>
<ol>
<li>
<p>정사각형 내부의 점들의 최대 거리: <img src="https://latex.codecogs.com/svg.image?%5Csqrt%7B(d/2)%5E2+(d/2)%5E2%7D=d/%5Csqrt%7B2%7D" alt="\sqrt{(d/2)^2+(d/2)^2}=d/\sqrt{2}" /></p>
</li>
<li>
<p>이때, <img src="https://latex.codecogs.com/svg.image?d/%5Csqrt%7B2%7D%3Cd" alt="d/\sqrt{2}&lt;d" /> 이다.</p>
</li>
<li>
<p>그렇다면 <img src="https://latex.codecogs.com/svg.image?CP_L" alt="CP_L" /> 과 <img src="https://latex.codecogs.com/svg.image?CP_R" alt="CP_R" /> 을 계산할 때, 최솟값으로 도출이 되었어야 한다.</p>
</li>
<li>
<p>하지만, <img src="https://latex.codecogs.com/svg.image?min(CP_L,CP_R)=d" alt="min(CP_L,CP_R)=d" /> 이므로, 모순이다.</p>
</li>
<li>
<p>따라서, 각 정사각형에는 점이 하나씩만 들어있다.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>각 정사각형에는 점이 하나씩만 들어있으므로, 하나의 점에서 3개의 행 이상 차이나는 점들에 대해서는 무시해도 된다.<br />
<img src="/assets/img/2021-07-20-ALGORITHM_ClosestPair/Untitled_46.png" alt="시간복잡도 증명" /></p>
</li>
<li>
<p>따라서, 중간영역의 시간복잡도는 <img src="https://latex.codecogs.com/svg.image?O(1)" alt="O(1)" />이다.</p>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 임태수 교수님 (2021)</li>
    <li>양성봉, 『알기 쉬운 알고리즘』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET