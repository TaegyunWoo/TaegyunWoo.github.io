I"d&<p><br/><br/></p>
<h1 id="section">연관관계 매핑 기초</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">객체와 테이블의 연관관계 방식</h3>
<ul>
<li>객체의 연관관계 방식
<ul>
<li>참조(주소)를 사용해서 관계를 맺는다.</li>
</ul>
</li>
<li>테이블의 연관관계 방식
<ul>
<li>외래키를 사용해서 관계를 맺는다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">목표</h3>
<ul>
<li><strong>객체의 참조와 테이블의 외래 키를 매핑하는 것</strong></li>
</ul>
<br/>
<h3 id="section-4">핵심 키워드</h3>
<ul>
<li><strong>방향</strong>
<ul>
<li>단방향, 양방향</li>
<li>단방향 예시
<ul>
<li>회원과 팀이 존재하고, 서로 관계가 있을 때</li>
<li>“회원 → 팀” 또는</li>
<li>“팀 → 회원” 둘 중 한 쪽만 참조하는 것</li>
</ul>
</li>
<li>양방향 예시
<ul>
<li>“회원 → 팀”과 “팀 → 회원” 둘 다 참조하는 것</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>다중성</strong>
<ul>
<li>다대일, 일대다, 일대일, 다대다</li>
<li>다대일 관계 예시
<ul>
<li>여러 회원이 한 팀에 속한다.</li>
<li>그러므로, 회원과 팀은 “다대일” 관계이다.</li>
</ul>
</li>
<li>일대다 관계 예시
<ul>
<li>한 팀에 여러 회원이 속한다.</li>
<li>그러므로, 팀과 회원은 “일대다” 관계이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>연관관계의 주인</strong>
<ul>
<li>객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-5">단방향 연관관계</h2>
<h3 id="section-6">단방향 연관관계란?</h3>
<p>단방향 연관관계를 이해하기 위해, 먼저 예시 배경을 명시하고 진행하겠다. 아래는 예시 배경에 대한 서술 내용이다.</p>
<ul>
<li>예시 배경
<ul>
<li>회원과 팀이 있다.</li>
<li>회원은 하나의 팀에만 소속될 수 있다.</li>
<li>회원과 팀은 다대일 관계이다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>다대일 연관관계, 단방향</p>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled.png" alt="Untitled" /></p>
<ul>
<li>객체 연관관계
<ul>
<li>회원 객체는 Member.team 필드로 팀 객체와 연관관계를 맺는다.</li>
<li>회원 객체와 팀 객체는 <strong>단방향 관계</strong>이다.
<ul>
<li>회원은 Member.team 필드를 통해서 팀을 알 수 있지만, 팀은 회원을 알 수 없다.</li>
</ul>
</li>
</ul>
</li>
<li>테이블 연관관계
<ul>
<li>회원 테이블은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다.</li>
<li>회원 테이블과 팀 테이블은 <strong>양방향 관계</strong>이다.</li>
<li>회원 테이블의 TEAM_ID 외래키를 통해서 회원과 팀을 조인할 수 있고, 팀과 회원도 조인할 수 있다.
<ul>
<li><code>MEMBER JOIN TEAM</code> , <code>TEAM JOIN MEMBER</code> 모두 가능하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>객체 연관관계와 테이블 연관관계의 차이점
<ul>
<li>참조를 통한 연관관계는 언제나 단방향이다.
<ul>
<li>만약 객체간에 연관관계를 양방향으로 만들고 싶다면, 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.</li>
<li><strong>하지만 정확히 말하자면, 이것은 양방향 관계가 아니라 서로 다른 단방향 관계가 2개 있는 것이다.</strong></li>
</ul>
</li>
<li>반면에 테이블은 외래키 하나로 양방향으로 조인할 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>정리
<ul>
<li>객체는 참조(주소)로 연관관계를 맺는다.</li>
<li>테이블은 외래키로 연관관계를 맺는다.</li>
<li>객체는 <strong>참조(<code>a.getB().getC()</code>)</strong> 를 통해 연관된 데이터를 조회한다.</li>
<li>테이블은 <strong>조인(<code>JOIN</code>)</strong> 을 통해 연관된 데이터를 조회한다.</li>
<li>참조를 사용하는 객체의 연관관계는 <strong>단방향</strong>이다.</li>
<li>외래키를 사용하는 테이블의 연관관계는 <strong>양방향</strong>이다.</li>
<li>객체를 양방향으로 참조하려면, 단방향 연관관계를 2개 만들어야 한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-7">순수한 객체 연관관계</h3>
<p>순수하게 객체만 사용한 연관관계를 살펴보자.</p>
<ul>
<li>
<p>회원 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span> <span class="c1">// 팀의 참조를 보관한다.</span>

	<span class="kd">public</span> <span class="nf">Member</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Member</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>팀 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Team</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Team</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>동작코드</p>
<ul>
<li>아래 코드를 통해서, 회원1과 회원2를 팀1에 소속시키자.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>

	<span class="c1">//팀에 소속시키기</span>
	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>
	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

	<span class="c1">//객체 그래프 탐색</span>
	<span class="nc">Team</span> <span class="n">findTeam</span> <span class="o">=</span> <span class="n">member1</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p>다대일 인스턴스 관계</p>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%201.png" alt="Untitled" /></p>
</li>
<li>
<p>객체 그래프 탐색</p>
<ul>
<li><code>Team findTeam = member1.getTeam();</code></li>
<li>위 코드처럼, 객체는 참조를 사용해서 연관관계를 탐색할 수 있다.</li>
<li>이것을 <strong>객체 그래프 탐색</strong> 이라고 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-8">테이블 연관관계</h3>
<p>이번에는 DB 테이블의 회원과 팀의 관계를 살펴보자. 아래는 회원 테이블과 팀 테이블의 DDL이다.</p>
<ul>
<li>
<p>테이블 DDL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span><span class="n">MEMBER</span> <span class="err">테이블</span> <span class="err">추가</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">MEMBER</span> <span class="p">(</span>
	<span class="n">MEMBER_ID</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">TEAM_ID</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
	<span class="n">USERNAME</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">)</span>
<span class="p">)</span>

<span class="o">//</span><span class="n">TEAM</span> <span class="err">테이블</span> <span class="err">추가</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">TEAM</span> <span class="p">(</span>
	<span class="n">TEAM_ID</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">NAME</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">TEAM_ID</span><span class="p">)</span>
<span class="p">)</span>

<span class="o">//</span><span class="n">MEMBER</span> <span class="err">테이블에</span> <span class="err">외래키</span> <span class="err">추가</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">MEMBER</span> <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">FK_MEMBER_TEAM</span>
	<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">TEAM_ID</span><span class="p">)</span>
	<span class="k">REFERENCES</span> <span class="n">TEAM</span>
</code></pre></div></div>
</li>
<li>
<p>동작 SQL</p>
<ul>
<li>아래 SQL을 통해서, 회원1과 회원2를 팀1에 소속시키자.</li>
</ul>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">TEAM</span><span class="p">(</span><span class="n">TEAM_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'team1'</span><span class="p">,</span> <span class="s1">'팀1'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER</span><span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">,</span> <span class="n">TEAM_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'member1'</span><span class="p">,</span> <span class="s1">'team1'</span><span class="p">,</span> <span class="s1">'회원1'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER</span><span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">,</span> <span class="n">TEAM_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'member2'</span><span class="p">,</span> <span class="s1">'team1'</span><span class="p">,</span> <span class="s1">'회원2'</span><span class="p">);</span>

<span class="o">//</span><span class="err">회원</span><span class="mi">1</span><span class="err">의</span> <span class="err">소속팀</span> <span class="err">조회</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">M</span>
	<span class="k">JOIN</span> <span class="n">TEAM</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">TEAM_ID</span>
	<span class="k">WHERE</span> <span class="n">M</span><span class="p">.</span><span class="n">MEMBER_ID</span> <span class="o">=</span> <span class="s1">'member1'</span><span class="p">;</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>조인
<ul>
<li>DB는 위 코드처럼 외래 키를 사용해서 연관관계를 탐색한다.</li>
<li>이것을 <strong>조인</strong>이라고 한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-9">객체 관계 매핑</h3>
<p>이제 JPA를 사용해서 “객체만 사용한 연관관계”와 “테이블만 사용한 연관관계”를 매핑해보자.</p>
<ul>
<li>
<p>매핑한 회원 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

	<span class="c1">//연관관계 매핑</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Member</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Member</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//연관관계 설정</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>매핑한 팀 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Team</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Team</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>연관관계</p>
<ul>
<li><strong>객체 연관관계</strong>
<ul>
<li>회원 객체의 <strong>Member.team 필드</strong>를 사용하여 연관관계를 맺음.</li>
</ul>
</li>
<li><strong>테이블 연관관계</strong>
<ul>
<li>회원 테이블의 <strong>MEMBER.TEAM_ID 외래키 컬럼</strong>을 사용하여 연관관계를 맺음.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>매핑 코드 분석</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ManyToOne</span>
<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
</code></pre></div></div>
<ul>
<li><code>@ManyToOne</code>
<ul>
<li>다대일 관계라는 매핑 정보이다.</li>
<li>Member와 Team의 관계는 다대일이다.</li>
</ul>
</li>
<li><code>@JoinColumn(name = &quot;TEAM_ID&quot;)</code>
<ul>
<li>외래 키를 매핑할 때 사용한다.</li>
<li><code>name</code> 속성에는 매핑할 <strong>외래 키 이름을 지정</strong>한다.</li>
<li>회원과 팀 테이블은 TEAM_ID 외래키로 연관관계를 맺으므로, <code>&quot;TEAM_ID&quot;</code> 로 지정되었다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-10">애너테이션 설명</h2>
<h3 id="codejoincolumncode"><code>@JoinColumn</code></h3>
<ul>
<li>목적
<ul>
<li><code>@JoinColumn</code> 애너테이션은 외래키를 매핑할 때 사용된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>주요 속성</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>기능</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>매핑할 외래키 이름</td>
<td>‘필드명’ + ‘_’ + ‘참조하는 테이블의 기본키 컬럼명’</td>
</tr>
<tr>
<td>referencedColumnName</td>
<td>외래키가 참조하는 대상 테이블의 컬럼명</td>
<td>참조하는 테이블의 기본키 컬럼명</td>
</tr>
<tr>
<td>foreignKey(DDL)</td>
<td>- 외래키 제약조건을 직접 지정할 수 있다.<br/>- 이 속성은 테이블을 생성할 때만 사용한다.</td>
<td></td>
</tr>
<tr>
<td>unique</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
<tr>
<td>nullable</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
<tr>
<td>insertable</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
<tr>
<td>updatable</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
<tr>
<td>columnDefinition</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
<tr>
<td>table</td>
<td><code>@Column</code> 의 속성과 같다.</td>
<td></td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li><code>@JoinColumn</code> 생략시
<ul>
<li>
<p>생략 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ManyToOne</span>
<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
</code></pre></div></div>
</li>
<li>
<p>해당 애너테이션 생략시, 외래 키를 찾을 때 기본 전략을 사용한다.</p>
<ul>
<li>‘필드명’ + ‘_’ + ‘참조하는 테이블의 기본키 컬럼명’</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="codemanytoonecode"><code>@ManyToOne</code></h3>
<ul>
<li>목적
<ul>
<li><code>@ManyToOne</code> 애너테이션은 다대일 관계에서 사용한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>주요 속성</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>기능</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td>optional</td>
<td>false로 설정하면, 연관된 엔티티가 항상 있어야 한다.</td>
<td>true</td>
</tr>
<tr>
<td>fetch</td>
<td>자세한 내용은 추후에 다룬다.</td>
<td>- @ManyToOne=FetchType.EAGER<br/>- @OneToMany=FetchType.LAZY</td>
</tr>
<tr>
<td>cascade</td>
<td>자세한 내용은 추후에 다룬다.</td>
<td></td>
</tr>
<tr>
<td>targetEntity</td>
<td>- 연관된 엔티티의 타입 정보를 설정한다.<br/>- 이 기능은 거의 사용하지 않는다.<br/>- 왜냐하면, 제네릭을 통해 타입을 알 수 있기 때문이다.</td>
<td></td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li>
<p><code>targetEntity</code> 속성 사용 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//--- targetEntity가 필요없는 코드 ---</span>
<span class="nd">@OneToMany</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">;</span> <span class="c1">//제네릭 타입 O</span>

<span class="c1">//--- targetEntity가 필요한 코드 ---</span>
<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">targetEntity</span> <span class="o">=</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span> <span class="n">members</span><span class="o">;</span> <span class="c1">//제네릭 타입 X</span>
</code></pre></div></div>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-11">연관관계 사용</h2>
<p>연관관계를 등록, 수정, 삭제, 조회하는 예제를 통해 연관관계를 어떻게 사용하는지, 예시코드를 통해 알아보자.</p>
<br/>
<h3 id="section-12">저장</h3>
<ul>
<li>아래 코드는 회원과 팀을 저장하는 코드이다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSave</span><span class="o">()</span> <span class="o">{</span>
	<span class="c1">//팀1 저장</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

	<span class="c1">//회원1 저장</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">// 연관관계 설정 (member1 -&gt; team1)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

	<span class="c1">//회원2 저장</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">// 연관관계 설정 (member1 -&gt; team1)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p><strong>JPA에서 엔티티를 저장할 때, 연관된 모든 엔티티는 영속 상태여야 한다.</strong></p>
<ul>
<li>따라서 위 예시에서 <code>member1</code>과 <code>member2</code>가 <code>team1</code>을 가르킬 때, <code>team1</code>이 영속성 컨텍스트에 포함된 상태이다.</li>
</ul>
</li>
<li>
<p>주요 소스 코드 분석</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">// 연관관계 설정 (member1 -&gt; team1)</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
</code></pre></div></div>
<ul>
<li>
<p>회원 엔티티는 팀 엔티티를 찾조하고 저장했다.</p>
</li>
<li>
<p>JPA는 <strong>참조한 팀의 기본 식별자(Team.id)를 외래키로 사용해서 적절한 등록 쿼리를 생성</strong>한다.</p>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">TEAM</span> <span class="p">(</span><span class="n">TEAM_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'team1'</span><span class="p">,</span> <span class="s1">'팀1'</span><span class="p">)</span> <span class="o">//</span><span class="err">팀</span><span class="mi">1</span> <span class="err">저장</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER</span> <span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">TEAM_ID</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'member1'</span><span class="p">,</span> <span class="s1">'회원1'</span><span class="p">,</span> <span class="s1">'team1'</span><span class="p">)</span> <span class="o">//</span><span class="err">회원</span><span class="mi">1</span> <span class="err">저장</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER</span> <span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">TEAM_ID</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'member2'</span><span class="p">,</span> <span class="s1">'회원2'</span><span class="p">,</span> <span class="s1">'team1'</span><span class="p">)</span> <span class="o">//</span><span class="err">회원</span><span class="mi">2</span> <span class="err">저장</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">조회</h3>
<p>이제 연관관계가 있는 엔티티를 조회하는 방법에 대해 알아보자. 연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지가 존재한다. 그것은 아래와 같다.</p>
<ul>
<li>연관관계가 있는 엔티티를 조회하는 방법
<ul>
<li>객체 그래프 탐색 (객체 연관관계를 사용한 조회)</li>
<li>객체지향 쿼리 사용 (JPQL)</li>
</ul>
</li>
</ul>
<p>지금부터 하나씩 설명하도록 하겠다.</p>
<br/>
<ul>
<li>객체 그래프 탐색
<ul>
<li>
<p>먼저 위에서 저장한대로, 회원1과 회원2가 팀1에 소속해 있다고 가정하자.</p>
</li>
<li>
<p><code>member.getTeam()</code> 을 사용해서 <code>member</code>와 연관된 <code>team</code> 엔티티를 조회할 수 있다.</p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span> <span class="c1">//객체 그래프 탐색</span>
</code></pre></div></div>
</li>
<li>
<p>이처럼 객체를 통해, 연관된 엔티티를 조회하는 것을 객체 그래프 탐색이라고 한다.</p>
</li>
<li>
<p>객체 그래프 탐색에 대한 자세한 내용은 추후에 설명하겠다.</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>객체지향 쿼리 사용
<ul>
<li>
<p>JPQL에서도 조인을 지원하므로, 조인을 사용하여 연관관계를 사용할 수 있다.</p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">queryLogicJoin</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">//jpql</span>
	<span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member m join m.team t where"</span> <span class="o">+</span>
				<span class="s">"t.name=:teamName"</span><span class="o">;</span>

	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
					<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamName"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">)</span>
					<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>JPQL의 <code>from Member m join m.team t</code> 부분을 보면 회원이 팀과 관계를 가지고 있는 필드(m.team)를 통해서, Member와 Team을 조인했다.</p>
</li>
<li>
<p>JPQL을 포함한 객체 쿼리에 대한 상세한 내용은 추후에 다룬다.</p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-14">수정</h3>
<p>이번에는 연관관계를 어떻게 수정하는지 알아보자. <strong>팀1 소속이던 회원을 새로운 팀2에 소속하도록 수정해보자.</strong></p>
<ul>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">updateRelation</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	
	<span class="c1">//새로운 팀2</span>
	<span class="nc">Team</span> <span class="n">team2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team2"</span><span class="o">,</span> <span class="s">"팀2"</span><span class="o">);</span>

	<span class="c1">//회원1에 새로운 팀2를 설정한다.</span>
	<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
	<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>이전 게시글에서 설명했듯이, JPA는 member엔티티의 <strong>모든 필드</strong>를 수정한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>단순히 불러온 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서, 변경감지 기능 (Dirty Checking)이 작동한다. 이러한 기능이 연관관계를 수정할 때도 일어난다.</li>
</ul>
<br/>
<h3 id="section-15">제거</h3>
<p>마지막으로 연관관계를 제거하는 방법에 대해 설명하겠다. <strong>회원1을 팀에 소속하지 않도록 변경해보자.</strong></p>
<ul>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">deleteRelation</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	
	<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
	<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">//연관관계 제거</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>위 코드처럼 null을 사용하여 연관관계를 제거할 수 있다.</p>
</li>
</ul>
<br/>
<h3 id="section-16">연관된 엔티티 삭제</h3>
<p>이제 연관된 엔티티를 삭제하는 방법에 대해 알아보자. (ex. team1 엔티티 삭제) 연관된 엔티티를 삭제하는 절차는 아래와 같다.</p>
<ul>
<li>
<p>연관된 엔티티 삭제 절차</p>
<ol>
<li>연관관계 제거</li>
<li>엔티티 삭제</li>
</ol>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">//회원1 연관관계 제거</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">//회원2 연관관계 제거</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">team</span><span class="o">);</span> <span class="c1">//팀 삭제</span>
</code></pre></div></div>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-17">양방향 연관관계</h2>
<ul>
<li>이번에는 반대 방향인 팀에서 회원으로 접근하는 관계를 추가하자.</li>
<li>“회원→팀”, “팀→회원”이 가능하도록 매핑해보자.</li>
</ul>
<br/>
<h3 id="section-18">양방향 객체 연관관계</h3>
<ul>
<li>먼저 객체 연관관계를 살펴보자.</li>
<li>아래 그림처럼, 회원과 팀은 다대일 관계이다.</li>
<li>반대로, 팀과 회원은 일대다 관계이다.</li>
<li>일대다 관계는 <strong>여러 건과 연관관계를 맺을 수 있으므로, 컬렉션을 사용</strong>해야 한다.</li>
</ul>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%202.png" alt="Untitled" /></p>
<br/>
<h3 id="section-19">양방향 테이블 연관관계</h3>
<ul>
<li>DB 테이블은 외래 키 하나로 양방향 조회가 가능하다.</li>
<li>즉, 처음부터 양방향 관계이다.</li>
<li>따라서, DB에 추가해야하는 내용은 전혀 없다.</li>
</ul>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%203.png" alt="Untitled" /></p>
<br/>
<h3 id="section-20">양방향 연관관계 매핑</h3>
<p>이제 양방향 관계를 매핑해보자.</p>
<ul>
<li>
<p>매핑한 회원 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

	<span class="c1">//연관관계 매핑</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Member</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Member</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//연관관계 설정</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>회원 엔티티 부분은 변경할 사항이 없다.</li>
</ul>
</li>
<li>
<p>매핑한 팀 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">//일대다 관계 설정</span>
	<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;();</span>

	<span class="kd">public</span> <span class="nf">Team</span><span class="o">()</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="nf">Team</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>코드 설명</p>
<ul>
<li>
<p>팀과 회원은 일대다 연관관계이다.</p>
</li>
<li>
<p>따라서, 팀 엔티티에 컬렉션(<code>List&lt;Member&gt;</code>)을 추가했다.</p>
</li>
<li>
<p>그리고 일대다 관계 매핑을 위해 <code>@OneToMany</code> 매핑 정보를 사용했다.</p>
</li>
<li>
<p><code>mappedBy</code> 속성</p>
<ul>
<li>이 속성은 양방향 매핑일 때 사용한다.</li>
<li><strong>반대쪽 매핑의 필드 이름</strong>을 값으로 주면 된다.</li>
<li>따라서, 반대쪽(Member 엔티티)의 필드 team의 이름을 값으로 주었다.</li>
</ul>
<blockquote>
<p>자세한 내용은 아래에서 계속 설명한다.</p>
</blockquote>
</li>
<li>
<p>이것으로 양방향 매핑을 완료했다. 이제부터 팀 엔티티에서 회원 컬렉션으로 객체 그래프를 탐색할 수 있다.</p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-21">일대다 컬렉션 조회</h3>
<p>위에서 설정한 일대다 컬렉션을 조회하는 방법에 대해 알아보자.</p>
<ul>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">biDirection</span><span class="o">()</span> <span class="o">{</span>
	<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"team1"</span><span class="o">);</span>
	
	<span class="c1">//컬렉션 조회</span>
	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">();</span> <span class="c1">//객체 그래프 조회 (팀-&gt;회원)</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-22">연관관계의 주인</h2>
<h3 id="section-23">연관관계의 주인이 필요한 배경</h3>
<p>위에서 설명한 <code>@OneToMany</code> 는 직관적으로 이해할 수 있다. 그렇다면 <code>mappedBy</code> 라는 속성은 왜 필요할까?</p>
<ul>
<li>
<p>객체에는 양방향 연관관계라는 것이 없다.</p>
</li>
<li>
<p>따라서, <strong>서로 다른 단방향 연관관계 2개를 Application 로직으로 잘 묶어서 양방향인 것처럼 보이게 해야한다.</strong></p>
</li>
<li>
<p>객체 연관관계 vs 테이블 연관관계</p>
<ul>
<li><strong>객체 연관관계</strong>
<ul>
<li>회원 → 팀 연관관계 1개 (단방향)</li>
<li>팀 → 회원 연관관계 1개 (단방향)</li>
</ul>
</li>
<li><strong>테이블 연관관계</strong>
<ul>
<li>회원 ↔ 팀 연관관계 1개 (양방향)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>연관관계의 주인 필요성</p>
<ul>
<li>이러한 객체와 테이블간의 차이 때문에, <strong>JPA는 연관관계의 주인으로 연관관계를 관리</strong>한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-24">연관관계의 주인이란?</h3>
<ul>
<li>연관관계의 주인이란, <strong>두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리하는 것</strong>이다.</li>
<li>엔티티 자체가 아닌, <strong>엔티티의 연관관계 필드(외래키 필드)가 연관관계의 주인으로 선택</strong>된다.</li>
<li><strong>즉, 연관관계의 주인을 정한다는 것은 외래키 관리자를 선택하는 것이다.</strong></li>
</ul>
<br/>
<h3 id="section-25">양방향 매핑의 규칙: 연관관계의 주인</h3>
<ul>
<li><strong>연관관계의 주인만이 ‘DB 연관관계’와 매핑되고, ’외래키를 관리(등록, 수정, 삭제)’할 수 있다.</strong></li>
<li>반면에 주인이 아닌 쪽은 읽기만 할 수 있다.</li>
</ul>
<br/>
<h3 id="section-26">연관관계의 주인 설정</h3>
<ul>
<li>위에서 설명한 <code>@OneToMany</code> 애너테이션의 속성 <code>mappedBy</code> 를 통해 연관관계의 주인을 설정할 수 있다.</li>
<li><strong>연관관계의 주인은 <code>mappedBy</code> 속성을 사용하지 않는다.</strong></li>
<li><strong>주인이 아니면, <code>mappedBy</code> 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.</strong></li>
<li><strong>연관관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이다.</strong>
<ul>
<li>즉, 회원·팀 예시에서는 <code>TEAM_ID</code> 외래키를 관리할 관리자를 선택해야한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>그렇다면 어떤 것을 연관관계의 주인으로 선택해야할까?
<ul>
<li>
<p>먼저 객체 연관관계와 테이블 연관관계를 다시 보자.</p>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%202.png" alt="Untitled" /></p>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%203.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>회원 엔티티에 있는 <code>Member.team</code> 필드를 주인으로 선택시</strong></p>
<ul>
<li>자기 테이블에 있는 외래키(<code>TEAM_ID</code>)를 관리하면 된다.</li>
</ul>
</li>
<li>
<p><strong>팀 엔티티에 있는 <code>Team.members</code> 필드를 주인으로 선택시</strong></p>
<ul>
<li>물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다.</li>
<li>왜냐하면 Team 엔티티는 TEAM 테이블에 매핑되어 있는데, 관리해야할 외래키는 MEMBER 테이블에 있기 때문이다.</li>
<li>따라서, <strong>연관관계의 주인은 <code>Member.team</code> 이다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>정리
<ul>
<li>MEMBER 테이블에 TEAM_ID라는 외래키가 존재하므로, 연관관계의 주인은 <code>Member.team</code> 필드이다.
<ul>
<li>다시말해, 외래키가 존재하는 테이블과 매핑된 엔티티의 연관 필드가 연관 관계의 주인이 되는 것이 자연스럽다.</li>
<li>왜냐하면, 반대쪽 엔티티가 가지고 있지 않은 외래키를 관리하는 것이 부자연스럽기 때문이다.</li>
</ul>
</li>
<li>연관관계의 주인만이 ‘DB 연관관계’와 매핑되고, ’외래키를 관리(등록, 수정, 삭제)’할 수 있다.</li>
<li>연관관계의 주인이 아닌 반대편은 읽기만 가능하고 외래키를 변경하지는 못한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-27">연관관계의 주인은 외래키가 있는 곳</h3>
<ul>
<li>
<p><strong>연관관계의 주인은 테이블에 외래키가 있는 곳으로 정해야 한다.</strong></p>
</li>
<li>
<p>주인 설정하기</p>
<ul>
<li>주인이 아닌 필드: <code>mappedBy</code> 속성의 값으로 ‘주인인 필드의 이름’을 넘겨준다</li>
<li>주인인 필드: 추가적으로 할 것은 없다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>주인 설정 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
	<span class="c1">//...</span>

	<span class="c1">//일대다 관계 설정, 연관관계의 주인 필드명 설정</span>
	<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;();</span>

	<span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="codemappedbycode--codeonetomanycode--"><code>mappedBy</code> 속성이 <code>@OneToMany</code>에만 존재하는 이유</h3>
<ul>
<li>DB 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 갖는다.</li>
<li><strong>즉 <code>@ManyToOne</code> 이 항상 연관관계의 주인이 되므로, <code>@OneToMany</code> 에만 <code>mappedBy</code> 속성이 존재한다.</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="section-28">양방향 연관관계 연산</h2>
<h3 id="section-29">저장</h3>
<p>양방향 연관관계를 사용해서 팀1, 회원1, 회원2를 저장해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSave</span><span class="o">()</span> <span class="o">{</span>
	
	<span class="c1">//팀1 저장</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

	<span class="c1">//회원1 저장</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member1 -&gt; team1)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

	<span class="c1">//회원2 저장</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member2 -&gt; team1)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>이 코드는 단방향 연관관계에서 살펴본 코드와 완전히 같다.</li>
</ul>
<br/>
<ul>
<li>DB 조회 결과
<ul>
<li><code>SELECT * FROM MEMBER;</code></li>
<li><strong>TEAM_ID 외래키에 팀의 기본키 값이 저장되어 있다.</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>MEMBER_ID</th>
<th>USERNAME</th>
<th>TEAM_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>member1</td>
<td>회원1</td>
<td>team1</td>
</tr>
<tr>
<td>member2</td>
<td>회원2</td>
<td>team1</td>
</tr>
</tbody>
</table>
<br/>
<h3 id="section-30">양방향 연관관계의 주의점</h3>
<ul>
<li>
<p>양방향 연관관계는 연관관계의 주인이 외래키를 관리한다.</p>
</li>
<li>
<p>따라서, 아래 코드는 DB에 반영되지 않는다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">//무시됨</span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">//무시됨</span>
</code></pre></div></div>
</li>
<li>
<p>아래 코드는 DB에 반영된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정됨</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정됨</span>
</code></pre></div></div>
</li>
<li>
<p>양방향 연관관계를 설정하고 가장 흔히 하는 **실수가 바로, “연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것”**이다.</p>
<ul>
<li>이런 경우, 연관관계 설정이 DB에 반영되지 않는다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-31">순수한 객체까지 고려한 양방향 연관관계</h3>
<ul>
<li>
<p>위에서 연관관계의 주인에만 값을 설정해도, 연관관계 설정이 DB에 반영된다고 이야기했다.</p>
</li>
<li>
<p>그렇다면 연관관계의 주인인 필드에만 값을 설정해도 될까? 정답은 아니오이다.</p>
</li>
<li>
<p><strong>사실 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다.</strong></p>
<ul>
<li>만약, 양쪽 방향에 값을 설정해주지 않는다면, 순수한 객체 관점에서는 문제가 일어날 수 있다.</li>
<li>예를 들어, JPA를 사용하지 않는 테스트 코드를 작성할 경우에 문제가 발생할 수 있다.</li>
</ul>
<blockquote>
<p>ORM은 객체와 관계형 DB 모두 신경을 써야한다.</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p>문제 테스트코드 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"순수한객체 양방향"</span><span class="o">)</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
	
	<span class="c1">//팀1</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>

	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정</span>
	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정</span>

	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">();</span>
	
	<span class="n">assertEquals</span><span class="o">(</span><span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>결과 = Fail (expected: 2, actual: 0)</li>
<li>이 결과는 당연한 것이다. 왜냐하면, <code>Member.team</code> 에만 연관관계를 설정하고 반대 방향은 연관관계를 설정하지 않았기 때문이다.</li>
<li>따라서, <code>members.size()</code> 의 값은 0이 나온다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>이러한 상황을 해결하기 위해, 양쪽 모두 관계를 설정해서 다시 테스트해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"순수한객체 양방향"</span><span class="o">)</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
	
	<span class="c1">//팀1</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>

	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member1 -&gt; team1)</span>
	<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (team1 -&gt; member1)</span>

	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member2 -&gt; team1)</span>
	<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">//연관관계 설정 (team1 -&gt; member2)</span>

	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">();</span>
	
	<span class="n">assertEquals</span><span class="o">(</span><span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>결과 = Success (expected: 2, actual: 2)</li>
<li>객체까지 고려하면 이렇게 양쪽 다 관계를 맺어야 한다. 단순히 DB의 경우만 생각해서는 안된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>이제 JPA를 사용해서 양쪽 관계를 모두 맺어보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testORM</span><span class="o">()</span> <span class="o">{</span>
	
	<span class="c1">//팀1 저장</span>
	<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

	<span class="c1">//회원1 양방향 관계 설정</span>
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
	<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member1 -&gt; team1)</span>
	<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (team1 -&gt; member1)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

	<span class="c1">//회원2 양방향 관계 설정</span>
	<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
	<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 (member2 -&gt; team1)</span>
	<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">//연관관계 설정 (team1 -&gt; member2)</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p>이제 순수한 객체 상태에서도 동작하고, 테이블의 외래키도 정상 입력된다.</p>
<blockquote>
<p>물론 외래키의 경우, <code>Member.team</code> 필드를 사용한다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>정리
<ul>
<li><code>member1.setTeam(team1);</code>
<ul>
<li>연관관계의 주인</li>
<li>DB 저장시에 사용되고, 객체 관점에서도 사용된다.</li>
</ul>
</li>
<li><code>team1.getMembers().add(member1);</code>
<ul>
<li>객체 관점에서만 사용된다.</li>
<li>객체 상태를 위해, 작성된 코드이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>결론
<ul>
<li><strong>객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자.</strong>
<ul>
<li>객체와 테이블 모두 고려해야하므로</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-32">연관관계 편의 메서드</h2>
<h3 id="section-33">연관관계 편의 메서드란?</h3>
<ul>
<li>양방향 연관관계는 결국 양쪽 다 신경써야 한다.</li>
<li>하지만, 이것을 매번 반복하기엔 상당히 귀찮다.</li>
<li>따라서, 양쪽 다 신경쓰기 위한 로직을 메서드 하나로 처리할 수 있는 것을 <strong>연관관계 편의 메서드</strong>라 한다.</li>
</ul>
<br/>
<h3 id="section-34">연관관계 편의 메서드 예시</h3>
<ul>
<li>
<p>Member 엔티티 수정</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="c1">//setter 수정</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span> <span class="c1">//기존 코드</span>
		<span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//Team쪽에도 연관관계 설정</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>실행 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//양쪽 모두 연관관계가 설정된다.</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//양쪽 모두 연관관계가 설정된다.</span>

<span class="c1">//== 기존 코드 삭제 ==</span>
<span class="c1">//team1.getMembers().add(member1);</span>
<span class="c1">//team1.getMembers().add(member2);</span>
<span class="c1">//====================</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="section-35">편의 메서드 작성시 주의사항</h3>
<ul>
<li>
<p>사실 우리가 방금 살펴본 <code>setTeam()</code> 메서드에는 버그가 있다.</p>
</li>
<li>
<p>버그 시나리오</p>
<ol>
<li>회원1의 팀을 팀A로 설정한다.</li>
<li>그후, 회원1의 팀을 다시 팀B로 설정한다.</li>
<li>이때 팀A의 <code>members</code> 필드에 회원1이 그대로 남는다.</li>
</ol>
<ul>
<li>아래 코드로 어떻게 버그가 발생하는지 알아보자.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamA</span><span class="o">);</span> <span class="c1">//연관관계: (member1-&gt;teamA), (teamA-&gt;member1)</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamB</span><span class="o">);</span> <span class="c1">//연관관계: (member1-&gt;teamB), (teamB-&gt;member1)</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">teamA</span><span class="o">.</span><span class="na">getMembers</span><span class="o">();</span> <span class="c1">//member1이 여전히 조회된다. (teamA-&gt;member1)</span>
</code></pre></div></div>
</li>
<li>
<p>이 상황을 시각화한 것이 아래 그림이다.</p>
<p><img src="/assets/img/2021-10-18-JPA_Relation_Basic/Untitled%204.png" alt="Untitled" /></p>
<ul>
<li>teamA의 members 필드가 여전히 member1을 가지고 있다. (참조하고 있다.)</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>버그의 원인</p>
<ul>
<li>teamB로 변경할 때, ‘teamA→member1’ 관계를 제거하지 않았다.</li>
<li>즉 연관관계를 변경할 때는, 기존 팀이 있으면 <strong>기존 팀과 회원의 연관관계를 삭제하는 코드를 추가</strong>해야 한다.</li>
</ul>
</li>
<li>
<p>버그 해결</p>
<ul>
<li>아래 코드는 기존 관계를 제거하는 코드가 포함된 <code>setTeam()</code> 편의 메서드이다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//만약 기존팀이 존재한다면</span>
		<span class="k">this</span><span class="o">.</span><span class="na">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//현재 인스턴스 객체를 지운다.</span>
	<span class="o">}</span>

	<span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//현재 인스턴스 객체를 새 팀에 추가한다.</span>
	<span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="section-36">참고사항</h3>
<ul>
<li>“teamA → member1” 관계가 제거되지 않아도 DB 외래키를 변경하는데는 문제없다.</li>
<li>왜냐하면, 외래키 변경은 연관관계의 주인(<code>Member.team</code>)에서 주관하기 때문이다.</li>
<li>즉, <code>Team.members</code> 가 연관관계의 주인이 아니기 때문에, DB 외래키는 변경이 정상적으로 된다.</li>
<li><strong>하지만, 꼭 관계가 정리되도록 하자.</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="section-37">정리</h2>
<p>내용을 정리하면 다음과 같다.</p>
<ul>
<li><strong>단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.</strong>
<ul>
<li>연관관계의 주인을 통해, 연관 엔티티를 DB에 적용할 수 있으므로</li>
</ul>
</li>
<li><strong>단방향을 양방향으로 만들면, 반대방향으로 객체 그래프 탐색 기능이 추가된다.</strong></li>
<li><strong>양방향 연관관계를 매핑하려면, 객체에서 양쪽 방향을 모두 관리해야 한다.</strong></li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET