I"O_<p><br/><br/></p>
<h1 id="section">컴퓨터 구조 개요</h1>
<h2 id="section-1">컴퓨터의 조직과 기능</h2>
<h3 id="sw-hw">컴퓨터 SW와 HW</h3>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled.png" alt="Untitled" /></p>
<ul>
<li><strong>Application designer</strong>
<ul>
<li>일반적인 응용 애플리케이션 계층</li>
<li>Software</li>
</ul>
</li>
<li><strong>System designer</strong>
<ul>
<li>OS 나 컴파일러와 같은 시스템 계층</li>
<li>Software</li>
</ul>
</li>
<li><strong>Logic designer</strong>
<ul>
<li>논리회로 계층</li>
<li>Hardware</li>
</ul>
</li>
<li><strong>Circuit designer</strong>
<ul>
<li>전자회로 계층</li>
<li>Hardware</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-2">컴퓨터의 기능</h3>
<ul>
<li><strong>데이터 처리</strong>
<ul>
<li>관련 장치: CPU의 ALU</li>
</ul>
</li>
<li><strong>데이터 저장</strong>
<ul>
<li>관련 장치: RAM, HDD 등</li>
</ul>
</li>
<li><strong>데이터 이동</strong>
<ul>
<li>관련 장치: Bus</li>
</ul>
</li>
<li><strong>제어</strong></li>
</ul>
<br/>
<h3 id="section-3">컴퓨터의 조직</h3>
<ul>
<li><strong>중앙처리장치</strong>
<ul>
<li>CPU</li>
</ul>
</li>
<li><strong>주기억 장치</strong>
<ul>
<li>Main Memory</li>
</ul>
</li>
<li><strong>입출력</strong>
<ul>
<li>I/O</li>
</ul>
</li>
<li><strong>시스템 상호연결</strong>
<ul>
<li>Bus</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%201.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-4">컴퓨터 구성</h2>
<h3 id="section-5">컴퓨터 주요 부품 목록</h3>
<ul>
<li>Main Board</li>
<li>CPU</li>
<li>RAM</li>
<li>Chipset</li>
<li>HDD</li>
<li>DVD</li>
<li>Graphic card</li>
<li>Power Supply</li>
</ul>
<br/>
<h3 id="main-board">Main Board</h3>
<ul>
<li>공통의 버스 배선과 인터페이스 회로를 모아 놓고, 슬롯 형태의 작은 보드를 꽂아 사용하는 기판 구조에서 어미가 되는 기판이다.</li>
</ul>
<br/>
<h3 id="section-6">중앙처리장치</h3>
<ul>
<li>
<p>컴퓨터 시스템 전체를 제어한다.</p>
</li>
<li>
<p><strong>CPU 구성요소</strong></p>
<ul>
<li>ALU: 산술·논리 연산장치</li>
<li>C.U: 제어장치</li>
<li>R: 레지스터</li>
</ul>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%202.png" alt="Untitled" /></p>
<ul>
<li>
<p>CPU의 Cache 장치 필요성</p>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%203.png" alt="Untitled" /></p>
<ul>
<li><strong>L1 Cache</strong></li>
<li><strong>L2 Cache</strong></li>
<li><strong>L3 Cache</strong></li>
<li>위 순서대로 용량이 커지며, 프로세서가 순서대로 확인한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="chipset">Chipset</h3>
<ul>
<li>여러 칩과 회로가 모여 서로 연관된 기능을 수행하도록 설계된 제어칩들의 조합이다.</li>
<li>CPU 프로세서와 함께 시스템 전체를 제어한다.</li>
<li><strong>칩셋 내부 회로</strong>
<ul>
<li>CPU를 지원하는 각종 제어 장치들로 구성되어 있다.</li>
<li>버스 컨트롤러, 메모리 컨트롤러, I/O 컨트롤러, 인터럽트 컨트롤러, 타이머 등</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>요즘에는 CPU에 Chipset이 내장되어 있다.</strong></p>
</blockquote>
<br/>
<h3 id="section-7">주기억장치</h3>
<ul>
<li>수행 중인 프로그램과 이를 위해서 필요한 데이터를 기억하고 있는 장치</li>
<li><strong>비교적 CPU에 접근 속도가 빠르며 많은 용량을 기억한다.</strong></li>
<li><strong>RAM(Random Access Memory)이 주로 사용된다.</strong>
<ul>
<li>D-RAM
<ul>
<li>Dynamic</li>
<li>전력 공급이 끊어지면, 데이터가 삭제됨.</li>
</ul>
</li>
<li>S-RAM
<ul>
<li>Static</li>
<li>전력 공급이 끊어져도, 데이터는 유지됨.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-8">보조기억 장치</h3>
<ul>
<li>외부 기억장치</li>
<li>반영구적으로 데이터를 저장하고 보존한다.</li>
<li><strong>중앙처리장치와 직접 정보를 교환할 수 없기 때문에, 저장된 데이터가 주기억장치로 옮겨진 후 처리된다.</strong></li>
<li>주기억장치에 비해, 가격은 저렴하고 용량이 크지만 속도가 느리다.</li>
</ul>
<p><br/><br/></p>
<h2 id="section-9">소프트웨어</h2>
<h3 id="section-10">시스템 소프트웨어</h3>
<ul>
<li>컴퓨터 시스템을 제어하고 효율적으로 사용하기 위해 만들어진 소프트웨어</li>
<li>운영체제, 디바이스 드라이버, 컴파일러, 인터프리터</li>
</ul>
<br/>
<h3 id="section-11">프로그래밍에서의 모델 및 추상 수준</h3>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%204.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-12">집적회로</h2>
<h3 id="section-13">무어의 법칙</h3>
<ul>
<li>컴퓨터의 크기가 작어졌다.</li>
<li>논리회로/기억 소자들이 가까워져 전기적 통로의 길이가 줄어들어 동작 속도가 상승했다.</li>
<li>집적회로 내에서 연결되어 납땜 연결보다 신뢰성이 높아졌다.</li>
<li>집적도가 상승되는 동안 칩 가격은 변하지 않았다.</li>
<li>전력 소모가 줄어들었다.</li>
</ul>
<p><br/><br/></p>
<h2 id="section-14">컴퓨터의 성능 향상</h2>
<h3 id="section-15">성능 균형 문제</h3>
<ul>
<li>
<p><strong>성능 균형 문제란?</strong></p>
<ul>
<li>프로세서와 주기억장치 간 인터페이스에서 병목이 발생하는 현상</li>
</ul>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%205.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>입출력 장치에서의 성능 균형 문제</strong></p>
<ul>
<li>프로세서와 입출력 장치 간의 데이터 이동은 여전히 해결되지 않은 문제이다.</li>
</ul>
</li>
<li>
<p><strong>성능 균형 문제 해결법</strong></p>
<ul>
<li>버스 대역폭 확대</li>
<li><strong>(CPU 내부의) 캐시 메모리 활용</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpu--">CPU 동작 순서</h3>
<ol>
<li>명령어 인출</li>
<li>명령어 해독</li>
<li>데이터 인출</li>
<li>데이터 처리 (실행)</li>
<li>데이터 저장</li>
</ol>
<br/>
<h3 id="section-16">프로세서 속도 향상 방안</h3>
<ul>
<li><strong>프로세서의 하드웨어 속도 증가시키기</strong>
<ul>
<li>논리 게이트 크기를 줄이고, 더 많은 게이트를 조밀하게 넣는다.</li>
<li><strong>클럭 속도를 높인다.</strong></li>
<li>신호들의 전파 시간을 감소시킨다.</li>
</ul>
</li>
<li>프로세서-주기억장치 사이에 존재하는, <strong>캐시의 크기와 속도를 증가시킨다.</strong></li>
<li><strong>명령어 실행 속도를 높일 수 있도록, 프로세서 조직과 구조를 변경한다.</strong>
<ul>
<li>
<p><strong>파이프라이닝</strong></p>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%206.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>수퍼스칼라</strong></p>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%207.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpu-">CPU 클럭이란?</h3>
<ul>
<li><strong>CPU가 일을 하는 단위이다.</strong>
<ul>
<li>ex) 명령어 해독</li>
</ul>
</li>
<li>클럭율: Hz로 나타낸다.</li>
</ul>
<br/>
<h3 id="section-17">클럭 속도와 회로 밀도 문제</h3>
<ul>
<li>칩 내부 회로의 밀도와 클럭 속도가 높아지면, <strong>전력밀도(단위면적당 전력소모량)이 증가한다.</strong></li>
<li><strong>트랜지스터 하나가 소비하는 전력</strong>
<ul>
<li>‘논리 값이 한번 바뀔때 소모되는 에너지’ * ‘시간당 논리 값이 바뀌는 빈도수’</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-18">성능 향상을 위한 새로운 시도: 멀티코어</h3>
<ul>
<li>멀티코어
<ul>
<li><strong>큰 용량의 캐시를 공유</strong>하는 여러 프로세서를 하나의 칩에 배치한 것이다.</li>
</ul>
</li>
<li>하나의 복잡한 프로세서를 사용하기보다는, 칩 내에 더 간단한 여러 프로세서를 배치하는 것이 좋다.
<ul>
<li>소프트웨어가 여러 개의 프로세서들을 효과적으로 사용하도록 지원한다면, 프로세서의 개수 만큼 성능 향상을 기대할 수 있다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-19">컴퓨터 성능 평가</h2>
<h3 id="section-20">프로세서의 평가 요소</h3>
<ul>
<li>성능</li>
<li>가격</li>
<li>크기</li>
<li>전력 소비</li>
<li>신뢰성</li>
</ul>
<br/>
<h3 id="section-21">관점에 따른 컴퓨터 성능 평가</h3>
<ul>
<li><strong>사용자 관점</strong>
<ul>
<li>응답시간 or 실행시간이 중요하다.</li>
<li><strong>실행시간</strong>
<ul>
<li>컴퓨터가 테스크를 완료하기까지의 총 소요시간</li>
<li>디스크 접근, 메모리 접근, 입출력 작업, 운영체제의 오버헤드 및 CPU 시간을 포함한다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>시스템 관점</strong>
<ul>
<li>처리량 or 대역폭이 중요하다.</li>
<li><strong>대역폭</strong>
<ul>
<li>일정한 시간 동안 처리하는 작업의 양</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-22">성능의 정의</h3>
<ul>
<li>
<p>프로그램의 실행 시간</p>
<ul>
<li>한 작업을 끝내는데 필요한 전체 시간</li>
<li>디스크 접근, 메모리 접근, 입출력 작업, 운영체제의 오버헤드 등 모든 시간을 더한 것이다.</li>
<li><strong>CPU 실행 시간 (CPU 시간)</strong>
<ul>
<li>프로세서가 순수하게 이 프로그램을 실행하기 위해서 소비한 시간</li>
</ul>
</li>
</ul>
</li>
<li>
<p>성능의 정의</p>
<ul>
<li>성능 = 1 / 수행시간</li>
<li>성능 = 1 / CPU실행시간
<ul>
<li><strong>CPU실행시간 = 명령어_수 * 명령어당_클럭_사이클_수 * 사이클당_초</strong></li>
<li><strong>CPU실행시간 = 명령어_수 * CPI / 클록율</strong></li>
</ul>
</li>
<li><strong>CPI: 명령어당 클럭 사이클 수</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-23">성능에 영향을 미치는 요소</h3>
<ul>
<li><strong>클록 사이클 수 (clock cycles)</strong>
<ul>
<li>클럭 사이클이란?<br />
<img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%208.png" alt="Untitled" /></li>
<li>공식
<ul>
<li><img src="https://latex.codecogs.com/svg.image?ClockCycle=I_%7Bc%7D*CPI" alt="ClockCycle=I_{c}*CPI" /></li>
</ul>
<blockquote>
<p><img src="https://latex.codecogs.com/svg.image?I_%7Bc%7D" alt="I_{c}" /> 와 <img src="https://latex.codecogs.com/svg.image?CPI" alt="CPI" />에 대해선 아래에서 설명하겠다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>클록율 (clock rate)</strong></p>
<ul>
<li>Hz 단위로 표현한다.</li>
<li>1 Hz = 1초에 1개의 사이클을 수행한다.</li>
<li>공식
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7BClockCycles%7D%7BCPUTime%7D" alt="\frac{ClockCycles}{CPUTime}" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>예시</p>
<ul>
<li>10 나노초에 1개의 사이클을 수행한다. ⇒ 10 nsec(nano second) <em>clock cycle</em> ⇒ 100 MHz <em>clock rate</em></li>
<li>2 나노초에 1개의 사이클을 수행한다. ⇒ 2 nsec <em>clock cycle</em> ⇒ 500 MHz <em>clock rate</em></li>
<li>1 나노초에 1개의 사이클을 수행한다. ⇒ 1 nsec <em>clock cycle</em> ⇒ 1 GHz <em>clock rate</em></li>
<li>200 피코초에 1개의 사이클을 수행한다. ⇒ 200 psec(pico second) <em>clock cycle</em> ⇒ 5GHz <em>clock rate</em></li>
</ul>
</li>
<li>
<p>단위 정리</p>
<ul>
<li>나노: 10^(-9)</li>
<li>피코: 10^(-12)</li>
<li>GHz: 1,000,000,000 Hz (10억)</li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpi">명령어 당 사이클 수 (CPI)</h3>
<ul>
<li>CPI: Cycles Per Instruction</li>
<li><strong>하나의 명령어를 수행하기 위해서 소요되는 클럭 사이클 수 (평균)</strong></li>
<li><strong>공식</strong>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?CPI=%5Cfrac%7B%5Csum_%7Bi=1%7D%5E%7Bn%7D%7BCPI%7D_i*I_i%7D%7BI_c%7D" alt="CPI=\frac{\sum_{i=1}^{n}{CPI}_i*I_i}{I_c}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?%7BCPI%7D_i" alt="{CPI}_i" /> : 명령어 유형 <img src="https://latex.codecogs.com/svg.image?I_i" alt="I_i" />를 위해 필요한 사이클 수</li>
<li><img src="https://latex.codecogs.com/svg.image?I_i" alt="I_i" /> : 전체 명령어 중 특정 유형에 속한 명령어의 수</li>
<li><img src="https://latex.codecogs.com/svg.image?I_c" alt="I_c" /> : 전체 명령어의 수</li>
<li>n : 명령어 유형의 개수</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>주어진 프로그램을 수행하는데 필요한 프로세서(CPU) 시간 T</strong>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T=I_c*CPI*%5Ctau" alt="T=I_cCPI\tau" /></li>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau" alt="\tau" /> : 클럭 사이클 시간</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>명령어 실행 및 기억장치 이동시간 등을 고려한 프로세서(CPU) 시간 T</strong>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T=I_c*%5Bp+(m*k)%5D*%5Ctau" alt="T=I_c*[p+(mk)]\tau" /></li>
<li><img src="https://latex.codecogs.com/svg.image?p" alt="T=I_c*[p+(mk)]\tau" /> : 명령어를 해독하고 실행하는데 필요한 프로세서 사이클의 수</li>
<li><img src="https://latex.codecogs.com/svg.image?m" alt="T=I_c*[p+(mk)]\tau" /> : 필요한 기억장치 참조 수</li>
<li><img src="https://latex.codecogs.com/svg.image?k" alt="T=I_c*[p+(mk)]\tau" /> : 기억장치 사이클 시간과 프로세서 사이클 시간 간의 비율</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-24">명령어 세트</h3>
<ul>
<li>
<p>명령어 수</p>
<ul>
<li>하나의 프로그램을 수행하기 위해서 필요한 기계 명령어 개수</li>
</ul>
</li>
<li>
<p>명령어 세트 종류</p>
<ul>
<li><strong>CISC 명령어 세트 (시스크)</strong>
<ul>
<li>시스크 프로세서에서 사용된다.</li>
</ul>
</li>
<li><strong>RISC 명령어 세트 (리스크)</strong>
<ul>
<li>리스크 프로세서에서 사용된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>즉, 프로세서(CPU)의 종류에 따라 명령어 세트가 결정된다.</p>
</blockquote>
</li>
<li>
<p>예시</p>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%209.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="cpi---1">예제 문제: CPI - 1</h3>
<ul>
<li>문제
<ul>
<li>같은 명령어 집합 구조 (CISC or RISC)를 구현한 컴퓨터 두 종류가 있다. 컴퓨터 A의 <strong>클럭 사이클 시간은 250ps</strong>이고 어떤 프로그램에 대한 <strong>CPI는 2.0</strong>이다.<br />
컴퓨터 B의 <strong>클럭 사이클 시간은 500ps</strong>이고, <strong>CPI는 1.2</strong>이다. 이 프로그램에 관해서는 어떤 컴퓨터가 얼마나 더 빠른가?</li>
</ul>
</li>
<li>풀이
<ul>
<li>공식: 주어진 프로그램을 수행하는데 필요한 프로세서 시간<br />
<img src="https://latex.codecogs.com/svg.image?T=I_c*CPI*%5Ctau" alt="T=I_cCPI\tau" /></li>
<li>컴퓨터 A의 프로세서 시간
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T=I_c*2.0*250ps=500ps*I_c" alt="T=I_c2.0250ps=500ps*I_c" /></li>
</ul>
</li>
<li>컴퓨터 A의 프로세서 시간
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T=I_c*1.2*500ps=600ps*I_c" alt="T=I_c1.2500ps=600ps*I_c" /></li>
</ul>
</li>
<li>이때, 컴퓨터 A와 B가 서로 같은 명령어 집합 구조를 구현했다고 했다.
<ul>
<li>따라서, <img src="https://latex.codecogs.com/svg.image?I_c" alt="I_c" /> 는 A와 B 모두 동일하다.</li>
</ul>
</li>
<li>그러므로, <img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B600ps*I_c%7D%7B500ps*I_c%7D=1.2" alt="\frac{600psI_c}{500psI_c}=1.2" /> 이다.</li>
<li><strong>즉, 컴퓨터 A가 B보다 1.2배 빠르다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpi---2">예제 문제: CPI - 2</h3>
<ul>
<li>
<p>문제</p>
<ul>
<li>어떤 컴파일러 설계자가 같은 상위 수준 언어 문장에 대해 생성된 <strong>두가지 코드 1과 2 중 하나를 선택</strong>하려고 한다.<br />
어떤 코드가 더 많은 명령어를 실행하는가? 어떤 코드가 더 빠른가? 각 코드의 CPI는 얼마인가?</li>
</ul>
<p><img src="/assets/img/2021-09-10-ComputerStructure_Summary/Untitled%2010.png" alt="Untitled" /></p>
</li>
<li>
<p>풀이 및 정답</p>
<ul>
<li>
<p>문제: 어떤 코드가 더 많은 명령어를 실행하는가?</p>
<ul>
<li>코드 1의 총 명령어 개수
<ul>
<li><img src="https://latex.codecogs.com/svg.image?2+1+2=5" alt="2+1+2=5" /></li>
</ul>
</li>
<li>코드 2의 총 명령어 개수
<ul>
<li><img src="https://latex.codecogs.com/svg.image?4+1+1=6" alt="4+1+1=6" /></li>
</ul>
</li>
<li>정답: 코드 2</li>
</ul>
</li>
<li>
<p>문제: 어떤 코드가 더 빠른가?</p>
<ul>
<li>코드 1의 클럭 사이클
<ul>
<li><img src="https://latex.codecogs.com/svg.image?1*2+2*1+3*2=10" alt="12+21+3*2=10" /></li>
</ul>
</li>
<li>코드 2의 클럭 사이클
<ul>
<li><img src="https://latex.codecogs.com/svg.image?1*4+2*1+3*1=9" alt="14+21+3*1=9" /></li>
</ul>
</li>
<li>정답: 코드 2</li>
</ul>
</li>
<li>
<p>문제: 각 코드의 CPI</p>
<ul>
<li>코드 1의 CPI
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B(1*2+2*1+3*2)%7D%7B5%7D=2" alt="\frac{(12+21+3*2)}{5}=2" /></li>
</ul>
</li>
<li>코드 2의 CPI
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B(1*4+2*1+3*1)%7D%7B6%7D=1.5" alt="\frac{(14+21+3*1)}{6}=1.5" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpi---3">예제 문제: CPI - 3</h3>
<ul>
<li>문제
<ul>
<li><strong>2GHz 클럭의 컴퓨터 A에서 10초에 수행되는 프로그램</strong>이 있다. 이 프로그램을 <strong>6초 동안에 실행할 컴퓨터 B를 설계</strong>하고자 한다.<br />
클럭 속도는 얼마든지 빠르게 만들 수 있는데, 이렇게 하면 CPU의 다른 부분에 대한 설계에 영향을 미쳐 같은 프로그램에 대해 <strong>A보다 1.2배 많은 클럭 사이클이 필요</strong>하다고 한다.<br />
컴퓨터 B의 클럭 속도는 얼마로 해야하는가?</li>
</ul>
</li>
<li>풀이
<ul>
<li>공식: 클록율<br />
<img src="https://latex.codecogs.com/svg.image?ClockRate=%5Cfrac%7BClockCycles%7D%7BCPUTime%7D" alt="ClockRate=\frac{ClockCycles}{CPUTime}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?2GHz=%5Cfrac%7BClockCycles_A%7D%7B10s%7D" alt="2GHz=\frac{ClockCycles_A}{10s}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?ClockCycles_A=2*10%5E%7B9%7D*10" alt="ClockCycles_A=2*10^{9}*10" /></li>
<li><img src="https://latex.codecogs.com/svg.image?ClockCycles_B=2*10%5E%7B9%7D*10*1.2" alt="ClockCycles_B=2*10^{9}101.2" /></li>
<li><img src="https://latex.codecogs.com/svg.image?ClockRate_B=%5Cfrac%7B2*10%5E%7B9%7D*10*1.2Hz%7D%7B6s%7D=%5Cfrac%7B24*10%5E%7B9%7DHz%7D%7B6s%7D=4GHz" alt="ClockRate_B=\frac{210^{9}101.2Hz}{6s}=\frac{2410^{9}Hz}{6s}=4GHz" /></li>
<li>그러므로, 컴퓨터 B의 클럭속도는 4GHz 로 해야한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-25">암달의 법칙</h3>
<ul>
<li>암달의 법칙
<ul>
<li>단일 프로세서와 비교하여, 다수의 프로세서들을 사용한 프로그램의 잠재적 속도 향상 정도를 다룬다.</li>
</ul>
</li>
<li>공식
<ul>
<li><img src="https://latex.codecogs.com/svg.image?SpeedUp=%5Cfrac%7BT(1-f)+Tf%7D%7BT(1-f)+%5Cfrac%7BTf%7D%7BN%7D%7D=%5Cfrac%7B1%7D%7B(1-f)+%5Cfrac%7Bf%7D%7BN%7D%7D" alt="SpeedUp=\frac{T(1-f)+Tf}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?T" alt="T" /> : 단일 프로세서를 이용하여 특정 프로그램을 처리하는데 걸리는 시간</li>
<li><img src="https://latex.codecogs.com/svg.image?N" alt="N" /> : <strong>병렬 프로세서의 개수</strong></li>
<li><img src="https://latex.codecogs.com/svg.image?f" alt="f" /> : 한 프로그램에서 스케줄링 오버헤드 없이, 무한히 <strong>병렬화할 수 있는 코드의 비율</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-26">예제 문제: 암달의 법칙 - 1</h3>
<ul>
<li>문제
<ul>
<li>어떤 연산의 수행 시간이 50%를 차지하는 프로그램이 존재한다.</li>
<li>이때, 하드웨어를 2배 빠르게 만든다면(2개의 프로세서를 사용한다면) 수행시간이 얼마나 향상되는가?</li>
<li>또, 이 연산을 2배 빠르게 수행하려면 하드웨어를 얼마나 개선해야하는가?</li>
</ul>
</li>
<li>풀이
<ul>
<li>공식: 다수의 프로세서를 사용했을 때 얼마나 빨라지겠는가<br />
<img src="https://latex.codecogs.com/svg.image?SpeedUp=%5Cfrac%7BT(1-f)+Tf%7D%7BT(1-f)+%5Cfrac%7BTf%7D%7BN%7D%7D=%5Cfrac%7B1%7D%7B(1-f)+%5Cfrac%7Bf%7D%7BN%7D%7D" alt="SpeedUp=\frac{T(1-f)+Tf}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B1%7D%7B(1-0.5)+%5Cfrac%7B0.5%7D%7B2%7D%7D=1.33" alt="\frac{1}{(1-0.5)+\frac{0.5}{2}}=1.33" /></li>
<li>그러므로, 1.33 배 향상된다.</li>
<li>또한, 하드웨어 개선을 통해 2배로 빠르게 계산할 수 없다. 왜냐하면 N이 무한대여도 공식으로 불가능하기 때문이다.
<ul>
<li>따라서 f (수행시간 비율)을 낮춰야한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-27">예제 문제: 암달의 법칙 - 2</h3>
<ul>
<li>문제
<ul>
<li>어떤 프로세서 칩이 응용 프로그램을 위해 사용되고 있는데, <strong>이 프로그램의 수행 시간이 30%는 연산A에, 25%는 연산B에, 10%는 연산C에 소요</strong>한다.<br />
이 프로세서의 새로운 모델을 위해 설계팀은 세가지의 가능한 향상방식을 고안해 냈는데, 이 각각의 설계 노력과 제조에 거의 같은 비용이 든다.<br />
이들 향상방식 중에 어느 하나를 선택해야 하는가?</li>
<li>연산A를 2배 빠르게 설계한다.</li>
<li>연산B를 3배 빠르게 설계한다.</li>
<li>연산C를 10배 빠르게 설계한다.</li>
</ul>
</li>
<li>풀이
<ul>
<li>공식: 다수의 프로세서를 사용했을 때 얼마나 빨라지겠는가<br />
<img src="https://latex.codecogs.com/svg.image?SpeedUp=%5Cfrac%7BT(1-f)+Tf%7D%7BT(1-f)+%5Cfrac%7BTf%7D%7BN%7D%7D=%5Cfrac%7B1%7D%7B(1-f)+%5Cfrac%7Bf%7D%7BN%7D%7D" alt="SpeedUp=\frac{T(1-f)+Tf}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}" />
<ul>
<li>n배 빠르게 = N</li>
<li>수행 시간 % = f</li>
</ul>
</li>
<li>연산 A를 2배 빠르게 설계한다.
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B1%7D%7B0.7+%5Cfrac%7B0.3%7D%7B2%7D%7D=1.17" alt="\frac{1}{0.7+\frac{0.3}{2}}=1.17" /></li>
<li>즉, 1.17배 향상된다.</li>
</ul>
</li>
<li>연산 B를 3배 빠르게 설계한다.
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B1%7D%7B0.75+%5Cfrac%7B0.25%7D%7B3%7D%7D=1.2" alt="\frac{1}{0.75+\frac{0.25}{3}}=1.2" /></li>
<li>즉, 1.2배 향상된다.</li>
</ul>
</li>
<li>연산 C를 10배 빠르게 설계한다.
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B1%7D%7B0.9+%5Cfrac%7B0.1%7D%7B10%7D%7D=1.09" alt="\frac{1}{0.9+\frac{0.1}{10}}=1.09" /></li>
<li>즉, 1.09배 향상된다.</li>
</ul>
</li>
<li><strong>따라서, 연산B를 3배 빠르게 설계하는 것이 좋다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-28">벤치마크</h3>
<ul>
<li>기계 성능의 상대적 평가를 위해, 선택되거나 설계된 프로그램</li>
<li>특성
<ul>
<li>고급 언어로 작성되며, 서로 다른 기계들에서 호환성을 가져야 한다.</li>
<li>특정 종류의 유형에 대표적이어야 한다.</li>
<li>쉽게 측정되고 널리 보급될 수 있어야 한다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 최정열 교수님 (2021)</li>
    <li>William Stalling, 『컴퓨터시스템구조론(10판)』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET