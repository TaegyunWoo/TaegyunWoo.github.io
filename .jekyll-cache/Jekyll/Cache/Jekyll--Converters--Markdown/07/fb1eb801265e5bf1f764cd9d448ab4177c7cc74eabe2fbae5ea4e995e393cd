I"<p><br/><br/></p>
<blockquote>
<p><a href="https://github.com/TaegyunWoo/algorithm-study/blob/main/src/main/java/greedy/%EC%88%AB%EC%9E%90%EA%B0%80_1%EC%9D%B4_%EB%90%A0_%EB%95%8C%EA%B9%8C%EC%A7%80.java">소스코드</a></p>
</blockquote>
<br/>
<h1 id="greedy---1--">Greedy : 숫자가 1이 될 때까지</h1>
<h2 id="section">문제</h2>
<h3 id="section-1">문제 정의</h3>
<ul>
<li>어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.</li>
<li>단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.</li>
<li>과정
<ol>
<li>N에서 1을 뺀다.</li>
<li>N을 K로 나눈다.</li>
</ol>
</li>
<li>위 과정을 통해, N이 1이 되도록 하는 최소 수행 횟수를 구하라.</li>
<li>예시
<ul>
<li>N이 17이고, K가 4라고 가정하자.</li>
<li>이때 1번 과정을 한번 수행하면 N은 16이 된다.</li>
<li>이후에 2번 과정을 두 번 수행하면 N은 1이 된다.</li>
<li>결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다.</li>
<li>3은 N을 1로 만드는 최소 횟수이다. 이것이 정답이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-2">입력조건</h3>
<ul>
<li>첫째줄에 N, K의 자연수가 주어지며, 각 수는 공백으로 구분된다.
<ul>
<li>N: 2 이상, 100000 이하</li>
<li>K: 2 이상, 100000 이하</li>
</ul>
</li>
<li>항상 N은 K보다 크거나 같다.</li>
</ul>
<br/>
<h3 id="section-3">출력조건</h3>
<ul>
<li>첫째 줄에 N이 1이 될때까지 1번 혹은 2번 과정을 수행해야 하는 횟수의 최솟값을 출력한다.</li>
</ul>
<br/>
<h3 id="section-4">입·출력 예시</h3>
<ul>
<li>
<p>입력</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>25 5
</code></pre></div></div>
</li>
<li>
<p>출력</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
</code></pre></div></div>
</li>
</ul>
<br/>
<h2 id="section-5">풀이</h2>
<h3 id="section-6">문제 해설</h3>
<ul>
<li>1번 과정(<code>1로 빼기</code>)보다 2번 과정(<code>K로 나누기</code>)를 수행했을 때, N의 크기가 가장 많이 줄어든다.</li>
<li>따라서 총 2개의 과정 중, 2번 과정을 최우선 순위로 삼아 연산을 수행하면 된다.</li>
</ul>
<br/>
<h3 id="section-7">소스코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">숫자가_1이_될_때까지</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solution1</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="n">k</span><span class="o">;</span>
      <span class="k">else</span>
        <span class="n">n</span><span class="o">--;</span>
      <span class="n">answer</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<br/>
<h3 id="section-8">시간복잡도</h3>
<ul>
<li><code>solution1</code> 의 경우
<ul>
<li>정답 구하기
<ul>
<li>N이 K로 나누어 떨어진다면, N을 K로 나눈다.</li>
<li>나누어 떨어지지 않는다면, N에 1을 뺀다.</li>
<li>최악의 경우, K가 소수(1과 자기자신만 약수로 갖는 수)로 설정된다면, 1번 과정만 수행되어야 한다.<br />
즉, 반복문이 N번 만큼 수행된다.</li>
<li>따라서 정답을 구하는 시간복잡도는 <code>O(N)</code> 이다.</li>
</ul>
</li>
<li>따라서 총 시간복잡도는 <code>O(N)</code> 이다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>나동빈, 『이것이 코딩 테스트다』</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET