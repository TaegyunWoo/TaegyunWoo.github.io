I"#h<p><br/><br/></p>
<ul>
<li>이전 게시글
<ol>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_Begin">[JPA] 객체지향 쿼리 언어 - 소개</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Begin">[JPA] 객체지향 쿼리 언어 - JPQL 기초</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Join">[JPA] 객체지향 쿼리 언어 - JPQL 조인</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Expert">[JPA] 객체지향 쿼리 언어 - JPQL 심화</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_QueryDSL">[JPA] 객체지향 쿼리 언어 - QueryDSL</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_NativeQuery">[JPA] 객체지향 쿼리 언어 - 네이티브 쿼리</a></li>
</ol>
</li>
</ul>
<p><br/><br/></p>
<h1 id="section">객체지향 쿼리 심화</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">알아볼 내용</h3>
<p>이번 포스팅에서 알아볼 내용은 아래와 같다.</p>
<ul>
<li><strong>벌크 연산</strong>
<ul>
<li>한번에 여러 데이터를 수정할 수 있는 기능</li>
</ul>
</li>
<li><strong>JPQL과 영속성 컨텍스트 간의 관계</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="section-3">벌크 연산</h2>
<h3 id="section-4">배경</h3>
<ul>
<li>엔티티를 수정하려면, <strong>영속성 컨텍스트의 변경 감지 기능(Dirty Check)</strong> 이나 <strong>병합</strong> 을 사용해야 한다.</li>
<li>엔티티를 삭제하려면, <strong><code>EntityManager.remove()</code> 메서드</strong>를 사용해야 한다.</li>
<li><strong>하지만 이러한 방법으로 수백개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다.</strong>
<ul>
<li>바로 이때, <strong>벌크연산</strong>을 사용하면 된다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-5">예시 코드</h3>
<ul>
<li>
<p><strong>UPDATE 벌크연산: 재고가 10개 미만인 모든 상품의 가격을 10% 상승시키기</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//네이티브 쿼리</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
	<span class="s">"update Product p "</span> <span class="o">+</span>
	<span class="s">"set p.price = p.price * 1.1 "</span> <span class="o">+</span>
	<span class="s">"where p.stockAmount &lt; :stockAmount"</span><span class="o">;</span>

<span class="c1">//createNativeQuery()가 아닌, createQuery()를 사용한다. </span>
<span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"stockAmount"</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
		<span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span> <span class="c1">//벌크연산 실행</span>
</code></pre></div></div>
<ul>
<li><code>createQuery()</code>
<ul>
<li>해당 메서드에 ‘벌크 연산을 할 네이티브 SQL’을 전달한다.</li>
<li>단순히 네이티브 SQL 자체를 수행하려면, <code>createNativeQuery()</code> 를 사용함에 주의하자.</li>
</ul>
</li>
<li><code>executeUpdate()</code>
<ul>
<li>벌크연산을 실행한다.</li>
<li>이때, 벌크 연산의 영향을 받은 엔티티의 건수를 반환한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>DELETE 벌크연산: 가격이 100원 미만인 상품을 삭제하기</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//네이티브 쿼리</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
	<span class="s">"delete from Product p "</span> <span class="o">+</span>
	<span class="s">"where p.price &lt; :price"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
		<span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span> <span class="c1">//벌크연산 실행</span>
</code></pre></div></div>
<ul>
<li>Delete 쿼리도 <code>executeUpdate()</code> 메서드를 사용하여 벌크 연산을 수행한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>INSERT 벌크 연산: 하이버네이트 종속 기능</strong>
<ul>
<li>
<p>JPA 표준은 아니지만, 하이버네이트는 <code>INSERT</code> 벌크 연산도 지원한다.</p>
</li>
<li>
<p>100원 미만의 모든 상품을 선택해서 ProductTemp에 저장하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//네이티브 쿼리</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
	<span class="s">"insert into ProductTemp(id, name, price, stockAmount) "</span> <span class="o">+</span>
	<span class="s">"select p.id, p.name, p.price, p.stockAmount from Product p "</span> <span class="o">+</span>
	<span class="s">"where p.price &lt; :price"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
		<span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span> <span class="c1">//벌크연산 실행</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-6">벌크 연산 시 주의점</h3>
<ul>
<li>
<p><strong>벌크 연산은 영속성 컨텍스트를 무시하고, DB에 직접 쿼리한다.</strong></p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//----- JPQL -----</span>
<span class="c1">//상품A 조회 (상품A의 가격은 1000원이다.)</span>
<span class="nc">Product</span> <span class="n">productA</span> <span class="o">=</span>
	<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p from Product p where p.name = :name"</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"productA"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span> <span class="c1">//이때, productA는 영속상태이다.</span>

<span class="c1">//출력결과: 1000</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"productA 수정 전 = "</span> <span class="o">+</span> <span class="n">productA</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>

<span class="c1">//----- 벌크 연산 -----</span>
<span class="c1">//모든 상품 가격 10% 상승</span>
<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"update Product p set p.price = p.price * 1.1"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>

<span class="c1">//출력결과: 1000</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"productA 수정 후 = "</span> <span class="o">+</span> <span class="n">productA</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</code></pre></div></div>
<ol>
<li>가격이 1000원인 상품A를 조회했다. 조회된 상품A는 영속성 컨텍스트에서 관리된다.</li>
<li>벌크 연산으로 모든 상품의 가격을 10% 상승시켰다. 따라서 상품A의 가격은 1100원이 되어야 한다.</li>
<li><strong>벌크 연산을 수행한 후에 상품A의 가격을 출력하면 기대했던 1100원이 아닌, 1000원이 그대로 출력된다.</strong>
<ul>
<li>왜냐하면 벌크 연산 시, 영속성 컨텍스트를 고려하지 않고 DB에 직접하여 값을 수정했기 때문이다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>시각화
<ul>
<li>
<p>벌크 연산 직전 상태</p>
<p><img src="/assets/img/2021-12-03-JPA_ObjectQuery_Expert/Untitled%2015.png" alt="Untitled" /></p>
</li>
<li>
<p>벌크 연산 상태</p>
<p><img src="/assets/img/2021-12-03-JPA_ObjectQuery_Expert/Untitled%2016.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-7">벌크 연산 문제점 해결방법들</h3>
<ul>
<li>
<p><strong><code>em.refresh()</code> 사용</strong></p>
<ul>
<li>벌크 연산을 수행한 직후에 정확인 상품A 엔티티를 사용해야 한다면, <code>em.refresh()</code> 를 사용해서 DB에서 상품A를 다시 조회하면 된다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="n">productA</span><span class="o">);</span>
</code></pre></div></div>
</li>
<li>
<p><strong>벌크 연산 먼저 실행</strong></p>
<ul>
<li>벌크 연산을 가장 먼저 실행하여, 문제를 방지할 수 있다.</li>
<li>예시
<ul>
<li>벌크 연산으로 상품A의 가격을 변경한 뒤 상품A를 조회하면, 벌크 연산으로 이미 변경된 상품A를 조회하게 된다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>벌크 연산 수행 후 영속성 컨텍스트 초기화</strong></p>
<ul>
<li>벌크 연산을 수행한 직후에 바로 영속성 컨텍스트를 초기화해서, 영속성 컨텍스트에 남아 있는 엔티티를 제거하는 것도 좋은 방법이다.</li>
<li>영속성 컨텍스트를 초기화하면, 이후 엔티티를 조회할 때 벌크 연산이 적용된 DB에서 엔티티를 조회한다.</li>
</ul>
</li>
<li>
<p>정리</p>
<ul>
<li>가능하면 벌크 연산을 가장 먼저 수행하는 것이 좋고, 상황에 따라 영속성 컨텍스트를 초기화하자.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="jpql">영속성 컨텍스트와 JPQL</h2>
<h3 id="section-8">쿼리 후 영속 상태인 것과 아닌 것</h3>
<ul>
<li>JPQL로 엔티티를 조회하면 영속성 컨텍스트에서 관리된다.</li>
<li><strong>하지만 엔티티가 아니면 영속성 컨텍스트에서 관리되지 않는다.</strong></li>
</ul>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m //엔티티 조회 (관리O)
select o,address from Order o //임베디드타입 조회 (관리X)
select m.id, m.username from Member m //단순 필드 조회 (관리X)
</code></pre></div></div>
<blockquote>
<p>참고로 임베디드 타입을 프로젝션으로 지정하고 조회하여 반환된 객체의 값을 변경해도, flush 시 변경내용이 반영되지 않는다.<br />
임베디드 타입은 영속성 컨텍스트에서 관리되지 않아, Dirty Checking 되지 않기 때문이다.</p>
</blockquote>
<ul>
<li><strong>조회한 엔티티만 영속성 컨텍스트가 관리한다.</strong></li>
</ul>
<br/>
<h3 id="jpql----">JPQL로 조회한 엔티티와 영속성 컨텍스트</h3>
<ul>
<li>
<p>만약 영속성 컨텍스트에 회원1이 이미 있는데, JPQL로 회원1을 다시 조회하면 어떻게 될까?</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//회원1 조회</span>
<span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span> <span class="c1">//member1이 영속성 컨텍스트의 관리를 받음</span>

<span class="c1">//엔티티 쿼리 조회 결과가 회원1, 회원2이다.</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
		<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
</li>
</ul>
</br>
<ul>
<li><strong>‘JPQL로 DB에서 조회한 엔티티’가 영속성 컨텍스트에 이미 있으면</strong>
<ul>
<li>
<p><strong>‘JPQL로 DB에서 조회한 결과’를 버리고, 대신에 영속성 컨텍스트에 있던 엔티티를 반환한다.</strong></p>
</li>
<li>
<p>그리고 이때, ‘JPQL로 DB에서 조회한 결과의 식별자’와 ‘영속성 컨텍스트가 관리하는 엔티티의 식별자’를 비교하여 같은 엔티티임을 확인한다.</p>
</li>
<li>
<p>결과 시각화</p>
<ol>
<li>
<p>JPQL를 통한 조회 시도</p>
<p><img src="/assets/img/2021-12-03-JPA_ObjectQuery_Expert/Untitled%2017.png" alt="Untitled" /></p>
</li>
<li>
<p>JPQL를 통한 조회 결과</p>
<p><img src="/assets/img/2021-12-03-JPA_ObjectQuery_Expert/Untitled%2018.png" alt="Untitled" /></p>
</li>
</ol>
</li>
<li>
<p>흐름 순서</p>
<ol>
<li>JPQL을 사용해서 조회를 요청한다.</li>
<li>JPQL은 SQL로 변환되어 DB를 조회한다.</li>
<li>조회한 결과와 영속성 컨텍스트를 비교한다.</li>
<li><strong>식별자 값을 기준으로 <code>member1</code> 은 이미 영속성 컨텍스트에 있으므로, 조회된 결과를 버리고 기존에 있던 <code>member</code> 이 반환된다.</strong></li>
<li>식별자 값을 기준으로 <code>member2</code> 는 영속성 컨텍스트에 없으므로 영속성 컨텍스트에 추가한다.</li>
<li>쿼리 결과인 <code>member1</code> , <code>member2</code> 를 반환한다. 여기서 <code>member1</code> 은 쿼리 결과가 아닌 영속성 컨텍스트에 있던 엔티티다.</li>
</ol>
</li>
<li>
<p>이를 통해 알 수 있는 사실</p>
<ul>
<li><strong>JPQL로 조회한 엔티티는 영속 상태이다.</strong></li>
<li><strong>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<p>새로 조회한 결과를 버리고, 영속성 컨텍스트에 존재하는 기존의 엔티티를 반환하는 이유에 대해 알아보자.<br />
기존 엔티티를 반환하는 방식 말고, 어떻게 할 수 있을지 생각해보면 아래와 같다.</p>
<ul>
<li>새로운 엔티티를 영속성 컨텍스트에 하나 더 추가하는 방법
<ul>
<li>영속성 컨텍스트는 기본 키 값을 기준으로 엔티티를 관리한다. 따라서 같은 기본 키 값을 가진 엔티티는 등록할 수 없다.</li>
<li>따라서 사용할 수 없는 방법이다.</li>
</ul>
</li>
<li>기존 엔티티를 새로 검색한 엔티티로 대체하는 방법
<ul>
<li>영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있으므로 위험하다.</li>
<li>따라서 사용할 수 없는 방법이다.</li>
</ul>
</li>
</ul>
<p>위에서 설명한 방법들은 모두 불가능한 방법들이다. 따라서 JPA는 “기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버리는 방법”을 채택했다.</p>
<br/>
<h3 id="codefindcode-vs-codejpqlcode"><code>find()</code> vs <code>JPQL</code></h3>
<ul>
<li>
<p><code>em.find()</code> 메서드는 엔티티를 영속성 컨텍스트에서 먼저 찾고, 없으면 DB에서 찾는다.</p>
<ul>
<li>따라서 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다.</li>
</ul>
<blockquote>
<p>따라서 1차 캐시하고 부른다.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//최초 조회, DB에서 조회</span>
<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>

<span class="c1">//두번째 조회, 영속성 컨텍스트에 있으므로 DB 조회X</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>

<span class="c1">// member1 == member2 =&gt; true</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p>JPQL은 어떤 방식으로 동작할까?</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//첫번째 호출: DB에서 조회</span>
<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span>
	<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m where m.id = :id"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">)</span>
	<span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span>

<span class="c1">//두번째 호출: DB에서 조회</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span>
	<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m where m.id = :id"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">)</span>
	<span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span>

<span class="c1">// member1 = member2 =&gt; true!</span>
</code></pre></div></div>
<ul>
<li>첫번째 JPQL 호출
<ul>
<li>DB에서 회원 엔티티를 조회하고 영속성 컨텍스트에 등록한다.</li>
</ul>
</li>
<li>두번째 JPQL 호출
<ul>
<li>DB에서 같은 회원 엔티티를 조회하고, 결과를 버리고 기존 엔티티를 반환한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>상세 설명</p>
<ul>
<li><strong>JPQL은 항상 DB에 SQL을 실행해서 결과를 조회한다.</strong></li>
<li><code>em.find()</code> 메서드는 영속성 컨텍스트에서 엔티티를 먼저 찾고, 없으면 DB를 조회한다.</li>
<li>JPQL은 DB를 먼저 조회한다. 그리고 결과가 영속성 컨텍스트에 있으면 결과를 버리고 기존 엔티티를 반환한다.
<ul>
<li>그렇기 때문에, JPQL 역시 <code>member1 == member2</code> 가 true이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>정리</p>
<ul>
<li>JPQL은 항상 DB를 조회한다.</li>
<li>JPQL로 조회한 엔티티는 영속 상태이다.</li>
<li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면, 기존 엔티티를 반환한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="jpql--">JPQL과 플러시 모드</h2>
<h3 id="section-9">플러시란?</h3>
<ul>
<li>영속성 컨텍스트의 변경 내역을 DB에 동기화하는 것</li>
<li>플러시가 일어날 때, 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서 INSET, UPDATE, DELETE SQL을 만들어 DB에 반영한다.</li>
<li>커밋하기 직전이나, 쿼리 실행 직전에 자동으로 플러시가 호출된다.</li>
<li>플러시 옵션
<ul>
<li><code>em.setFlushMode(FlushModeType.AUTO);</code>
<ul>
<li>커밋 또는 쿼리 실행 시, 먼저 플러시</li>
<li>기본값</li>
</ul>
</li>
<li><code>em.setFlushMode(FlushModeType.COMMIT);</code>
<ul>
<li>커밋시에만 플러시</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">쿼리와 플러시 모드</h3>
<ul>
<li>
<p>JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 DB에 반영해야 한다.</p>
<ul>
<li>JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고, DB에 직접 접근하기 때문에</li>
</ul>
<p><img src="/assets/img/2021-12-03-JPA_ObjectQuery_Expert/Untitled%2019.png" alt="Untitled" /></p>
</li>
<li>
<p>다음 예제 코드를 보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//가격을 1000 -&gt; 2000원으로 변경</span>
<span class="n">product</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>

<span class="c1">//가격이 2000원인 상품 조회 (JPQL)</span>
<span class="nc">Product</span> <span class="n">product2</span> <span class="o">=</span>
	<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p from Product p where p.price = 2000"</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span>
</code></pre></div></div>
<ul>
<li><code>product.setPrice(2000)</code>
<ul>
<li>해당 메서드를 호출하면, 영속성 컨텍스트의 상품 엔티티는 가격이 1000원에서 2000원을 변경된다.</li>
<li>DB에서는 아직 1000원인 상태로 남아있다.</li>
</ul>
</li>
<li>JPQL 호출 시
<ul>
<li>가격이 2000원인 상품을 조회한다.</li>
<li>이때 플러시 모드를 따로 설정하지 않으면 플러시 모드가 <code>AUTO</code> 이다.</li>
<li><strong>따라서 쿼리 실행 직전에 영속성 컨텍스트가 플러시된다.</strong></li>
<li>결국 2000원으로 수정한 상품을 조회할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>위 예시에서 플러시 모드는 <code>COMMIT</code> 으로 설정하면, 쿼리시에는 플러시되지 않는다.</p>
<ul>
<li>따라서 2000원으로 수정한 상품을 조회할 수 없다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">플러시 모드와 최적화</h3>
<ul>
<li><code>FlushModeType.COMMIT</code> 모드는 트랜잭션을 커밋할 때만 플러시하고, 쿼리를 실행할 때는 플러시하지 않는다.
<ul>
<li>따라서 JPA 쿼리를 사용할 때, 영속성 컨텍스트에는 있지만 아직 DB에 반영하지 않은 데이터를 조회할 수 없다.</li>
</ul>
</li>
<li>그렇다면 <code>COMMIT</code> 플러시 모드는 왜 사용할까?
<ul>
<li>
<p><strong>아래와 같이 플러시가 너무 자주 일어나는 상황에 <code>COMMIT</code> 모드를 사용하면, 쿼리시 발생하는 플러시 횟수를 줄여서 성능을 최적화할 수 있다.</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//비즈니스 로직</span>
<span class="n">등록</span><span class="o">()</span>
<span class="n">쿼리</span><span class="o">()</span> <span class="c1">// 쿼리 전, 먼저 플러시한다.</span>
<span class="n">등록</span><span class="o">()</span>
<span class="n">쿼리</span><span class="o">()</span> <span class="c1">// 쿼리 전, 먼저 플러시한다.</span>
<span class="n">등록</span><span class="o">()</span>
<span class="n">쿼리</span><span class="o">()</span> <span class="c1">// 쿼리 전, 먼저 플러시한다.</span>
<span class="n">커밋</span><span class="o">()</span> <span class="c1">// 이때도 먼저 플러시한다.</span>

</code></pre></div></div>
<ul>
<li>위 상황에서 <code>FlushModeType.AUTO</code> 사용시: 쿼리와 커밋할 때, 총 4번 플러시한다.</li>
<li>위 상황에서 <code>FlushModeType.COMMIT</code> 사용시: 커밋할 때, 총 1번 플러시한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>또한 JPA를 사용하지 않고, JDBC를 직접 사용해서 SQL을 실행할 때도 플러시 모드를 고민해야 한다.</strong>
<ul>
<li>JDBC로 쿼리를 직접 실행하면 JPA는 JDBC가 실행한 쿼리를 인식할 방법이 없다.</li>
<li>따라서 별도의 JDBC 호출은 플러시 모드를 AUTO로 설정해도 플러시가 일어나지 않는다.</li>
<li><strong>이때는 JDBC로 쿼리를 실행하기 직전에, <code>em.flush()</code> 를 호출해서 영속성 컨텍스트의 내용을 DB에 동기화하는 것이 안전하다.</strong></li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET