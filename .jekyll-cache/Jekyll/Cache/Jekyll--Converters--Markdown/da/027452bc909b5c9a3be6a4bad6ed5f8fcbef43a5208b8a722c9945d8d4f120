I"<p><br/><br/></p>
<ul>
<li>이전 게시글
<ol>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_Begin">[JPA] 객체지향 쿼리 언어 - 소개</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Begin">[JPA] 객체지향 쿼리 언어 - JPQL 기초</a></li>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Join">[JPA] 객체지향 쿼리 언어 - JPQL 조인</a></li>
</ol>
</li>
</ul>
<p><br/><br/></p>
<h1 id="jpql-">JPQL 심화</h1>
<h2 id="section">경로 표현식</h2>
<h3 id="section-1">경로 표현식이란?</h3>
<ul>
<li>쉽게 말하자면, .(점)을 찍어 객체 그래프를 탐색하는 것을 말한다.
<ul>
<li>
<p>아래 JPQL 쿼리를 보자.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m.username
from Member m
join m.team t
join m.orders o
where t.name = '팀A'
</code></pre></div></div>
<ul>
<li><code>m.username</code> , <code>m.team</code> , <code>m.orders</code> , <code>t.name</code></li>
<li>위에 서술한 것들이 바로 경로 표현식을 사용한 것들이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-2">경로 표현식 용어 정리</h3>
<p>경로 표현식을 이해하기 위해, 필요한 용어들을 설명하겠다.</p>
<ul>
<li><strong>상태 필드</strong>
<ul>
<li>단순히 값을 저장하기 위한 필드</li>
<li>필드 or 프로퍼티</li>
</ul>
</li>
<li><strong>연관 필드</strong>
<ul>
<li>객체 사이의 연관관계를 맺기 위해 사용하는 필드</li>
<li>임베디드 타입 포함</li>
<li>필드 or 프로퍼티</li>
<li>연관 필드의 종류
<ul>
<li><strong>단일 값 연관 필드</strong>
<ul>
<li><code>@ManyToOne</code></li>
<li><code>@OneToOne</code></li>
<li>대상이 엔티티이다.</li>
</ul>
</li>
<li><strong>컬렉션 값 연관 필드</strong>
<ul>
<li><code>@OneToMany</code></li>
<li><code>@ManyToMany</code></li>
<li>대상이 컬렉션이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>예제 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
<pre><code>&lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//상태 필드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//상태 필드&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;team&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//연관 필드 (단일값 연관 필드)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@OneToMany&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//연관 필드 (컬렉션 값 연관 필드)&lt;/span&gt;
</code></pre>
<p><span class="o">}</span>
</code></pre></div></div></p>
<ul>
<li>상태 필드: <code>m.username</code> , <code>m.age</code></li>
<li>단일 값 연관 필드: <code>m.team</code></li>
<li>컬렉션 값 연관 필드: <code>m.orders</code></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">경로 표현식과 특징</h3>
<p>경로 표현식의 경로 탐색 범위는 아래와 같다.</p>
<ul>
<li><strong>상태 필드 경로</strong>
<ul>
<li>경로 탐색의 끝</li>
<li>더는 탐색할 수 없다.</li>
</ul>
</li>
<li><strong>단일 값 연관 경로</strong>
<ul>
<li>
<p>묵시적으로 내부 조인이 일어난다.</p>
<blockquote>
<p>묵시적 내부 조인에 대해선 본 포스팅에서 자세히 다룬다.</p>
</blockquote>
</li>
<li>
<p>계속 탐색할 수 있다.</p>
</li>
</ul>
</li>
<li><strong>컬렉션 값 연관 경로</strong>
<ul>
<li>묵시적으로 내부 조인이 일어난다.</li>
<li>더는 탐색할 수 없다.</li>
<li>단 FROM 절에서 조인을 통해 별칭을 얻으면, 별칭으로 탐색할 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<p>예시를 통해 각각 알아보자.</p>
<ul>
<li><strong>상태 필드 경로 탐색</strong>
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m.username, m.age from Member m
</code></pre></div></div>
<ul>
<li>상태 필드 경로 탐색: <code>m.username</code> , <code>m.age</code></li>
</ul>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>단일 값 연관 경로 탐색 - 1</strong>
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select o.member from Order o
</code></pre></div></div>
<ul>
<li>단일 값 연관 경로 탐색: <code>m.member</code></li>
</ul>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">Orders</span> <span class="n">o</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">MEMBER</span> <span class="n">m</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">MEMBER_ID</span><span class="o">=</span><span class="n">m</span><span class="p">.</span><span class="n">ID</span>
</code></pre></div></div>
<ul>
<li><strong>단일 값 연관 필드로 경로 탐색을 하면, SQL에서 내부 조인이 일어난다. 이것을 ‘묵시적 조인’이라고 한다.</strong></li>
<li><strong>묵시적 조인은 모두 내부 조인이다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>단일 값 연관 경로 탐색 - 2</strong>
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select o.member.team from Order o
where o.product.name = 'productA'
and o.address.city = 'Incheon'
</code></pre></div></div>
<ul>
<li>단일 값 연관 경로 탐색: <code>o.member.team</code> , <code>o.product.name</code> , <code>o.address.city</code></li>
</ul>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">Orders</span> <span class="n">o</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">MEMBER</span> <span class="n">m</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">MEMBER_ID</span><span class="o">=</span><span class="n">m</span><span class="p">.</span><span class="n">ID</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">TEAM</span> <span class="n">t</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">TEAM_ID</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">ID</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">PRODUCT</span> <span class="n">p</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">PRODUCT_ID</span><span class="o">=</span><span class="n">P</span><span class="p">.</span><span class="n">ID</span>
<span class="k">WHERE</span> <span class="n">p</span><span class="p">.</span><span class="n">NAME</span><span class="o">=</span><span class="s1">'productA'</span> <span class="k">AND</span> <span class="n">o</span><span class="p">.</span><span class="n">CITY</span><span class="o">=</span><span class="s1">'Incheon'</span>
</code></pre></div></div>
<ul>
<li><code>o.address.city</code> 처럼 임베디드 타입에 접근하는 것 역시 단일 값 연관 경로 탐색이다.</li>
<li><strong>하지만 <code>city</code> 가 하나의 테이블(<code>Order</code>)에 존재하므로 조인할 필요가 없다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>컬렉션 값 연관 경로 탐색</strong>
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select t.members from Team t //성공
select t.members.username from Team t //불가능
</code></pre></div></div>
<ul>
<li>컬렉션 값 연관 경로 탐색: <code>t.members</code></li>
<li><code>select t.members.username from Team t</code>
<ul>
<li>members의 각 member의 name이 리스트로 반환되지 않을까?</li>
<li><strong>불가능하다!</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>상세 설명</p>
<ul>
<li>
<p><code>t.members</code> 처럼 컬렉션까지는 경로 탐색이 가능하다.</p>
</li>
<li>
<p><code>**t.members.username</code> 처럼 컬렉션에서 경로 탐색을 시작하는 것은 허락하지 않는다.**</p>
</li>
<li>
<p><strong>만약 컬렉션에서 경로 탐색을 하고 싶으면, 아래 코드처럼 조인을 사용해서 새로운 별칭을 획득해야 한다.</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//별칭 m을 획득하여 경로를 탐색할 수 있다.
//이 경우, m.username은 상태 필드 경로 탐색이다.
select m.username from Team t join t.members m
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>참고: <code>size</code> 라는 것을 통해, 컬렉션의 크기를 구할 수 있다.<br />
예시: <code>select t.members.size from Team t</code></p>
</blockquote>
<br/>
<h3 id="section-4">경로 탐색을 사용한 묵시적 조인 시 주의사항</h3>
<ul>
<li><strong>묵시적 조인은 항상 내부 조인이다.</strong></li>
<li>컬렉션은 경로 탐색의 끝이다.
<ul>
<li>컬렉션에서 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 한다.</li>
</ul>
</li>
<li>경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만, 묵시적 조인으로 인해 SQL의 FROM절에 영향을 준다.</li>
</ul>
<br/>
<ul>
<li><strong>묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어렵다.</strong></li>
<li><strong>따라서 성능이 중요하면 분석하기 쉽도록 명시적 조인을 사용하자.</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="section-5">서브 쿼리</h2>
<h3 id="jpql--">JPQL 서브쿼리 제약</h3>
<p>JPQL도 SQL처럼 서브 쿼리를 지원한다. 단 몇 가지 제약이 있다.</p>
<ul>
<li>서브쿼리를 WHERE, HAVING 절에서만 사용할 수 있다.</li>
<li>서브쿼리를 SELECT, FROM 절에서는 사용할 수 없다.</li>
</ul>
<br/>
<h3 id="jpql---">JPQL 서브쿼리 사용 예시</h3>
<ul>
<li>
<p>나이가 평균보다 많은 회원 찾기</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where m.age &gt; (select AVG(m2.age) from Member m2)
</code></pre></div></div>
</li>
<li>
<p>한 건이라도 주문한 고객 찾기</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where 0 <span class="err">&lt;</span> (select COUNT(o) from Order o where o.member=m)
</code></pre></div></div>
<blockquote>
<p>예시 도메인 모델은 <a href="https://taegyunwoo.github.io/jpa/JPA_ObjectQuery_JPQL_Begin#3">이전 게시글을 참고</a>하자.</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="section-6">서브 쿼리 함수</h3>
<ul>
<li><code>EXISTS</code> 함수
<ul>
<li>
<p>문법</p>
<ul>
<li><code>[NOT] EXISTS (서브쿼리)</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>서브쿼리에 결과가 존재하면 참이다.</li>
<li>NOT은 반대이다.</li>
</ul>
</li>
<li>
<p>예시 : 팀A 소속인 회원 조회</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where EXISTS (select t from m.team where t.name='팀A')
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>{ALL | ANY | SOME}</code> 함수
<ul>
<li>
<p>문법</p>
<ul>
<li><code>{ALL | ANY | SOME} (서브쿼리)</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>비교 연산자와 같이 사용한다.
<ul>
<li>ALL : 조건을 모든 서브쿼리 결과 레코드가 만족하면 참이다.</li>
<li>ANY or SOME : 둘다 같은 의미다. 조건을 하나의 결과 레코드가 만족하면 참이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>예시 : 전체 상품 각각의 재고보다 주문량이 많은 주문들</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select o from Order o
where o.orderAmount &gt; ALL (select p.stockAmount from Product p)
</code></pre></div></div>
</li>
<li>
<p>예시 : 어떤 팀이든 팀에 소속된 회원</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where m.team = ANY (select t from Team t)
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>IN</code> 함수
<ul>
<li>
<p>문법</p>
<ul>
<li><code>[NOT] IN (서브쿼리)</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>서브쿼리의 결과 중 하나라도 같은 것이 있으면 참이다.</li>
<li>참고로 <code>IN</code>은 서브쿼리가 아닌 곳에서도 사용한다.</li>
</ul>
</li>
<li>
<p>예시 : 20세 이상을 보유한 팀</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select t from Team t
where t IN (select t2 from Team t2 join t2.members m2 where m2.age &gt;= 20)
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h2 id="section-7">조건식</h2>
<h3 id="section-8">타입 표현</h3>
<p>JPQL에서 사용하는 타입은 아래와 같다. (대소문자는 구분하지 않는다.)</p>
<table>
<thead>
<tr>
<th>종류</th>
<th>설명</th>
<th>예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>문자</td>
<td>- 작은 따옴표 사이에 표현 <br/> - 작은 따옴표를 표현하고 싶으면 작은 따옴표 연속 두 개(’’) 사용</td>
<td>‘HELLO’ <br/> ‘It’‘s’</td>
</tr>
<tr>
<td>숫자</td>
<td>- L (Long 타입 지정) <br/> - D (Double 타입 지정) <br/> - F (Float 타입 지정)</td>
<td>10L <br/> 10D  <br/>10F</td>
</tr>
<tr>
<td>날짜</td>
<td>- DATE {d ‘yyyy-mm-dd’} <br/> - TIME {t ‘hh-mm-ss’} <br/> - DATETIME {ts ‘yyyy-mm-dd hh:mm:ss.f’}</td>
<td>{d ‘2021-11-29’} <br/> {t ‘10-11-11’} <br/> {ts ‘2021-11-29 10-11-11.123’} <br/> m.createDate = {d ‘2012-03-24’}</td>
</tr>
<tr>
<td>Boolean</td>
<td>TRUE <br/> FALSE</td>
<td></td>
</tr>
<tr>
<td>Enum</td>
<td>패키지명을 포함한 전체 이름을 사용해야 한다.</td>
<td>jpabook.MemberType.Admin</td>
</tr>
<tr>
<td>엔티티타입</td>
<td>엔티티의 타입을 표현한다. <br/> 주로 상속과 관련해서 사용한다.</td>
<td>TYPE(m)=Member</td>
</tr>
</tbody>
</table>
<br/>
<h3 id="section-9">연산자 우선 순위</h3>
<p>연산자 우선 순위는 아래와 같다.</p>
<ol>
<li>경로 탐색 연산
<ul>
<li>. (점)</li>
</ul>
</li>
<li>수학 연산
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>-(단항 연산자)</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>/</li>
</ul>
</li>
<li>비교 연산
<ul>
<li>=</li>
<li>&gt;</li>
<li>&gt;=</li>
<li>&lt;</li>
<li>&lt;=</li>
<li>&lt;&gt;(다름)</li>
<li>[NOT] BETWEEN</li>
<li>[NOT] LIKE</li>
<li>[NOT] IN</li>
<li>IS [NOT] NULL</li>
<li>IS [NOT] EMPTY</li>
<li>[NOT] MEMBER [OF]</li>
<li>[NOT] EXISTS</li>
</ul>
</li>
<li>논리 연산
<ul>
<li>NOT</li>
<li>AND</li>
<li>OR</li>
</ul>
</li>
</ol>
<br/>
<h3 id="section-10">논리 연산과 비교식</h3>
<ul>
<li>논리 연산
<ul>
<li>AND : 둘다 만족하면 참</li>
<li>OR : 둘 중 하나만 만족해도 참</li>
<li>NOT : 조건식의 결과 반대</li>
</ul>
</li>
<li>비교식
<ul>
<li>=</li>
<li>&gt;</li>
<li>&gt;=</li>
<li>&lt;</li>
<li>&lt;=</li>
<li>&lt;&gt;</li>
</ul>
</li>
</ul>
<br/>
<h3 id="between-in-like-null-">Between, IN, Like, NULL 비교</h3>
<ul>
<li><strong>Between 식</strong>
<ul>
<li>
<p>문법</p>
<ul>
<li><code>X [NOT] BETWEEN A AND B</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>X는 A~B 사이의 값이면 참이다.</li>
<li>A와 B를 포함한다.</li>
</ul>
</li>
<li>
<p>예시 : 나이가 10~20인 회원 찾기</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where m.age BETWEEN 10 AND 20
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>IN 식</strong>
<ul>
<li>
<p>문법</p>
<ul>
<li><code>X [NOT] IN (예제)</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>X와 같은 값이 예제에 하나라도 있으면 참이다.</li>
<li>예제에는 서브쿼리를 사용할수도 있다.</li>
</ul>
</li>
<li>
<p>예시 : 이름이 회원1이거나 회원2인 회원 찾기</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where m.username IN ('회원1', '회원2')
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>LIKE 식</strong>
<ul>
<li>
<p>문법</p>
<ul>
<li><code>문자표현식 [NOT] LIKE 패턴값 [ESCAPE 이스케이프문자]</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>문자표현식과 패턴값을 비교한다.</li>
<li><code>%</code> : 아무 값들이입력되어도 된다. (값이 없어도 됨)</li>
<li><code>_</code> : 한 글자는 아무 값이 입력되어도 된다. (값이 반드시 있어야 함)</li>
</ul>
</li>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//중간에 원이라는 단어가 들어간 회원
select m from Member m
where m.username LIKE '%원%'
<p>//처음에 회원이라는 단어가 들어간 회원
select m from Member m
where m.username LIKE ‘회원%’</p>
<p>//마지막에 회원이라는 단어가 들어간 회원
select m from Member m
where m.username LIKE ‘%회원’</p>
<p>//회원A, 회원1
select m from Member m
where m.username LIKE ‘회원_’</p>
<p>//회원3
select m from Member m
where m.username LIKE ‘__3’</p>
<p>//회원%
select m from Member m
where m.username LIKE ‘원%’ ESCAPE ’'
</code></pre></div></div></p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>NULL 비교식</strong>
<ul>
<li>
<p>문법</p>
<ul>
<li><code>{단일값 경로 | 입력 파라미터} IS [NOT] NULL</code></li>
</ul>
</li>
<li>
<p>설명</p>
<ul>
<li>NULL인지 비교한다.</li>
<li>NULL은 <code>=</code> 으로 비교하면 안되고, 반드 <code>IS NULL</code> 을 사용해야 한다.</li>
</ul>
</li>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select m from Member m
where m.username IS NULL
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>컬렉션 식</strong>
<ul>
<li>
<p>컬렉션 식이란?</p>
<ul>
<li>컬렉션에만 사용하는 특별한 기능이다.</li>
<li>컬렉션은 컬렉션 식 이외에 다른 식은 사용할 수 없다.</li>
</ul>
</li>
<li>
<p><strong>빈 컬렉션 비교식: 문법</strong></p>
<ul>
<li><code>{컬렉션 값 연관 경로} IS [NOT] EMPTY</code></li>
</ul>
</li>
<li>
<p><strong>빈 컬렉션 비교식: 설명</strong></p>
<ul>
<li>컬렉션에 값이 비었으면 참이다.</li>
</ul>
</li>
<li>
<p><strong>빈 컬렉션 비교식: 예시</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//JPQL: 주문이 하나라도 있는 회원 조회
select m from Member m
where m.orders IS EMPTY
<p>//실행된 SQL
SELECT m.* from MEMBER m
WHERE EXISTS (
SELECT o.ID FROM ORDERS o WHERE m.ID=o.MEMBER_ID
)</p>
<p>//오류가 발생하는 JPQL
select m from Member m
where m.orders IS NULL
</code></pre></div></div></p>
</li>
<li>
<p><strong>컬렉션의 멤버식: 문법</strong></p>
<ul>
<li><code>{엔티티or값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로}</code></li>
</ul>
</li>
<li>
<p><strong>컬렉션의 멤버식: 설명</strong></p>
<ul>
<li>엔티티나 값이 컬렉션에 포함되어 있으면 참이다.</li>
</ul>
</li>
<li>
<p><strong>컬렉션의 멤버식: 예시</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//JPQL: 주문이 하나라도 있는 회원 조회
select t from Team t
where :memberParam MEMBER OF t.members
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">스칼라 식</h3>
<p>스칼라는 숫자, 문자, 날짜, case, 엔티티 타입 같은 가장 기본적인 타입들을 말한다.</p>
<ul>
<li>수학 식
<ul>
<li>+, - : 단항 연산자</li>
<li>*, /, +, - : 사칙연산</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>문자 함수</li>
</ul>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
<th>예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(문자1, 문자2, …)</td>
<td>문자를 합한다.</td>
<td>CONCAT(‘A’, ‘B’) = AB</td>
</tr>
<tr>
<td>SUBSTRING(문자, 위치, [길이])</td>
<td>- 위치부터 시작해 길이만큼 문자를 구한다. <br/> - 길이 값이 없으면 나머지 전체 길이를 뜻한다.</td>
<td>SUBSTRING(‘ABCDEF’, 2, 3) = BCD</td>
</tr>
<tr>
<td>TRIM([[LEADING</td>
<td>TRAILING</td>
<td>BOTH] [트림문자] FROM] 문자)</td>
</tr>
<tr>
<td>LOWER(문자)</td>
<td>소문자로 변경</td>
<td>LOWER(‘ABC’)=‘abc’</td>
</tr>
<tr>
<td>UPPER(문자)</td>
<td>대문자로 변경</td>
<td>UPPER(‘abc’)=‘ABC’</td>
</tr>
<tr>
<td>LENGTH(문자)</td>
<td>문자 길이</td>
<td>LENGTH(‘ABC’)=3</td>
</tr>
<tr>
<td>LOCATE(찾을 문자, 원본 문자, [검색시작위치])</td>
<td>- 검색위치부터 문자를 검색한다. <br/> - 1부터 시작, 못찾으면 0 반환</td>
<td>LOCATE(‘DE’, ‘ABCDEFG’)=4</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li>수학 함수</li>
</ul>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
<th>예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS(수학식)</td>
<td>절대값을 구한다.</td>
<td>ABS(-10)=10</td>
</tr>
<tr>
<td>SQRT(수학식)</td>
<td>제곱근을 구한다.</td>
<td>SQRT(4)=2.0</td>
</tr>
<tr>
<td>MOD(수학식, 나눌수)</td>
<td>나머지를 구한다.</td>
<td>MOD(4, 3)=1</td>
</tr>
<tr>
<td>SIZE(컬렉션 값 연관 경로식)</td>
<td>컬렉션의 크기를 구한다.</td>
<td>SIZE(t.members)</td>
</tr>
<tr>
<td>INDEX(별칭)</td>
<td>- LIST 타입 컬렉션의 위치값을 구한다. <br/> - 단 컬렉션이 @OrderColumn을 사용하는 LIST 타입일 때만 사용할 수 있다.</td>
<td>t.members m where INDEX(m) &gt; 3</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li>날짜 함수
<ul>
<li>
<p><code>CURRENT_DATE</code> : 현재 날짜</p>
</li>
<li>
<p><code>CURRENT_TIME</code> : 현재 시간</p>
</li>
<li>
<p><code>CURRENT_TIMESTAMP</code> : 현재 날짜 시간</p>
</li>
<li>
<p>예시 : 종료 이벤트 조회</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select e from Event e where e.endDate <span class="nt">&lt; CURRENT_DATE</span>
</code></pre></div></div>
</li>
<li>
<p>하이버네이트는 날짜 타입에서 년, 월, 일, 시간, 분, 초 값을 구하는 기능을 지원한다.</p>
<ul>
<li>
<p><code>YEAR</code> , <code>MONTH</code> , <code>DAY</code> , <code>HOUR</code> , <code>MINUTE</code> , <code>SECOND</code></p>
</li>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select year(CURRENT_TIMESTAMP), match(CURRENT_TIMESTAMP),
	day(CURRENT_TIMESTAMP)
from Member
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="case-">CASE 식</h3>
<ul>
<li>CASE 식이란?
<ul>
<li>특정 조건에 따라 분기할 때 사용한다.</li>
</ul>
</li>
<li>CASE 식의 종류
<ul>
<li><strong>기본 CASE</strong></li>
<li><strong>심플 CASE</strong></li>
<li><strong>COALESCE</strong></li>
<li><strong>NULLIF</strong></li>
</ul>
</li>
</ul>
<p>하나씩 순서대로 알아보자.</p>
<br/>
<ul>
<li><strong>기본 CASE</strong>
<ul>
<li>
<p>문법</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE
	{WHEN {조건식} THEN {스칼라식}}+
	ELSE {스칼라식}
END
</code></pre></div></div>
</li>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select case
	when m.age <span class="err">&lt;</span>= 10 then '학생요금'
	when m.age &gt;= 60 then '경로요금'
	else '일반요금'
end from Member m
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>심플 CASE</strong>
<ul>
<li>
<p>문법</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE {조건대상}
	{WHEN {스칼라식1} THEN {스칼라식2}}+
	ELSE [스칼라식]
END
</code></pre></div></div>
</li>
<li>
<p>설명</p>
<ul>
<li>자바의 switch 문과 유사하다.</li>
</ul>
</li>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select case t.name
	when '팀A' then '인센티브110%'
	when '팀B' then '인센티브120%'
	else '인센티브105%'
end from Team t
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>COALESCE</strong>
<ul>
<li>
<p>문법</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COALESCE({스칼라식} {, {스칼라식}}+)
</code></pre></div></div>
</li>
<li>
<p>설명</p>
<ul>
<li>스칼라식을 차례대로 조회해서 NULL이 아니면 반환한다.</li>
</ul>
</li>
<li>
<p>예시 : m.username 이 null이면 ‘이름없는 회원’을 반환하라</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select coalesce(m.username, '이름없는 회원') from Member m
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>NULLIF</strong>
<ul>
<li>
<p>문법</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NULLIF({스칼라식}, {스칼라식})
</code></pre></div></div>
</li>
<li>
<p>설명</p>
<ul>
<li>두 값이 같으면 NULL을 반환한다.</li>
<li>두 값이 다르면 첫 번째 값을 반환한다.</li>
</ul>
</li>
<li>
<p>예시 : 사용자 이름이 ‘관리자’면 NULL을 반환하고 나머지는 본인의 이름을 반환하라</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select nullif(m.username, '관리자') from Member m
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-12">다형성 쿼리</h2>
<h3 id="section-13">다형성 쿼리란?</h3>
<ul>
<li>
<p>JPQL로 부모 엔티티를 조회했을 때, 그 자식 엔티티도 함께 조회한다는 것이다. 아래 예시를 보자.</p>
</li>
<li>
<p>예시</p>
<ul>
<li><code>Item</code> 의 자식으로 <code>Book</code> , <code>Album</code> , <code>Movie</code> 가 존재한다고 하자.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
	<span class="c1">//...</span>
<span class="o">}</span>
<p><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">“B”</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>
<span class="c1">//…</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
<span class="o">}</span></p>
<p><span class="c1">//Album, Movie 생략</span>
</code></pre></div></div></p>
<ul>
<li>
<p>이때 아래와 같이 조회하면 <code>Item</code>의 자식도 함께 조회된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select i from Item i"</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
</li>
<li>
<p>결과 SQL: 단일테이블 전략</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ITEM</span>
</code></pre></div></div>
<ul>
<li>단일 테이블이기 때문에 ITEM에서만 조회해도 자식까지 조회된다.</li>
</ul>
</li>
<li>
<p>결과 SQL: 조인 전략</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">i</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">ITEM</span> <span class="n">i</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">BOOK</span> <span class="n">b</span> <span class="k">ON</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">ITEM_ID</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">ALBUM</span> <span class="n">a</span> <span class="k">ON</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">ITEM_ID</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">MOVIE</span> <span class="n">m</span> <span class="k">ON</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">ITEM_ID</span>
</code></pre></div></div>
<ul>
<li>외부 조인을 통해, 자식까지 모두 조회한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="type">TYPE</h3>
<ul>
<li>TYPE이란, 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용하는 것이다.</li>
<li>예시 : Item 중에 Book, Movie를 조회하라.
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select i from Item i
where i.DTYPE in ('B', 'M')
</code></pre></div></div>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">i</span> <span class="k">FROM</span> <span class="n">Item</span> <span class="n">i</span>
<span class="k">WHERE</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'B'</span><span class="p">,</span> <span class="s1">'M'</span><span class="p">)</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="treat">TREAT</h3>
<ul>
<li>TREAT란?
<ul>
<li>JPA 2.1에 추가된 기능이다.</li>
<li>자바의 타입 캐스팅과 비슷하다.</li>
<li>상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용한다.</li>
<li>JPA 표준: FROM, WHERE 절에서만 사용할 수 있다.</li>
<li>Hibernate: SELECT 절에서도 사용할 수 있다.</li>
</ul>
</li>
<li>예시
<ul>
<li>
<p>JPQL 쿼리</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select i from Item i
where treat(i as Book).author = 'kim'
</code></pre></div></div>
<ul>
<li>treat를 통해 Item을 자식 타입인 Book으로 다룬다. 따라서 <code>author</code> 필드에 접근할 수 있다.</li>
</ul>
</li>
<li>
<p>결과 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">i</span> <span class="k">FROM</span> <span class="n">Item</span> <span class="n">i</span>
<span class="k">WHERE</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span><span class="o">=</span><span class="s1">'B'</span> <span class="k">AND</span> <span class="n">i</span><span class="p">.</span><span class="n">AUTHOR</span><span class="o">=</span><span class="s1">'kim'</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-14">사용자 정의 함수 호출</h2>
<h3 id="section-15">문법</h3>
<p><code>function_invocation::= FUNCTION(function_name {, function_arg}*)</code></p>
<ul>
<li>
<p>예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select function('group_concat', i.name) from Item i
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="section-16">조건</h3>
<ul>
<li>하이버네이트 구현체를 사용하면, 아래와 같이 방언 클래스를 상속해서 구현하고 사용할 DB 함수를 미리 등록해야 한다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyH2Dialect</span> <span class="kd">extends</span> <span class="nc">H2Dialect</span> <span class="o">{</span>
<pre><code>&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyH2Dialect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;registerFunction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group_concat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StandardSQLFunction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;group_concat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StandardBasicTypes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STRING&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
</code></pre>
<p><span class="o">}</span>
</code></pre></div></div></p>
<ul>
<li>그리고 하애와 같이 <code>hibernate.dialect</code> 에 해당 방언을 등록해야 한다.
<ul>
<li>
<p><code>persistence.xml</code></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.dialect"</span> <span class="na">value=</span><span class="s">"hello.MyH2Dialect"</span><span class="nt">/&gt;</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-17">기타 정리</h2>
<h3 id="section-18">기타</h3>
<ul>
<li><code>enum</code> 은 <code>=</code> 비교 연산만 지원한다.</li>
<li>임베디드 타입은 비교를 지원하지 않는다.</li>
</ul>
<br/>
<h3 id="empty-string">EMPTY STRING</h3>
<ul>
<li>JPA 표준은 ’’을 길이 0인 Empty String으로 정했다.</li>
<li>하지만 DB에 따라 ’’을 NULL로 사용하는 경우도 있다.</li>
<li>따라서 Empty String을 사용하기 전에 미리 확인해야한다.</li>
</ul>
<br/>
<h3 id="null-">NULL 정의</h3>
<ul>
<li>조건을 만족하는 데이터가 하나도 없으면 NULL이다.</li>
<li>NULL은 알 수 없는 값이다. NULL과의 모든 수학적 계산 결과는 NULL이다.</li>
<li><code>NULL == NULL</code> 은 알 수 없는 값이다.</li>
<li><code>NULL is NULL</code> 은 참이다.</li>
</ul>
<br/>
<ul>
<li><strong>AND 연산과 NULL</strong></li>
</ul>
<table>
<thead>
<tr>
<th>AND</th>
<th>TRUE</th>
<th>FALSE</th>
<th>NULL</th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>TRUE</td>
<td>FALSE</td>
<td>NULL</td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>FALSE</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li><strong>OR 연산과 NULL</strong></li>
</ul>
<table>
<thead>
<tr>
<th>OR</th>
<th>TRUE</th>
<th>FALSE</th>
<th>NULL</th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr>
<td>FALSE</td>
<td>TRUE</td>
<td>FALSE</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>TRUE</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li><strong>NOT 연산과 NULL</strong></li>
</ul>
<table>
<thead>
<tr>
<th>NOT</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p><br/><br/></p>
<h2 id="section-19">엔티티 직접 사용</h2>
<h3 id="section-20">기본키 값</h3>
<ul>
<li>
<p>객체 인스턴스는 참조 값으로 식별하고, 테이블 로우(레코드)는 기본키 값으로 식별한다.</p>
</li>
<li>
<p><strong>따라서 JPQL에서 엔티티 객체를 직접 사용하면, SQL에서는 해당 엔티티의 기본키 값을 사용한다.</strong></p>
<ul>
<li>
<p>JPQL에서의 엔티티 객체 직접 사용 예시</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select count(m) from Member m //엔티티 직접 사용
select count(m.id) from Member m //엔티티의 아이디 사용
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><strong>엔티티를 직접 사용하면 JPQL이 SQL로 변환될 때, 해당 엔티티의 기본키를 사용한다. 따라서 실제 실행된 SQL은 둘 다 같다.</strong></p>
<ul>
<li>
<p>SQL 결과</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cnt</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>파라미터: 엔티티 직접 사용 vs 엔티티 기본키 사용
<ul>
<li>
<p><strong>엔티티를 파라미터로 직접 받는 코드</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sqlString</span> <span class="o">=</span> <span class="s">"select m from Member m where m = :member"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"member"</span><span class="o">,</span> <span class="n">member</span><span class="o">)</span>
		<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<ul>
<li>
<p>SQL 결과</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
<span class="k">WHERE</span> <span class="n">m</span><span class="p">.</span><span class="n">ID</span><span class="o">=?</span>
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><strong>기본키를 파라미터로 받는 코드</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sqlString</span> <span class="o">=</span> <span class="s">"select m from Member m where m.id = :memberId"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"memberId"</span><span class="o">,</span> <span class="mi">4L</span><span class="o">)</span>
		<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<ul>
<li>
<p>SQL 결과</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
<span class="k">WHERE</span> <span class="n">m</span><span class="p">.</span><span class="n">ID</span><span class="o">=?</span>
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><strong>‘엔티티를 직접 파라미터에 전달하는 것’이나 ‘기본키를 파라미터에 전달하는 것’이나 결과는 동일하다.</strong></p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-21">외래키 값</h3>
<ul>
<li>
<p><strong>외래키 대신에 엔티티를 직접 사용하는 코드</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<p><span class="nc">String</span> <span class="n">sqlString</span> <span class="o">=</span> <span class="s">“select m from Member m where m.team = :team”</span><span class="o">;</span></p>
<p><span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">“team”</span><span class="o">,</span> <span class="n">team</span><span class="o">)</span>
<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div></p>
<ul>
<li>
<p>SQL 결과</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
<span class="k">WHERE</span> <span class="n">m</span><span class="p">.</span><span class="n">TEAM_ID</span><span class="o">=?</span>
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><strong>외래키를 사용하는 코드</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<p><span class="nc">String</span> <span class="n">sqlString</span> <span class="o">=</span> <span class="s">“select m from Member m where m.team.id = :team”</span><span class="o">;</span></p>
<p><span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">“team”</span><span class="o">,</span> <span class="n">team</span><span class="o">)</span>
<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div></p>
<ul>
<li>
<p>SQL 결과</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">m</span>
<span class="k">WHERE</span> <span class="n">m</span><span class="p">.</span><span class="n">TEAM_ID</span><span class="o">=?</span>
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><strong>이것 역시 결과가 동일하다.</strong></p>
</li>
<li>
<p><strong>묵시적 조인이 일어나지 않는 이유</strong></p>
<ul>
<li><code>m.team.id</code> 를 보면, 묵시적 조인이 일어나야 할 것 같다.</li>
<li><strong>하지만 <code>Team</code>의 id값은 <code>Member</code> 테이블에 존재하므로 (외래키) 묵시적 조인이 일어나지 않는다.</strong></li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="named---">Named 쿼리: 정적 쿼리</h2>
<h3 id="jpql---1">JPQL 쿼리 종류</h3>
<ul>
<li><strong>동적 쿼리</strong>
<ul>
<li>JPQL을 문자로 완성해서 직접 넘기는 것</li>
<li>예시) <code>select m from Member m</code></li>
</ul>
</li>
<li><strong>정적 쿼리</strong>
<ul>
<li>미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용할 수 있는 기능</li>
<li>이것을 <strong>Named 쿼리</strong>라고 한다.</li>
<li>Named 쿼리는 한번 정의하면 변경할 수 없다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-22">정적 쿼리의 특징</h3>
<ul>
<li>Named 쿼리는 <strong>애플리케이션 로딩 시점에 JPQL 문법을 체크</strong>하고 파싱해둔다.
<ul>
<li>따라서 오류를 빨리 확인할 수 있다.</li>
<li>또한 성능상 이점도 있다.</li>
<li>데이터베이스의 조회 성능 최적화</li>
</ul>
</li>
</ul>
<br/>
<h3 id="named-----">Named 쿼리 작성 방법: 애너테이션에 정의하기</h3>
<ul>
<li>
<p>Named 쿼리 작성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
	<span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
	<span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username = :username"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@NamedQuery</code> 애너테이션을 통해, Named 쿼리를 작성한다.
<ul>
<li><code>name</code> 속성: 쿼리 이름 부여</li>
<li><code>query</code> 속성: 사용할 쿼리 작성</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Named 쿼리 사용</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
		<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">)</span>
		<span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<ul>
<li><code>em.createNamedQuery(&quot;Named쿼리 이름&quot;, 반환타입)</code></li>
</ul>
<blockquote>
<p>Named 쿼리 이름 형식: <code>엔티티명.쿼리제목</code> 으로 설정해야 관리도 쉽고, 충돌을 방지할 수 있다.</p>
</blockquote>
</li>
<li>
<p>여러 Named 쿼리 정의 시, <code>@NamedQueries</code> 애너테이션을 사용하면 된다.</p>
</li>
</ul>
<br/>
<h3 id="named----xml-">Named 쿼리 작성 방법: XML에 정의하기</h3>
<ul>
<li>
<p>Named 쿼리를 작성할 때는 XML에 정의하는 것이 편리하다.</p>
</li>
<li>
<p>Named 쿼리 작성: <code>META-INF/ormMember.xml</code></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;entity-mappings</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/persistence/orm"</span> <span class="na">version=</span><span class="s">"2.1"</span><span class="nt">&gt;</span>
<pre><code>&lt;span class=&quot;nt&quot;&gt;&amp;lt;named-query&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Member.findByUsername&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;query&amp;gt;&amp;lt;CDATA&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;m&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;m&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;m.username =&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;:username&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/query&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/named-query&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;named-query&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Member.count&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;query&amp;gt;&lt;/span&gt;select count(m) from Member m&lt;span class=&quot;nt&quot;&gt;&amp;lt;/query&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/named-query&amp;gt;&lt;/span&gt;
</code></pre>
<p><span class="nt">&lt;/entity-mappings&gt;</span>
</code></pre></div></div></p>
<ul>
<li><code>&lt;CDATA[]&gt;</code> 를 사용하면 대괄호 사이에 있는 문자을 그대로 출력한다. 그러므로 xml의 예약문자(<code>&gt;</code> , <code>&lt;</code> 등)을 쿼리에서 사용할 수 있다.</li>
</ul>
</li>
<li>
<p>그리고 <code>ormMember.xml</code> 파일을 인식하도록 <code>META-INF/persistence.xml</code>에 아래 코드를 추가해야 한다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;persistence-unit</span> <span class="na">name=</span><span class="s">"jpabook"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;mapping-file&gt;</span>META-INF/ormMember.xml<span class="nt">&lt;/mapping-file&gt;</span>
...
</code></pre></div></div>
<blockquote>
<p>META-INF/orm.xml 은 JPA가 기본 매핑파일로 인식해서 별도의 설정을 하지 않아도 된다.</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="section-23">환경에 따른 설정</h3>
<ul>
<li>만약 xml과 애너테이션에 같은 설정이 있으면, <strong>xml을 우선으로 적용</strong>한다.
<ul>
<li>만약 같은 이름의 Named 쿼리가 xml과 애너테이션에 모두 정의되어 있다면, xml에 정의된 것이 사용된다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET