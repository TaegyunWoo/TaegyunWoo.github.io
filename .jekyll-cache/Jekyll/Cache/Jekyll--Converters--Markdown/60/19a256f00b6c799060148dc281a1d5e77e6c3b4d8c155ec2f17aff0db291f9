I"Y5<p><br/><br/></p>
<h1 id="section">조합 알고리즘</h1>
<h2 id="section-1">개요</h2>
<ul>
<li>조합 알고리즘에 대해 알아보기 전에, 먼저 조합에 대해 알아보자.</li>
</ul>
<br/>
<h3 id="section-2">조합이란?</h3>
<ul>
<li>n개의 숫자 중, r개의 숫자를 순서없이 뽑는 것</li>
</ul>
<br/>
<h3 id="section-3">공식</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?_nC_r=_%7Bn-1%7DC_%7Br-1%7D+_%7Bn-1%7DC_r" alt="공식" /></li>
<li>‘하나의 원소를 선택할 경우’ + ‘하나의 원소를 선택하지 않을 경우’의 합이다.</li>
<li><strong>즉, n개 중 r개를 뽑는 경우의 수는 ‘하나의 원소를 선택하고 나머지를 뽑는 경우’와 ‘하나의 원소를 제외하고 뽑는 경우’로 이루어진다.</strong></li>
</ul>
<blockquote>
<p>자세한 것은 아래 예시를 통해 설명한다.</p>
</blockquote>
<br/>
<h2 id="section-4">예시</h2>
<h3 id="section-5">주어진 배열</h3>
<ul>
<li><code>{1, 2, 3}</code></li>
</ul>
<h3 id="r">뽑는 개수 (r)</h3>
<ul>
<li>2개</li>
</ul>
<h3 id="section-6">가능한 조합</h3>
<ul>
<li><code>{1, 2}</code> , <code>{1, 3}</code>, <code>{2, 3}</code></li>
</ul>
<h3 id="section-7">공식 적용</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?_3C_2=_2C_1+_2C_2" alt="공식" /></li>
</ul>
<br/>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?_2C_1" alt="공식" /> 인 이유?
<ul>
<li>3개 중 하나는 뽑아두고(<code>n-1</code>), 남은 횟수(<code>r-1</code>)만큼 마저 뽑는다.</li>
<li>예시
<ul>
<li>1을 뽑아둔다. → 남은 원소 = 3-1 = 2 = n-1</li>
<li>남은 횟수만큼 뽑는다. → 남은 횟수 = 2-1 = 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?_2C_2" alt="공식" /> 인 이유?
<ul>
<li>3개 중 하나를 제외하고(<code>n-1</code>), 뽑는다.</li>
<li>예시
<ul>
<li>1을 제외한다. → 남은 원소 = 3-1 = 2 = n-1</li>
<li>뽑는다. → 2 = r</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>따라서 해당 공식을 <img src="https://latex.codecogs.com/svg.image?_kC_0=1" alt="공식" /> 이 나올때까지 반복하면, <img src="https://latex.codecogs.com/svg.image?_nC_r" alt="공식" /> 을 구할 수 있다.</li>
</ul>
<p><br/><br/></p>
<h1 id="section-8">조합 알고리즘</h1>
<h2 id="section-9">조합의 경우의 수 구하기</h2>
<ul>
<li>조합의 실제 경우를 구하는 것이 아닌, 단순히 <strong>경우의 수</strong> 만 구하는 알고리즘에 대해 먼저 알아보자.</li>
</ul>
<br/>
<h3 id="section-10">코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">조합_경우의_수</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCombinationCaseNum</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>

    <span class="cm">/*
     * n == r 이라면, 모두 뽑는 경우 하나만 존재한다.
     * r == 0 이라면, 모두 뽑지 않는 경우 경우 하나만 존재한다.
     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">r</span> <span class="o">||</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="nf">getCombinationCaseNum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">getCombinationCaseNum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>코드가 상당히 단순하다.</li>
<li>단순히 총 경우의 개수만 구한다면, 공식을 코드화하면 된다.</li>
</ul>
<br/>
<h2 id="section-11">실제 조합 구하기</h2>
<ul>
<li>이번에는 실제 조합을 구해보자.</li>
<li>배열의 처음부터 마지막까지 돌며 아래 케이스를 모두 고려해야 한다.
<ol>
<li>현재 인덱스의 원소를 선택하는 경우 (<img src="https://latex.codecogs.com/svg.image?_%7Bn-1%7DC_%7Br-1%7D" alt="공식" />)</li>
<li>현재 인덱스의 원소를 선택하지 않는 경우 (<img src="https://latex.codecogs.com/svg.image?_%7Bn-1%7DC_r" alt="공식" />)</li>
</ol>
</li>
<li>재귀를 통한 완전탐색 방식으로 실제 조합을 구할 수 있다.
<ul>
<li>백트래킹 등의 방식도 있지만, 생략한다.</li>
</ul>
</li>
<li>코드를 통해 설명하겠다.</li>
</ul>
<br/>
<h3 id="section-12">코드</h3>
<blockquote>
<p>코드는 한번 훑어본 뒤, 아래 설명을 참고하자. 그리고 다시 코드를 보자.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">조합_구하기</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getCombination</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numAry</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//뽑아야하는 만큼 뽑았으므로, 출력 후 종료</span>
      <span class="n">print</span><span class="o">(</span><span class="n">numAry</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//모든 원소를 둘러보았으므로, 종료</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">visited</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//현재 원소를 뽑았을 때</span>
    <span class="n">getCombination</span><span class="o">(</span><span class="n">numAry</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// n-1Cr-1</span>

    <span class="n">visited</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//현재 원소를 뽑지 않았을 때</span>
    <span class="n">getCombination</span><span class="o">(</span><span class="n">numAry</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span> <span class="c1">// n-1Cr</span>
  <span class="o">}</span>

  <span class="c1">//뽑은 원소를 출력하는 메서드</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numAry</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"{"</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">visited</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">numAry</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"}\n"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>변수 <code>depth</code>
<ul>
<li>현재 인덱스를 가르킨다.</li>
<li>순열이 아닌 조합이기 때문에, 이전에 살펴본 원소는 더이상 고려대상이 아니다.<br />
따라서 변수 <code>depth</code> 는 무조건 1씩 증가한다.
<ul>
<li>즉 이전에 뽑을지 말지 판단했던 원소는 다음 뽑기에서 제외된다. (뽑지 않더라도)</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>배열 <code>boolean[] visited</code>
<ul>
<li><code>visited[i]</code> = i번째 원소를 뽑을지, 말지에 대한 정보</li>
<li>현재 인덱스(<code>depth</code>)에 위치한 원소를 뽑는다면 → <code>visited[depth] = true</code></li>
<li>현재 인덱스(<code>depth</code>)에 위치한 원소를 뽑지 않는다면 → <code>visited[depth] = false</code></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>매개변수 <code>n</code>
<ul>
<li>조합 공식에선 <code>n-1</code>을 사용한다. 하지만 위 코드에선 매개변수 <code>n</code>은 변화하지 않는다.</li>
<li>왜냐하면, 변수 <code>depth</code> 가 1씩 증가하므로, <code>n</code> 이 1씩 감소될 필요가 없기 때문이다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>재귀 종료 조건
<ul>
<li><code>depth == n</code>
<ul>
<li>모든 원소를 살펴보았으므로 종료한다.</li>
<li>단 <code>depth == n</code> 이더라도, 뽑아야하는 횟수만큼 뽑았다는 보장이 없기 때문에 뽑은 원소를 출력하지는 않는다.</li>
</ul>
</li>
<li><code>r == 0</code>
<ul>
<li>뽑아야하는 횟수만큼 뽑았으므로 종료한다.</li>
<li>뽑아야하는 횟수만큼 뽑았기 때문에, 뽑은 원소를 출력한다.
<ul>
<li>이때 <code>visited</code> 배열에서 <code>true</code>인 index가 ‘뽑은 원소의 index’이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">재귀의 흐름</h3>
<ol>
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled0.png" alt="" /></p>
<ol start="2">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled1.png" alt="" /></p>
<ol start="3">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled2.png" alt="" /></p>
<ol start="4">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled3.png" alt="" /></p>
<ol start="5">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled4.png" alt="" /></p>
<ol start="6">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled5.png" alt="" /></p>
<ol start="7">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled6.png" alt="" /></p>
<ol start="8">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled7.png" alt="" /></p>
<ol start="9">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled8.png" alt="" /></p>
<ol start="10">
<li></li>
</ol>
<p><img src="/assets/img/2022-02-20-ALGORITHM_Combination/Untitled9.png" alt="" /></p>
<blockquote>
<p>이하 생략…</p>
</blockquote>
:ET