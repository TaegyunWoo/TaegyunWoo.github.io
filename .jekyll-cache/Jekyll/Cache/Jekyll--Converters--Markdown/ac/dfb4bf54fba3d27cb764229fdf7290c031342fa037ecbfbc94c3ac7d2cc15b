I"N<p><br/><br/></p>
<h1 id="section">연결리스트</h1>
<h2 id="section-1">연결리스트 - 큐</h2>
<h3 id="section-2">구성요소</h3>
<p><img src="/assets/img/2021-07-09-DATASTRUCTURE_LinkedList_Queue/Untitled_49.png" alt="연결리스트 큐 구성요소" /></p>
<br>
<h3 id="section-3">노드 구조</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Element</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">//저장할 데이터의 타입 정의</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LinkedNode</span> <span class="p">{</span>
	<span class="n">Element</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//저장할 데이터</span>
	<span class="k">struct</span> <span class="n">LinkedNode</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span> <span class="c1">//다음 노드의 주소</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//front가 가르킬 노드의 주소</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//rear가 가르킬 노드의 주소</span>
</code></pre></div></div>
<br>
<h3 id="section-4">공백상태</h3>
<ul>
<li>front == rear == NULL</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">top</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">rear</span><span class="o">==</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="section-5">포화상태</h3>
<ul>
<li>계속해서 추가할 수 있으므로 의미가 없다.</li>
</ul>
<br>
<h3 id="section-6">큐 초기화</h3>
<ul>
<li>front == NULL</li>
<li>rear == NULL</li>
</ul>
<br>
<h3 id="enqueue-">enqueue 연산</h3>
<ul>
<li>
<p><strong>큐가 비어있는 상태에서의 enqueue</strong> 와<br />
<strong>큐가 비어있지 않는 상태에서의 enqueue</strong> 의<br />
작동 방식이 다르다.</p>
</li>
<li>
<p>&lt;큐가 비어있는 상태에서 enqueue할 때&gt;</p>
<ul>
<li>front와 rear 모두 새로운 노드를 가르킨다.</li>
</ul>
<p><img src="/assets/img/2021-07-09-DATASTRUCTURE_LinkedList_Queue/Untitled_50.png" alt="큐가 비어있는 상태에서 enqueue" /></p>
</li>
</ul>
<br>
<ul>
<li>
<p>&lt;큐가 비어있지 않은 상태에서 enqueue할 때&gt;</p>
<ol>
<li><strong>‘새로운 노드의 link’</strong> 는 ‘rear가 가르키는 노드’의 주소값을 가르킨다.</li>
<li><strong>‘rear가 가리키는 노드의 link’</strong> 는 새로운 노드의 주소값을 가르킨다.</li>
</ol>
<p><img src="/assets/img/2021-07-09-DATASTRUCTURE_LinkedList_Queue/Untitled_51.png" alt="큐가 비어있는 상태에서 enqueue" /></p>
</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">Element</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="c1">//빈 큐일때</span>
		<span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">//비어있지 않은 큐일때</span>
		<span class="n">rear</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span> <span class="c1">//(1)</span>
		<span class="n">rear</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span> <span class="c1">//(2)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
<p>가장 먼저, 추가할 데이터를 가지는 노드 객체를 생성해야함 (동적 할당으로)</p>
</blockquote>
<blockquote>
<p>가장 마지막에 있는 노드의 link는 NULL</p>
</blockquote>
<br>
<h3 id="dequeue-">dequeue 연산</h3>
<ol>
<li>공백검사</li>
<li><strong>‘새로운 포인터 변수’</strong> 가 ‘삭제할 노드’를 가르킴 (front의 값 가져옴)
be) return할 노드 기억</li>
<li><strong>‘front’</strong> 가 ‘front가 가르키는 노드’를 가리키도록 함</li>
<li>만약 하나 남은 노드를 제거했을 때, rear도 NULL로 설정함
be) 공백상태 만들기</li>
<li><strong>‘기억해둔 노드’</strong> 의 data를 저장</li>
<li><strong>‘기억해둔 노드’</strong> 를 메모리에서 해제</li>
<li><strong>‘기억해둔 data’</strong> 를 반환</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Element</span> <span class="nf">pop</span><span class="p">(</span><span class="n">Element</span> <span class="n">inputData</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//return할 노드의 주소값을 담을 포인터변수</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">returnNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="c1">//반환할 데이터</span>
	<span class="n">Element</span> <span class="n">returnData</span>

	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"스택 공백 에러"</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//기존에 front가 가르키던 노드 주소값 저장</span>
	<span class="n">returnNode</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>

	<span class="c1">//front가 가르킬 '다음 노드'의 주소값</span>
	<span class="n">front</span> <span class="o">=</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="c1">//return 노드의 data 저장</span>
	<span class="n">Element</span> <span class="n">returnData</span> <span class="o">=</span> <span class="n">returnNode</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="c1">//삭제할 노드를 메모리에서 해제</span>
	<span class="n">free</span><span class="p">(</span><span class="n">returnNode</span><span class="p">);</span>

	<span class="c1">//pop한 노드의 데이터 반환</span>
	<span class="k">return</span> <span class="n">returnData</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="peek-">peek 연산</h3>
<ol>
<li>공백상태 검사</li>
<li>front가 가르키는 노드의 data멤버 반환</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Element</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//공백검사</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="err">'공백오류'</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="destroyqueue-">destroy_queue 연산</h3>
<ul>
<li>
<p>큐 사용이 끝났다면, 큐를 메모리에서 해제해야함</p>
</li>
<li>
<p>공백상태가 아닐 때까지 dequeue 반복</p>
</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">destroy_stack</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">is_empty</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dequeue</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="size-">size 연산</h3>
<ul>
<li>모든 노드들을 따라가면서 연결된 횟수 검사</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="c1">//마지막 노드의 link값이 NULL이므로, NULL까지 찾는다.</span>
	<span class="k">for</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">front</span><span class="p">;</span> <span class="n">node</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="section-7">종합예시</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">Element</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LinkedNode</span> <span class="p">{</span>
	<span class="n">Element</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">LinkedNode</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">front</span><span class="p">;</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">rear</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init_queue</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">front</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">rear</span><span class="o">==</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">Element</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
	<span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">newNode</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">front</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
		<span class="n">rear</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rear</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
		<span class="n">rear</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">Element</span> <span class="n">returnData</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"공백상태 에러"</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">node</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
	<span class="n">returnData</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">front</span> <span class="o">=</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">front</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">returnData</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">front</span><span class="p">;</span> <span class="n">node</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"큐 공백에러"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">init_queue</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enqueue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">dequeue</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">dequeue</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">dequeue</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">dequeue</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 박미옥 교수님 (2021)</li>
    <li>최영규, 『두근두근 자료구조』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET