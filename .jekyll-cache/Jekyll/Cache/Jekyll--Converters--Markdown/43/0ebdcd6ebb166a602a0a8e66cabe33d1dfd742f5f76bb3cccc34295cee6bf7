I"K<p><br/><br/></p>
<h1 id="section">컴포넌트 스캔과 의존관계 자동 주입</h1>
<ul>
<li>
<p>기존에는 <code>@Bean</code> 애너테이션이나 XML의 <bean> 태그를 통해서 스프링 빈 객체를 등록하였다.</p>
</li>
<li>
<p>이러한 방식은 빈의 개수가 증가하면 번거롭다.</p>
</li>
<li>
<p>따라서, 스프링이 제공하는 기능인 <strong>컴포넌트 스캔</strong> 을 사용하여 좀더 편리하게 빈을 등록할 수 있다.</p>
</li>
<li>
<p>또한, 의존관계도 자동으로 주입하는 <code>@Autowired</code> 라는 기능도 제공한다.</p>
</li>
</ul>
<p><br><br></p>
<h2 id="section-1">애너테이션 정리</h2>
<ul>
<li><code>@ComponentScan</code>
<ul>
<li><code>@Component</code> 가 붙은 클래스를 빈 객체로 등록한다.</li>
</ul>
</li>
<li><code>@Component</code>
<ul>
<li>해당 클래스를 스프링 빈으로 등록할 수 있도록 유도한다.</li>
</ul>
</li>
<li><code>@Autowired</code>
<ul>
<li>해당 생성자의 매개변수에 자동으로 의존관계를 주입한다(DI).</li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-2">컴포넌트 스캔 적용 코드</h2>
<h3 id="codeappconfigcode">컴포넌트 스캔이 적용된 <code>AppConfig</code></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.FilterType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ComponentScan</span><span class="o">.*;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span>
        <span class="n">excludeFilters</span> <span class="o">=</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">ANNOTATION</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">Configuration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="o">)</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutoAppConfig</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p><code>@ComponentScan</code> 애너테이션을 설정 정보 ( <code>AutoAppConfig</code> )에 붙여주면 된다.</p>
</li>
<li>
<p>컴포넌트 스캔은 <code>@Component</code> <strong>애너테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록</strong> 한다.</p>
</li>
</ul>
<blockquote>
<p><code>excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class)</code> 해당 옵션은 이전 게시글에서 작성한 예제 코드 ( <code>AppConfig</code> )를 남기기 위해 추가한 옵션이다.</p>
</blockquote>
<br>
<h3 id="codememorymemberrepositorycode-">컴포넌트로 지정한 <code>MemoryMemberRepository</code> 클래스</h3>
<blockquote>
<p>기존의 <code>MemoryMemberRepository</code> 클래스의 코드는 <a href="https://taegyunwoo.github.io/spring/SPRING_OCP_DIP">이전 게시글</a> 참고.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemoryMemberRepository</span> <span class="kd">implements</span> <span class="nc">MemberRepository</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@Component</code> 애너테이션을 사용하여, <code>@ComponentScan</code> 애너테이션이 붙은 설정 정보 ( <code>AutoAppConfig</code> )가 <code>MemoryMemberRepository</code> 를 스캔하여 빈으로 등록할 수 있도록 한다.</li>
</ul>
<br>
<h3 id="coderatediscountpolicycode-">컴포넌트로 지정한 <code>RateDiscountPolicy</code> 클래스</h3>
<blockquote>
<p><code>RateDiscountPolicy</code> 클래스는 할인정책 관련 구체 클래스이다. <code>DiscountPolicy</code> 인터페이스를 구체화한 것이다.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RateDiscountPolicy</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@Component</code> 애너테이션을 사용하여, <code>@ComponentScan</code> 애너테이션이 붙은 설정 정보 ( <code>AutoAppConfig</code> )가 <code>MemoryMemberRepository</code> 를 스캔하여 빈으로 등록할 수 있도록 한다.</li>
</ul>
<br>
<h3 id="codememberserviceimplcode-">의존관계가 자동으로 주입되는 <code>MemberServiceImpl</code> 클래스</h3>
<blockquote>
<p>기존의 <code>MemberServiceImpl</code> 클래스의 코드는 <a href="https://taegyunwoo.github.io/spring/SPRING_OCP_DIP">이전 게시글</a> 참고.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberServiceImpl</span> <span class="kd">implements</span> <span class="nc">MemberService</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>

	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@Autowired</code> 애너테이션을 통해 의존관계를 자동으로 주입해준다.</li>
</ul>
<br>
<h3 id="codeorderserviceimplcode-">의존관계가 자동으로 주입되는 <code>OrderServiceImpl</code> 클래스</h3>
<blockquote>
<p>기존의 <code>OrderServiceImpl</code> 클래스의 코드는 <a href="https://taegyunwoo.github.io/spring/SPRING_Configuration">이전 게시글</a> 참고.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceImpl</span> <span class="kd">implements</span> <span class="nc">OrderService</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kd">final</span> <span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">;</span>

	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="nf">OrderServiceImpl</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">discountPolicy</span> <span class="o">=</span> <span class="n">discountPolicy</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@Autowired</code> 애너테이션을 통해 의존관계를 자동으로 주입해준다.</li>
<li>여러 의존관계 역시 한번에 주입받을 수 있다.</li>
</ul>
<br>
<h3 id="section-3">테스트 코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">hello.core.AutoAppConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.member.MemberService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutoAppConfigTest</span> <span class="o">{</span>

	<span class="nd">@Test</span>
	<span class="kt">void</span> <span class="nf">basicScan</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">ApplicationContext</span> <span class="n">ac</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AutoAppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>MemberService</code> 의 구체 객체가 정상적으로 빈으로 생성된 것을 확인할 수 있다.</li>
</ul>
<p><br><br></p>
<h2 id="section-4">상세 동작 원리</h2>
<h3 id="codecomponentscancode"><code>@ComponentScan</code></h3>
<p><img src="/assets/img/2021-07-25-SPRING_ComponentScan/Untitled%2013.png" alt="@ComponentScan 동작 원리" /></p>
<ul>
<li><code>@ComponentScan</code> 은 <code>@Component</code> 가 붙은 모든 클래스를 스프링 빈으로 등록한다.</li>
<li>이때 스프링 빈의 기본 이름은 클래스명을 사용하되, <strong>맨 앞글자만 소문자를 사용</strong> 하여 빈을 등록한다.
<ul>
<li>Ex) MemberServiceImpl 클래스 ⇒ memberServiceImpl</li>
</ul>
</li>
<li>빈 이름을 직접 설정하고 싶다면, <code>@Component(&quot;원하는빈이름&quot;)</code> 을 사용하면 된다.</li>
</ul>
<br>
<h3 id="codeautowiredcode---"><code>@Autowired</code> 의존관계 자동 주입</h3>
<p><img src="/assets/img/2021-07-25-SPRING_ComponentScan/Untitled%2014.png" alt="@Autowired" /></p>
<ul>
<li>생성자에 <code>@Autowired</code> 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.</li>
<li>기본적인 조회 전략은 <strong>타입이 같은 빈을 찾아서 주입하는 것</strong> 이다.
<ul>
<li>즉, 위 그림에서 빈 객체 <code>memoryMemberRepository</code> 의 타입이 <code>MemoryMemberRepository</code> 이자, <code>MemberRepository</code> 이므로 해당 빈이 주입되게 된다.</li>
</ul>
</li>
<li>여러 파라미터가 있더라도 다 찾아서 자동으로 주입한다.</li>
</ul>
<p><br><br><br></p>
<h1 id="section-5">탐색 위치와 기본 스캔 대상</h1>
<h2 id="section-6">탐색할 패키지의 시작 위치 지정</h2>
<ul>
<li>스프링 컨테이너가 모든 자바 클래스를 대상으로 컴포넌트 스캔을 수행하면 시간이 오래 걸리게 된다.</li>
<li>따라서, 꼭 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다.</li>
</ul>
<br>
<h3 id="section-7">탐색 시작 위치 지정 설정</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ComponentScan</span><span class="o">(</span>
	<span class="n">basePackages</span> <span class="o">=</span> <span class="o">{</span><span class="s">"원하는 패키지명1"</span><span class="o">,</span> <span class="s">"원하는 패키지명2"</span><span class="o">,</span> <span class="o">..</span> <span class="o">,</span> <span class="s">"원하는 패키지명n"</span><span class="o">},</span>
<span class="o">)</span>
</code></pre></div></div>
<ul>
<li><code>basePackages</code>
<ul>
<li>탐색할 패키지의 시작 위치를 지정한다.</li>
<li>해당 패키지를 포함한 모든 하위 패키지를 탐색한다.</li>
</ul>
</li>
<li><code>basePackageClasses</code>
<ul>
<li>해당 속성은 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.</li>
</ul>
</li>
<li>만약 시작 위치를 지정하지 않으면, <code>@ComponentScan</code> 이 붙은 설정 정보 클래스의 패키지가 시작 위치로 설정된다.</li>
</ul>
<br>
<h3 id="section-8">탐색 시작 위치를 설정하는 좋은 방법</h3>
<ul>
<li>탐색 시작 패키지를 따로 지정하기보단, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 방법을 권장한다.</li>
</ul>
<p><br><br></p>
<h2 id="section-9">컴포넌트 스캔 기본 대상</h2>
<ul>
<li><code>@ComponentScan</code> 은 <code>@Component</code> 뿐만 아니라 아래의 내용도 추가로 대상에 포함한다.
<ul>
<li><code>@Component</code> : 컴포넌트 스캔에서 사용</li>
<li><code>@Controller</code> : 스프링 MVC 컨트롤러에서 사용</li>
<li><code>@Service</code> : 스프링 비즈니스 로직에서 사용</li>
<li><code>@Repository</code> : 스프링 데이터 접근 계층에서 사용</li>
<li><code>@Configuration</code> : 스프링 설정 정보에서 사용</li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-10">애너테이션들의 부가 기능</h2>
<ul>
<li><code>@Controller</code> : 스프링 MVC 컨트롤러로 인식</li>
<li><code>@Service</code> : 아무런 처리를 하지는 않는다. 단지, 개발자들에게 핵심 비즈니스 로직이 여기 있다는 것을 명시해준다.</li>
<li><code>@Repository</code> : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.</li>
<li><code>@Configuration</code> : 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.</li>
</ul>
<p><br><br><br></p>
<h1 id="section-11">중복 등록과 충돌</h1>
<h2 id="section-12">컴포넌트 스캔에서 발생할 수 있는 상황</h2>
<p>컴포넌트 스캔시 같은 빈 이름을 등록했을 때, 발생할 수 있는 상황은 아래와 같다.</p>
<ul>
<li>자동 빈 등록 vs 자동 빈 등록</li>
<li>수동 빈 등록 vs 자동 빈 등록</li>
</ul>
<p><br><br></p>
<h2 id="vs---">자동 빈 등록 vs 자동 빈 등록</h2>
<p>컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, <strong>그 이름이 같은 경우 스프링은 오류를 발생</strong> 시킨다.</p>
<p><br><br></p>
<h2 id="vs----1">수동 빈 등록 vs 자동 빈 등록</h2>
<h3 id="section-13">예시 코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//빈 객체로 등록할 클래스</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemoryMemberRepository</span> <span class="kd">implements</span> <span class="nc">MemberRepository</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p>해당 클래스에 <code>@Component</code> 가 붙어있으므로, <code>@ComponentScan</code> 에 의해 자동으로 빈 등록이 된다.</p>
</li>
<li>
<p>즉, 자동 빈 등록이다.</p>
</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//설정 정보 클래스</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutoAppConfig</span> <span class="o">{</span>

	<span class="c1">//빈 수동 등록	</span>
	<span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"memoryMemberRepository"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p><code>AutoAppConfig</code> 클래스 내부에 <code>@Bean</code> 애너테이션을 사용하여 memberRepository 빈 객체를 수동으로 등록한다.</p>
</li>
<li>
<p>즉, 수동 빈 등록이다.</p>
</li>
</ul>
<br>
<h3 id="section-14">중복 결과</h3>
<p>이 경우 <strong>수동 빈 등록이 우선권</strong> 을 가진다. 즉, <strong>수동 빈이 자동 빈을 오버라이딩</strong> 해버린다.</p>
<blockquote>
<p>이러한 결과를 의도적으로 설계했다면 괜찮지만, 그것이 아니라면 이러한 문제 (빈 객체가 오버라이딩 되는 문제)를 디버깅하기란 쉽지 않다.</p>
</blockquote>
<br>
<hr />
<br>
<p><a href="https://inf.run/pcN8"><img src="/assets/img/Inflearn_Spring_SpringCore/Logo.png" width="400px" height="250px"></a></p>
<ul>
<li><em>본 게시글은 김영한님의 강의를 토대로 정리한 글입니다.</em></li>
<li><em>더 자세한 내용을 알고 싶으신 분들이 계신다면, 해당 강의를 수강하시는 것을 추천드립니다.</em></li>
</ul>
:ET