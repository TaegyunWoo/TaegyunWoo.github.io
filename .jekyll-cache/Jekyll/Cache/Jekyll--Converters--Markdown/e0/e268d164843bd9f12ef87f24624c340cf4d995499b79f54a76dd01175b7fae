I"z.<p><br/><br/></p>
<h1 id="websocket">WebSocket</h1>
<h2 id="section">개요</h2>
<h3 id="websocket-">WebSocket 이란?</h3>
<ul>
<li>양방향 통신을 제공하기 위해 개발된 프로토콜이다.</li>
<li>기존의 단방향 HTTP 프로토콜과 호환된다.</li>
<li>일반 Socket 통신과 달리, HTTP 80 포트를 사용하므로 방화벽 제약이 없다.</li>
<li>접속까지는 HTTP 프로토콜을 이용하고, 통신은 자체적인 WebSocket 프로토콜을 사용한다.</li>
</ul>
<br/>
<h3 id="http---">일반 HTTP 통신의 동작 방식</h3>
<ul>
<li><strong>클라이언트의 요청이 있어야만, 서버가 응답 msg를 보낼 수 있다.</strong></li>
<li><strong>응답 msg를 보낸 후, 클라이언트와의 연결이 종료된다.</strong></li>
<li>일반 HTTP는 반이중 통신이다.
<ul>
<li>반이중 통신: 동시에 양쪽이 데이터를 보낼 수 없음</li>
</ul>
</li>
</ul>
<br/>
<p><img src="/assets/img/2021-12-23-Tech_WebSocket/Untitled.png" alt="출처: 솔내시스템 ezTCP님의 블로그" /></p>
<p>출처: 솔내시스템 ezTCP님의 블로그</p>
<br/>
<ul>
<li>순수 HTTP만으로 WebSocket과 같이 동작시키는 방법들
<ul>
<li><strong>polling</strong>
<ul>
<li>클라이언트가 일반 HTTP Request 메시지를 서버로 계속 요청한다.</li>
<li>HTTP Connection을 맺고 끊음을 반복하므로 부담이 크다.</li>
</ul>
</li>
<li><strong>Long polling</strong>
<ul>
<li>클라이언트가 일반 HTTP Request 메시지를 서버에 일단 요청한다.</li>
<li>클라이언트가 그 상태로 계속 대기하다가, 서버에서 이벤트가 발생하면 그제서야 응답한다.</li>
<li>그 후, 클라이언트가 다시 Request 메시지를 보낸다.</li>
<li>이벤트 간의 시간간격이 좁으면, polling과 차이점이 없어진다. 즉, 부담이 커진다.</li>
</ul>
</li>
<li><strong>Streaming</strong>
<ul>
<li>클라이언트가 일반 HTTP Request 메시지를 서버에 일단 요청한다.</li>
<li>클라이언트가 그 상태로 계속 대기하다가, 서버에서 이벤트가 발생하면 그제서야 응답한다.</li>
<li><strong>이때 메시지만 보내고 (Flush) 연결을 끊지는 않는다.</strong></li>
<li>Connection 과정이 최초 한 번만 필요하므로, 부담이 경감된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="websocket--">WebSocket의 동작 방식</h3>
<p><img src="/assets/img/2021-12-23-Tech_WebSocket/Untitled%201.png" alt="출처: 위키백과" /></p>
<p>출처: 위키백과</p>
<ul>
<li>최초 Connection을 맺을 때, <strong>HTTP Handshake</strong>를 진행한다.</li>
<li>그 후부터는, Websocket 프로토콜을 사용한다.</li>
<li><strong>클라이언트가 접속 요청을 하고, 웹 서버가 응답한 후 Connection을 유지한다.</strong></li>
<li><strong>클라이언트의 요청 없이도 데이터를 전송할 수 있는 프로토콜이다.</strong></li>
<li>HTTP 환경에서 전이중 통신을 지원한다.</li>
</ul>
<blockquote>
<p><strong>ws://~ 로 WebSocket 요청 MSG를 보낸다.</strong></p>
</blockquote>
<br/>
<h3 id="websocket---1">WebSocket 접속 과정</h3>
<p><img src="/assets/img/2021-12-23-Tech_WebSocket/Untitled%202.png" alt="출처: https://blog.naver.com/eztcpcom/220070508655" /></p>
<p>출처: <a href="https://blog.naver.com/eztcpcom/220070508655">https://blog.naver.com/eztcpcom/220070508655</a></p>
<ul>
<li>HTTP와 마찬가지로 WebSocket 역시 TCP/IP 위에서 동작하므로 가장 먼저 TCP/IP 접속을 해야한다.</li>
<li>그 후, HTTP Handshake를 진행한다.</li>
</ul>
<blockquote>
<p>참고로 소켓통신에서 클라이언트와 서버는 N:1 관계로 연결된다.</p>
</blockquote>
<p><br/><br/></p>
<h2 id="websocket--with-spring-boot">WebSocket 구현 (With Spring-boot)</h2>
<h3 id="codebuildgradlecode">의존성 추가: <code>build.gradle</code></h3>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation 'org.springframework.boot:spring-boot-starter-websocket'
</code></pre></div></div>
<br/>
<h3 id="codewebsockethandlercode">웹소켓 핸들러: <code>WebSocketHandler</code></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSocketHandler</span> <span class="kd">extends</span> <span class="nc">TextWebSocketHandler</span> <span class="o">{</span>
<pre><code>&lt;span class=&quot;c1&quot;&gt;//웹소켓에 접속한 클라이언트 정보를 저장할 컬렉션&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebSocketSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sessionList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//클라이언트가 msg 전송 시, 호출되는 메서드&lt;/span&gt;
</code></pre>
<p><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">handleTextMessage</span><span class="o">(</span><span class="nc">WebSocketSession</span> <span class="n">session</span><span class="o">,</span> <span class="nc">TextMessage</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
<span class="nc">String</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">getPayload</span><span class="o">();</span> <span class="c1">//전달 받은 msg의 페이로드</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">“payload : “</span> <span class="o">+</span> <span class="n">payload</span><span class="o">);</span></p>
<pre><code>	&lt;span class=&quot;c1&quot;&gt;//요청받은 msg의 페이로드를 웹소켓에 접속된 모든 클라이언트에게 전송한다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebSocketSession&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;sess:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sessionList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
</code></pre>
<p><span class="o">}</span></p>
<p><span class="c1">// 클라이언트가 웹소켓에 접속 시, 호출되는 메서드</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterConnectionEstablished</span><span class="o">(</span><span class="nc">WebSocketSession</span> <span class="n">session</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">session</span><span class="o">);</span> <span class="c1">//접속한 클라이언트 정보를 저장한다.</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">session</span> <span class="o">+</span> <span class="s">” 클라이언트 접속”</span><span class="o">);</span>
<span class="o">}</span></p>
<p><span class="c1">//클라이언트가 웹소켓 접속 해지 시, 호출되는 메서드</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterConnectionClosed</span><span class="o">(</span><span class="nc">WebSocketSession</span> <span class="n">session</span><span class="o">,</span> <span class="nc">CloseStatus</span> <span class="n">status</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">session</span> <span class="o">+</span> <span class="s">” 클라이언트 접속 해제”</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">session</span><span class="o">);</span> <span class="c1">//해제한 클라이언트의 정보를 제거한다.</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></p>
<ul>
<li><code>extends TextWebSocketHandler</code>
<ul>
<li>텍스트 기반 웹소켓 핸들러를 구현하려면, <code>TextWebSocketHandler</code> 를 상속받아서 구현해야 한다.</li>
</ul>
</li>
<li><code>List&lt;WebSocketSession&gt; sessionList</code>
<ul>
<li>웹소켓에 접속한 클라이언트 정보를 저장할 리스트이다.</li>
<li><code>WebSocketSession</code>
<ul>
<li>웹소켓에 접속한 사용자(클라이언트)의 정보가 담겨있는 객체이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="codewebsocketconfigcode">웹소켓핸들러 등록: <code>WebSocketConfig</code></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@EnableWebSocket</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSocketConfig</span> <span class="kd">implements</span> <span class="nc">WebSocketConfigurer</span> <span class="o">{</span>
<pre><code>&lt;span class=&quot;c1&quot;&gt;//생성자 주입&lt;/span&gt;
</code></pre>
<p><span class="kd">private</span> <span class="kd">final</span> <span class="nc">WebSocketHandler</span> <span class="n">webSocketHandler</span><span class="o">;</span></p>
<p><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerWebSocketHandlers</span><span class="o">(</span><span class="nc">WebSocketHandlerRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
<span class="n">registry</span><span class="o">.</span><span class="na">addHandler</span><span class="o">(</span><span class="n">webSocketHandler</span><span class="o">,</span> <span class="s">”/ws”</span><span class="o">).</span><span class="na">setAllowedOrigins</span><span class="o">(</span><span class="s">”*”</span><span class="o">);</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></p>
<ul>
<li>
<p><code>addHandler(webSocketHandler, &quot;/ws&quot;)</code></p>
<ul>
<li>
<p>웹소켓에 접속할 엔드포인트를 설정한다.</p>
</li>
<li>
<p>위 경우, 아래 주소로 요청하여 웹소켓에 접속(Connection)할 수 있다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ws//localhost:8080/ws
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p><code>setAllowedOrigins(&quot;*&quot;)</code></p>
<ul>
<li>CORS 를 허용한다.</li>
</ul>
</li>
</ul>
:ET