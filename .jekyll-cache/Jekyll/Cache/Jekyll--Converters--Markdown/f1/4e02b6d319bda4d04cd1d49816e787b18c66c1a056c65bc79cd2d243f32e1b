I"u<p><br/><br/></p>
<blockquote>
<p><a href="https://github.com/TaegyunWoo/algorithm-study/blob/main/src/main/java/shortestpath/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EA%B0%9C%EC%84%A0.java">소스코드</a></p>
</blockquote>
<br/>
<h1 id="section">다익스트라 알고리즘 - 개선버전</h1>
<h2 id="section-1">개요</h2>
<h3 id="vs-">기존버전 vs 개선버전</h3>
<ul>
<li>다익스트라 알고리즘을 간단히 구현하면 시간 복잡도가 <code>O(V^2)</code> 이다.</li>
<li>하지만 지금 다룰 구현방법을 이용하면 다익스트라 최단 경로 문제를 최악의 경우에도 시간 복잡도 <code>O(ElogV)</code> 를 보장하여 해결할 수 있다.
<ul>
<li>여기서 <code>V</code> 는 노드의 개수이고, <code>E</code> 는 간선의 개수를 의미한다.</li>
</ul>
</li>
<li>간단한 다익스트라 알고리즘은 ‘최단 거리가 가장 짧은 노드’를 찾기 위해서, 매번 최단 거리 테이블을 선형적으로 (모든 원소를 앞에서부터 하나씩) 탐색해야 했다.</li>
<li>개선된 다익스트라 알고리즘에서는 <strong>힙 자료구조</strong> 를 이용한다. 힙 자료구조를 이용하면 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로, 출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.
<ul>
<li>이 과정에서 선형 시간이 아닌, 로그 시간이 걸린다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-2">힙 자료구조와 우선순위 큐</h3>
<ul>
<li>힙 자료구조는 <strong>우선순위 큐</strong> 를 구현하기 위해 사용하는 자료구조 중 하나이다.</li>
<li>힙 자료구조 종류
<ul>
<li>최대힙: 부모노드의 키값이 자식노드의 키값보다 크거나 같은 완전이진트리, <code>부모노드Key값 ≥ 자식노드Key값</code></li>
<li>최소힙: 부모노드의 키값이 자식노드의 키값보다 작거나 같은 완전이진트리, <code>부모노드Key값 ≤ 자식노드Key값</code></li>
</ul>
</li>
<li>힙 자료구조에서의 시간복잡도
<ul>
<li>자료 삽입시 시간복잡도: <code>O(logN)</code></li>
<li>자료 삭제시(검색시) 시간복잡도: <code>O(logN)</code></li>
</ul>
</li>
<li>우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 구조이다.</li>
</ul>
<br/>
<table>
<thead>
<tr>
<th>자료구조</th>
<th>추출되는 데이터</th>
</tr>
</thead>
<tbody>
<tr>
<td>스택(Stack)</td>
<td>가장 나중에 삽입된 데이터</td>
</tr>
<tr>
<td>큐(Queue)</td>
<td>가장 먼저 삽입된 데이터</td>
</tr>
<tr>
<td>우선순위 큐(Priority Queue)</td>
<td>가장 우선순위가 높은 데이터</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li>대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리를 지원하기 때문에 일반적인 코딩 테스트 환경에서 우리가 직접 힙 자료구조부터 작성해서 우선순위 큐를 구현할 일은 없다.
<ul>
<li>대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리에 데이터의 묶음을 넣으면, 첫 번쨰 원소를 기준으로 우선순위를 설정한다.</li>
<li>따라서 데이터가 (가치,물건)으로 구성된다면, ‘가치’ 값이 우선순위 값이 되는 것이다.</li>
</ul>
</li>
<li>우선순위 큐를 구현할 때는 내부적으로 최소힙 혹은 최대힙을 이용한다.
<ul>
<li>최소힙을 이용하는 경우: 값이 낮은 데이터가 먼저 삭제된다.</li>
<li>최대힙을 이용하는 경우: 값이 큰 데이터가 먼저 삭제된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>최소 힙을 최대 힙처럼 사용하는 방법?</p>
</blockquote>
<br/>  
&nbsp;&nbsp;우선순위에 해당하는 값에 음수 부호(-)를 붙여서 넣었다가, 나중에 우선순위 큐에서 꺼낸 다음에 다시 음수 부호(-)를 붙여서 원래의 값으로 돌리는 방식을 사용할 수 있다.  
&nbsp;&nbsp;이러한 테크닉도 실제 코딩 테스트 환경에서는 자주 사용될 수 있다.
<blockquote>
<p>자바에서는 기본적으로 <code>최소 힙</code> 을 사용하여 우선순위 큐가 구현되어 있다.</p>
</blockquote>
<br/>
<h3 id="section-3">다익스트라 알고리즘에 우선순위 큐 적용하기</h3>
<ul>
<li>우선순위 큐를 적용하여도 다익스트라 알고리즘이 동작하는 기본 원리는 동일하다.</li>
<li>최단 거리를 저장하기 위한 1차원 리스트(최단 거리 테이블)는 기존처럼 그대로 이용한다.</li>
<li><strong>현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용한다.</strong></li>
</ul>
<h3 id="section-4">다익스트라 알고리즘 동작 방식</h3>
<ol>
<li>출발 노드를 설정한다.</li>
<li>최단 거리 테이블을 초기화하고, 우선순위 큐에 <code>(거리: 0, 노드: 출발노드)</code> 를 넣는다.</li>
<li>우선순위 큐에서 데이터를 꺼낸다. 만약 꺼낸 데이터의 노드가 이미 처리된 적(방문한 적)있다면, 다시 꺼낸다.</li>
<li>꺼낸 노드를 방문 처리한다.</li>
<li><code>'시작노드'부터 '3번에서 꺼낸 데이터의 노드'에 연결된 노드까지의 최소 거리</code> 를 구하여, 최단 거리 테이블을 갱신한다.</li>
<li>4번에서 갱신된 데이터 <code>(거리, 노드)</code>를 우선순위 큐에 집어넣는다.</li>
<li>3번, 4번, 5번을 순서대로 반복한다.</li>
</ol>
<p><br/><br/></p>
<h2 id="section-5">동작 예시</h2>
<h3 id="section-6">예시에서 사용할 그래프 형태</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled10.jpg" alt="" /></p>
<ul>
<li>시작노드는 1번 노드이다.</li>
</ul>
<br/>
<h3 id="step-01">Step 01</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled11.jpg" alt="" /></p>
<ul>
<li>출발 노드에서 출발 노드로의 거리는 0이다.</li>
<li>우선순위 큐에 1번 노드를 포함한 데이터를 넣는다.</li>
</ul>
<br/>
<h3 id="step-02">Step 02</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled12.jpg" alt="" /></p>
<ul>
<li>dequeue된 노드 1번이 방문처리되지 않았으므로, ‘시작노드’부터 ‘노드 1번에 연결된 노드들’ 간의 거리를 구한다.</li>
<li>계산된 거리가 최단 거리 테이블의 값보다 작으면 갱신한다.</li>
<li>그리고 갱신된 데이터를 우선순위 큐에 집어넣는다.</li>
</ul>
<br/>
<h3 id="step-03">Step 03</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled13.jpg" alt="" /></p>
<ul>
<li>dequeue된 노드 4번이 방문처리되지 않았으므로, ‘시작노드’부터 ‘노드 4번에 연결된 노드들’ 간의 거리를 구한다.</li>
<li>계산된 값이 작다면 최단 거리 테이블을 갱신하고, 갱신된 데이터를 우선순위 큐에 집어넣는다.</li>
</ul>
<br/>
<h3 id="step-04">Step 04</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled14.jpg" alt="" /></p>
<ul>
<li>위 그림에선 <code>1 -&gt; 2 -&gt; 3</code>으로 갈 때의 거리 ‘5’보다<br />
기존의 <code>1 -&gt; 4 -&gt; 3</code> 방식의 거리 ‘4’가 더 작기 때문에, 갱신하지 않는다.</li>
<li>갱신되지 않으면 우선순위 큐에 넣지 않는다.</li>
</ul>
<br/>
<h3 id="step-05">Step 05</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled15.jpg" alt="" /></p>
<br/>
<h3 id="step-06">Step 06</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled16.jpg" alt="" /></p>
<br/>
<h3 id="step-07">Step 07</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled17.jpg" alt="" /></p>
<ul>
<li>dequeue 된 노드 3은 이미 처리완료 상태(방문 완료 상태) 이기 때문에, 무시한다.</li>
</ul>
<br/>
<h3 id="step-08">Step 08</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled18.jpg" alt="" /></p>
<br/>
<h3 id="step-09">Step 09</h3>
<p><img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled19.jpg" alt="" /></p>
<br/>
<h3 id="section-7">특징</h3>
<ul>
<li><a href="https://github.com/TaegyunWoo/algorithm-study/blob/main/doc/shortestpath/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EA%B8%B0%EB%B3%B8.md">기존 다익스트라 알고리즘</a>
에서 사용한 <code>getShortestNode()</code> 함수를 사용하지 않아도 된다.
<ul>
<li>왜냐하면 <strong>‘최단 거리가 가장 짧은 노드’를 선택하는 과정을 다익스트라 최단 경로 함수 안에서 우선순위 큐를 이용하는 방식으로 대체</strong> 할 수 있기 때문이다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-8">소스코드</h2>
<h3 id="section-9">다익스트라 알고리즘</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">다익스트라_개선</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">sizeOfNode</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">sizeOfEdge</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">startNode</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">shortestTable</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10001</span><span class="o">];</span>

  <span class="cm">/**
   * 실행 메서드
   */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">BufferedReader</span> <span class="n">bf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">sizeOfNode</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    <span class="n">sizeOfEdge</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    <span class="n">startNode</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sizeOfNode</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">graph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;());</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sizeOfEdge</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
      <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
      <span class="kt">int</span> <span class="n">fromNode</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
      <span class="kt">int</span> <span class="n">toNode</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
      <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
      <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">fromNode</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">toNode</span><span class="o">,</span> <span class="n">distance</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">solution</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sizeOfNode</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

      <span class="c1">//시작노드에서 도달할 수 없는 노드인 경우</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">shortestTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"INFINITE"</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">shortestTable</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/**
   * 다익스트라 알고리즘 메서드
   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">solution</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//우선순위 큐 (최소힙으로 구현되어있다.)</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">priorityQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

    <span class="c1">//최단거리 테이블 초기화</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">shortestTable</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="n">shortestTable</span><span class="o">[</span><span class="n">startNode</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="n">priorityQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">startNode</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span> <span class="c1">//우선순위 큐에 시작노드 데이터 집어넣기</span>

    <span class="c1">//우선순위 큐가 빌때까지 반복</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">priorityQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span> <span class="c1">//우선순위 큐에서 거리가 가장 짧은 노드 꺼내기</span>
      <span class="kt">int</span> <span class="n">nowNodeIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getIndex</span><span class="o">();</span> <span class="c1">//현재 노드 index</span>
      <span class="kt">int</span> <span class="n">nowNodeDistance</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getDistance</span><span class="o">();</span> <span class="c1">//현재 노드 거리</span>

      <span class="c1">//최단거리 테이블 값보다 현재노드의 거리가 더 크다면, 해당 노드는 이미 처리가 된 것이다.</span>
      <span class="cm">/*
        "우선순위 큐에 저장된 데이터 == 과거에 최소거리 테이블을 갱신할 때 사용된 데이터" 이다.
        그러므로 '우선순위 큐에 저장된 데이터' 보다 현재의 '최소거리 테이블의 데이터' 가 작다면,
        해당 '우선순위 큐에 저장된 데이터' 는 필요없는 값이 된다.
       */</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">shortestTable</span><span class="o">[</span><span class="n">nowNodeIndex</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nowNodeDistance</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

      <span class="c1">//현재 노드와 연결된 다른 인접한 노드들을 확인</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nowNodeIndex</span><span class="o">).</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">nearNodeIndex</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nowNodeIndex</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">getIndex</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">nearNodeDistance</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nowNodeIndex</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">getDistance</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">distanceOfStartNodeToNearNode</span> <span class="o">=</span> <span class="n">shortestTable</span><span class="o">[</span><span class="n">nowNodeIndex</span><span class="o">]</span> <span class="o">+</span> <span class="n">nearNodeDistance</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">distanceOfStartNodeToNearNode</span> <span class="o">&lt;</span> <span class="n">shortestTable</span><span class="o">[</span><span class="n">nearNodeIndex</span><span class="o">])</span> <span class="o">{</span>
          <span class="n">shortestTable</span><span class="o">[</span><span class="n">nearNodeIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">distanceOfStartNodeToNearNode</span><span class="o">;</span>
          <span class="n">priorityQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">nearNodeIndex</span><span class="o">,</span> <span class="n">distanceOfStartNodeToNearNode</span><span class="o">));</span>
        <span class="o">}</span>
      <span class="o">}</span> <span class="c1">//내부 for문 종료</span>

    <span class="o">}</span> <span class="c1">//외부 while문 종료</span>

  <span class="o">}</span>

  <span class="cm">/**
   * Comparable 인터페이스를 상속받는다.
   * Comparable 인터페이스: 객체간 비교를 위한 인터페이스
   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getIndex</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getDistance</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//우선순위 큐 내부에서 정렬될 때 사용된다.</span>
    <span class="c1">//거리가 짧은 것이 높은 우선순위를 가지도록 설정</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Node</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">distance</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="na">distance</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">//음수 또는 0이면 객체의 자리가 유지된다. (우선순위 큐가 최소힙으로 구성되어있으므로)</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">//양수인 경우에는 두 객체의 자리가 바뀐다. (우선순위 큐가 최소힙으로 구성되어있으므로)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<ul>
<li><code>if (shortestTable[nowNodeIndex] &lt; nowNodeDistance)</code> 를 통해, 처리했던 노드인지 판단할 수 있는 이유?
<ul>
<li>
<p>우선순위 큐에는 ‘과거에 최단거리 테이블을 갱신하며 넣어둔 데이터’ 들이 여러 개 존재한다.</p>
</li>
<li>
<p>이때 데이터를 enqueue할 때, ‘최단거리 테이블이 갱신되었을 경우’에만 enqueue한다는 것 이외의 제약은 없다.</p>
</li>
<li>
<p>따라서 같은 노드가 여러 번 갱신되었을 때, 우선순위 큐에는 동일한 노드를 갖는 데이터가 여러 개 존재한다. 이는 위 ‘동작 예시’ 에서 확인해볼 수 있다.</p>
<ul>
<li><code>Step02</code> : ‘노드 3’이 갱신되며 우선순위 큐에 enqueue 되었다.
<img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled12.jpg" alt="" /></li>
</ul>
<br/>
<ul>
<li><code>Step03</code> : ‘노드 3’이 <strong>다시 갱신</strong> 되며 우선순위 큐에 enqueue 되었다.
<img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled13.jpg" alt="" /></li>
</ul>
<br/>
<ul>
<li>
<p><code>Step05</code> : ‘노드 3’이 <strong>또 다시 갱신</strong> 되며 우선순위 큐에 enqueue 되었다.
<img src="/assets/img/2022-01-18-ALGORITHM_ShortestPath_DijkstraExpert/Untitled15.jpg" alt="" /></p>
</li>
<li>
<p>따라서 ‘노드 3’ 관련 데이터가 총 3번 enqueue되었고, 우선순위 큐에서 공존하는 상태이다.</p>
</li>
</ul>
</li>
<li>
<p><code>nowNodeDistance</code> 는 우선순위 큐에서 뽑아낸 노드의 거리값이다.<br />
우선순위 큐는 거리가 <strong>가장 작은</strong> 것을 dequeue 해주니, <code>nowNodeDistance</code> 는 현재 우선순위 큐에 들어있는 값 중 가장 작은 값이다.</p>
</li>
<li>
<p>그렇다면, <code>shortestTable[nowNodeIndex] &lt; nowNodeDistance</code> 가 뜻하는바는 무엇일까.</p>
<ul>
<li><strong><code>nowNodeDistance</code>는 현재로써 가장 작은 값이지만, <code>shortestTable[nowNodeIndex]</code> 이 더 작다면 이미 해당 노드가 처리되었다는 것이다.</strong></li>
<li>즉 우선순위 큐에 같은 노드가 여러 개 존재할 수 있으므로,
현재의 <code>nowNodeDistance</code> 보다 더 작은 값을 갖는 데이터가
과거에 이미 dequeue 되어 처리되었었다는 의미이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">시간복잡도</h3>
<ul>
<li>위 알고리즘은 <code>O(ElogV)</code>의 시간복잡도를 갖는다.
<ul>
<li><code>V</code> : 노드 개수</li>
<li><code>E</code> : 간선 개수</li>
</ul>
</li>
<li>노드를 하나씩 꺼내 검사하는 반복문(<code>while문</code>)은 노드의 개수 <strong>V 이상의 횟수</strong>로는 반복되지 않는다.</li>
<li>또한 V번 반복될 때마다 각각 자신과 연결된 간선들을 모두 확인(<code>for문</code>)한다.</li>
<li>따라서 ‘현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인’하는 총 횟수는 총 최대 간선의 개수(E)만큼 연산이 수행될 수 있다.
<ul>
<li>즉 전체 다익스트라 최단 경로 알고리즘은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사하다고 볼 수 있다.</li>
</ul>
</li>
<li><strong>간단하게 생각하면 다익스트라 알고리즘의 시간 복잡도는 최대 E개의 간선 데이터를 힙에 넣었다가 다시 빼는 것으로 볼 수 있으므로 <code>O(ElogE)</code>임을 이해할 수 있다.</strong></li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>나동빈, 『이것이 코딩 테스트다』</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET