I"G<p><br/><br/></p>
<ul>
<li>이전 게시글
<ul>
<li><a href="https://taegyunwoo.github.io/os/OS_Process1">[OS] 프로세스 - 1</a></li>
</ul>
</li>
</ul>
<p>본 포스팅 글은 이전 게시글에 대해 이어지는 내용을 작성합니다. 해당 게시글을 확인하지 않으신 분은 먼저 이전 글을 읽고 오시기 바랍니다.</p>
<p><br/><br/></p>
<h1 id="section">프로세스 통신</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">프로세스 종류</h3>
<ul>
<li>독립적으로 작동하는 프로세스</li>
<li>협력적으로 작동하는 프로세스
<ul>
<li>협력적으로 작동하는 프로세스는 서로 영향을 준다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">협력 프로세스를 사용하는 이유</h3>
<ul>
<li>정보 공유</li>
<li>연산속도 향상</li>
<li>모듈화</li>
<li>편의성</li>
</ul>
<br/>
<h3 id="ipc">IPC</h3>
<ul>
<li>IPC: Interprocess Communication</li>
<li>협력 프로세스가 원활하게 동작하기 위한 방법을 의미한다.</li>
<li>IPC의 종류
<ul>
<li><strong>Shared Memory</strong></li>
<li><strong>Message Passing</strong></li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-4">프로세스 통신 모델</h2>
<h3 id="message-passing-vs-shared-memory">Message Passing vs Shared Memory</h3>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2059.png" alt="Untitled" /></p>
<ul>
<li>
<p><strong>Message Passing</strong></p>
<ul>
<li>Message Queue를 통해 메시지를 주고받는다.</li>
<li>Kernel을 통해, Message를 교환하여 Kernel Overhead가 발생할 수 있다.</li>
<li>프로세스간 직접적으로 통신을 하지 않는다.</li>
</ul>
</li>
<li>
<p><strong>Shared Memory</strong></p>
<ul>
<li>공유메모리를 통해 프로세스가 서로 소통한다.</li>
<li>동기화(Sync)를 통해서 동시성 문제를 극복한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-5">공유 메모리</h2>
<h3 id="section-6">공유 메모리 원리</h3>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2060.png" alt="Untitled" /></p>
<br/>
<h3 id="section-7">생산자 소비자 문제</h3>
<ul>
<li>
<p>생산자, 소비자는 협력 프로세스가 서로 통신하기 위해 필요하다.</p>
</li>
<li>
<p>생산자: 공유할 데이터를 생산(Write)한다.</p>
</li>
<li>
<p>소비자: 공유할 데이터를 소비(Read)한다.</p>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2061.png" alt="Untitled" /></p>
<blockquote>
<p><strong>읽고 쓰는 속도가 동일해야 한다.</strong></p>
</blockquote>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-8">버퍼</h2>
<h3 id="section-9">버퍼의 종류</h3>
<ul>
<li><strong>무한 버퍼</strong></li>
<li><strong>유한 버퍼</strong></li>
</ul>
<br/>
<h3 id="section-10">유한 버퍼</h3>
<ul>
<li>
<p>유한 버퍼는 공유 메모리에서 사용된다.</p>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2062.png" alt="Untitled" /></p>
</li>
<li>
<p>유한 버퍼 소스코드</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define BUFFER_SIZE 10
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c1">//...</span>
<span class="p">}</span> <span class="n">item</span><span class="p">;</span>

<span class="n">item</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Write 할 곳의 index</span>
<span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Read 할 곳의 index</span>
</code></pre></div></div>
<ul>
<li>즉, 유한버퍼는 큐 형태를 가진다.</li>
</ul>
</li>
<li>
<p>버퍼 상태</p>
<ul>
<li><strong>empty 상태</strong>
<ul>
<li>“in == out” 일 때, 버퍼는 빈 상태가 된다.</li>
</ul>
</li>
<li><strong>full 상태</strong>
<ul>
<li>“((in+1)%BUFFER_SIZE) == out” 일 때, 버퍼는 꽉 찬 상태가 된다.</li>
</ul>
</li>
<li>원형 큐의 상태와 동일하다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">유한버퍼: 생산자</h3>
<ul>
<li>
<p>아래 코드는 버퍼에 생산자가 공유할 데이터를 생산하는 예시코드이다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item</span> <span class="n">next_producted</span><span class="p">;</span>
<span class="k">while</span><span class="p">(((</span><span class="n">in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="o">==</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//buffer가 full상태인 경우</span>
	<span class="c1">//Do Nothing</span>
<span class="p">}</span>
<span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_produced</span><span class="p">;</span> <span class="c1">//비어있는 곳(변수 in)에 item을 삽입(생산)한다.</span>
<span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span> <span class="c1">//변수 in이 다음 비어 있는 원소를 가리키도록 한다.</span>
</code></pre></div></div>
<ul>
<li><code>((in+1)%BUFFER_SIZE)==out</code>
<ul>
<li>해당 조건은 원형 큐 형태인 버퍼가 full 상태인지 판단한다.</li>
<li><code>while</code> 문을 통해, 버퍼가 꽉 차있으면 공유할 데이터를 삽입하지 않도록 한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>환형 버퍼(원형 버퍼) 예시</p>
<ul>
<li><strong>사용자는 최대 ‘BUFFER_SIZE-1’개 만큼의 버퍼를 사용할 수 있다.</strong></li>
<li>마지막 공간까지 데이터가 채워진다면, full 상태와 empty 상태를 구분할 수 없기 때문이다.</li>
</ul>
<blockquote>
<p>자세한 내용은 이전에 포스팅한 글 “<a href="https://taegyunwoo.github.io/datastructure/DATASTRUCTURE_Queue#14">[데이터구조] 큐</a>“를 참고하자.</p>
</blockquote>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2063.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-12">유한버퍼: 소비자</h3>
<ul>
<li>
<p>아래 코드는 버퍼에 소비자가 공유할 데이터를 소비하는 예시코드이다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item</span> <span class="n">next_consumed</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">in</span><span class="o">==</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//공백 상태일 때</span>
		<span class="c1">//Do Nothing</span>
	<span class="p">}</span>

	<span class="n">next_consumed</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span> <span class="c1">// 읽기</span>
	<span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span> <span class="c1">// 변수 out이 다음에 읽을 위치를 가르키도록</span>
<span class="p">}</span>
<span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_produced</span><span class="p">;</span> <span class="c1">//비어있는 곳(변수 in)에 item을 삽입한다.</span>
<span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span> <span class="c1">//변수 in이 다음 비어 있는 원소를 가리키도록 한다.</span>
</code></pre></div></div>
<ul>
<li><code>in==out</code>
<ul>
<li>해당 조건은 원형 큐 형태인 버퍼가 empty 상태인지 판단한다.</li>
<li><code>while</code> 문을 통해, 버퍼가 비어있으면 공유할 데이터를 소비하지 않도록 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="message-passing--">Message Passing (메시지 전달)</h2>
<h3 id="section-13">개요</h3>
<ul>
<li>
<p>Message Passing은 IPC의 한 종류이다.</p>
<ul>
<li>또다른 종류로는 Shared Memory (공유 메모리)가 존재한다.</li>
</ul>
</li>
<li>
<p>Message Passing에서 사용하는 동작들</p>
<ul>
<li>send(message)
<ul>
<li>메시지 송신</li>
</ul>
</li>
<li>receive(message)
<ul>
<li>메시지 수신</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Message Passing을 위해 준비해야하는 것</p>
<ul>
<li>프로세스 간의 통신 링크 만들기</li>
<li>send와 receive를 통해, 메시지 교환하기</li>
<li>주요 이슈
<ul>
<li>어떻게 링크를 만들 것인가?</li>
<li>링크는 단방향인가, 양방향인가?</li>
</ul>
</li>
<li>통신 링크의 종류
<ul>
<li>물리적 링크
<ul>
<li>Shared Memory</li>
<li>Hardware Bus</li>
<li>Network</li>
</ul>
</li>
<li>논리적 링크
<ul>
<li>동기, 비동기 링크</li>
<li>자동적, 명시적 버퍼</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-14">직접 통신</h3>
<ul>
<li>
<p>P2P 방식의 통신이다.</p>
</li>
<li>
<p>행동</p>
<ul>
<li>send(P, message)
<ul>
<li>프로세스 P에게 메시지를 보낸다.</li>
</ul>
</li>
<li>receive(Q, message)
<ul>
<li>프로세스 Q로부터 온 메시지를 받는다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>통신 링크의 속성</p>
<ul>
<li>자동 링크 연결</li>
<li>한 쌍의 통신 프로세스만 연관되어 있다.</li>
<li>단방향, 양방향 링크 존재</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2064.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-15">간접 통신</h3>
<ul>
<li>
<p>메일박스(포트)를 통해서 통신하는 방법이다.</p>
</li>
<li>
<p>프로세스가 서로 직접적으로 통신하지는 않는다.</p>
</li>
<li>
<p>메일박스</p>
<ul>
<li>Mailbox는 port라고 불리기도 한다.</li>
<li>각 메일박스는 유일한 식별자를 가지고 있다.</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2065.png" alt="Untitled" /></p>
</li>
<li>
<p>특징</p>
<ul>
<li>
<p>링크가 여러 프로세스와 연결되어 있을 수 있다.</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2066.png" alt="Untitled" /></p>
</li>
<li>
<p>프로세스들이 여러 개의 링크를 가질 수 있다.</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2067.png" alt="Untitled" /></p>
</li>
</ul>
</li>
<li>
<p>연산의 종류</p>
<ul>
<li>새 메일박스(포트) 만들기</li>
<li>메일박스를 통해서 send, receive 하기</li>
<li>메일박스 삭제하기</li>
</ul>
</li>
</ul>
<br/>
<h3 id="message-passing-">Message Passing 종류</h3>
<p>Message Passing은 여러가지 종류가 있다.</p>
<ul>
<li>Message Passing의 종류
<ul>
<li>봉쇄형</li>
<li>비봉쇄형</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-16">봉쇄형</h3>
<ul>
<li>
<p>봉쇄(Blocking)을 통해, 동기(Sync)를 할 수 있다.</p>
</li>
<li>
<p>봉쇄형의 종류</p>
<ul>
<li><strong>봉쇄형 송신</strong>
<ul>
<li>sender는 보낸 메시지가 받아질 때까지 Block된다.</li>
</ul>
</li>
<li><strong>봉쇄형 수신</strong>
<ul>
<li>receiver는 메시지가 도착할 때까지 Block된다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>시각화</strong></p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2068.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-17">비봉쇄형</h3>
<ul>
<li>
<p>비봉쇄(Unblocking)을 통해, 비동기(async)를 할 수 있다.</p>
</li>
<li>
<p>비봉쇄형의 종류</p>
<ul>
<li><strong>비봉쇄형 송신</strong>
<ul>
<li>sender는 메시지를 보내고, 할일을 계속한다.</li>
</ul>
</li>
<li><strong>비봉쇄형 수신</strong>
<ul>
<li>receiver는 ‘유효한 메시지를 받거나’, ‘Null 메시지라도 받아서’ 작업을 계속한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2069.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-18">랑데부</h3>
<ul>
<li>랑데부란?
<ul>
<li>send와 receive가 동시에 Block인 상태를 뜻한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-19">버퍼링</h2>
<h3 id="section-20">버퍼링이란</h3>
<ul>
<li>
<p>직접, 간접 통신 모두 프로세스 간에 교환되는 메시지는 임시 큐에 들어간다. 이것을 버퍼링이라고 한다.</p>
</li>
<li>
<p>버퍼링 종류</p>
<ul>
<li><strong>Zero Capacity</strong>
<ul>
<li>오직 한개씩만 주고 받는다.</li>
<li>Queue의 길이가 1인 것</li>
<li>즉, 큐잉이 불가능하다.</li>
</ul>
</li>
<li><strong>Bounded Capacity</strong>
<ul>
<li>유한 용량</li>
</ul>
</li>
<li><strong>Unbounded Capacity</strong>
<ul>
<li>무한 용량</li>
</ul>
</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2070.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="ipc-">IPC 예시</h2>
<h3 id="mach-">Mach 시스템</h3>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2071.png" alt="Untitled" /></p>
<ul>
<li>msg_send() : 메시지를 메일박스에 보낸다.</li>
<li>msg_receive() : 메일박스에서 메시지를 수신한다.</li>
</ul>
<br/>
<h3 id="section-21">윈도우즈 시스템</h3>
<ul>
<li>윈도우즈는 <strong>“advanced local procedure call (LPC)“을 통해 Message Passing을 사용</strong>한다.</li>
<li>즉, 고급 로컬 프로시저 호출 기능에 기반한 윈도우즈는 메시지 전달 기법을 사용한다.</li>
</ul>
<p><br/><br/></p>
<h2 id="client-server-">Client-Server 시스템</h2>
<h3 id="section-22">주요 포인트</h3>
<ul>
<li>Socket</li>
<li>Remote Procedure Calls (RPC)</li>
<li>Pipes</li>
<li>Remote Method Invocation (Java에서)</li>
</ul>
<br/>
<h3 id="section-23">소켓</h3>
<ul>
<li>소켓은 연결의 종단점을 뜻한다.</li>
<li>소켓의 구성요소
<ul>
<li>Ip</li>
<li>Port</li>
</ul>
</li>
<li>포트
<ul>
<li>1024번 이하 포트는 주로 사용되는 메인 포트이다.</li>
<li>개발, 테스트 용으로 포트를 사용할 때는 1024번 이상 포트를 사용해야 한다.</li>
</ul>
</li>
<li>Loopback 주소
<ul>
<li>localhost</li>
<li>127.0.0.1</li>
<li>자기 자신으로 돌아오는 주소이다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2072.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>
<p>자바에서의 소켓</p>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2073.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="remote-procedure-calls">Remote Procedure Calls</h3>
<ul>
<li>
<p>RPC란?</p>
<ul>
<li>원격지에 존재하는 프로시저를 호출하는 방법이다.</li>
<li>프로시저: 일종의 로직</li>
</ul>
</li>
<li>
<p><strong>Big-endian</strong></p>
<ul>
<li>최상위 바이트를 먼저 저장한다.</li>
</ul>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2074.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>Little-endian</strong></p>
<ul>
<li>최하위 바이트를 먼저 저장한다.</li>
</ul>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2075.png" alt="Untitled" /></p>
</li>
<li>
<p>Big-endian과 Little-endian을 서로 변환, 해석할 해석기가 필요하다.</p>
<ul>
<li>왜냐하면, 통신하는 시스템들이 Big-endian과 Little-endian 을 모두 사용하기 때문이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="pipes">Pipes</h3>
<ul>
<li>파이프는 두 프로세스가 통신할 수 있게 하는 전달자 역할을 한다.</li>
<li>초기 UNIX에서 제공한 것으로 현재는 윈도우에서도 사용한다.</li>
<li>고려사항
<ul>
<li>단방향 vs 양방향</li>
<li>반이중 vs 전이중
<ul>
<li>반이중: 동시에 양방향 통신 X, 시점을 구분하여 송신과 수신을 따로 진행한다.</li>
<li>전이중: 동시에 양방향 통신 O</li>
</ul>
</li>
</ul>
</li>
<li>파이프의 종류
<ul>
<li><strong>Ordinary Pipes</strong>
<ul>
<li>일반 파이프</li>
</ul>
</li>
<li><strong>Named Pipes</strong>
<ul>
<li>지명 파이프</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-24">일반 파이프</h3>
<ul>
<li>부모-자식 프로세스 간의 통신시 아래 그림처럼 <code>fd</code>가 구분되어 사용된다.
<ul>
<li><code>fd</code> : file descriptor</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-10-12-OS_Process2/Untitled%2076.png" alt="Untitled" /></p>
<br/>
<h3 id="section-25">지명 파이프</h3>
<ul>
<li>양방향 통신이 가능하다.</li>
<li>통신할 프로세스가 부모-자식 관계여야만 사용할 수 있다는 제한도 존재하지 않는다.</li>
</ul>
<br/>
<h3 id="rmi">RMI</h3>
<ul>
<li>RMI란?
<ul>
<li>Remote Method Invocation</li>
<li>RMI 방식의 원리와 RPC 방식의 원리는 서로 같다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET