I";z<p><br/><br/></p>
<h1 id="section">명령어 세트</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">기계 명령어, 컴퓨터 명령어란?</h3>
<ul>
<li>프로세서가 실행할 수 있는 여러 가지 명령어들의 집합이다.</li>
<li>기계어 코드라고도 한다.</li>
</ul>
<br/>
<h3 id="section-3">기계 명령어 형식</h3>
<ul>
<li>명령어는 일련의 비트들에 의해서 표현된다.</li>
<li>명령어 세트에서 <strong>한 가지 이상의 명령어 형식</strong>이 사용될 수 있다.
<ul>
<li>명령어 세트에는 다양한 형식의 명령어가 존재한다.</li>
</ul>
</li>
<li>명령어는 필드들로 나누어진다.</li>
</ul>
<br/>
<ul>
<li>
<p>간단한 명령어 형식</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2026.png" alt="Untitled" /></p>
<ul>
<li><strong>Opcode</strong>
<ul>
<li>명령을 표현하는 이진 코드</li>
</ul>
</li>
<li><strong>Operand</strong>
<ul>
<li>명령에 사용될 값 or 주소</li>
<li>하나의 명령어에 여러 Operand 필드가 존재할 수 있다.</li>
<li><strong>명령에 사용될 값 자체를 담을 수도 있고, 명령에 사용될 값의 주소를 담을 수도 있다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-4">기계 명령어의 요소들</h3>
<p>아래는 기계 명령어를 구성하는 요소들이다.</p>
<ul>
<li><strong>연산 코드</strong>
<ul>
<li>수행될 연산을 지정한다.</li>
<li>연산 코드 or Opcode 에 의해 지정된다.</li>
</ul>
</li>
<li><strong>원천 오퍼랜드 참조</strong>
<ul>
<li>연산할 Data의 주소 또는 실제값을 담는다.</li>
</ul>
</li>
<li><strong>결과 오퍼랜드 참조</strong>
<ul>
<li>연산 결과를 저장할 위치(주소)를 담는다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-5">연산 코드: 명령어 종류</h3>
<ul>
<li><strong>데이터 처리</strong>
<ul>
<li>산술 및 논리 명령어</li>
</ul>
</li>
<li><strong>데이터 저장</strong>
<ul>
<li>기억장치와 레지스터 간의 데이터 이동</li>
</ul>
</li>
<li><strong>데이터 이동</strong>
<ul>
<li>I/O 명령어들</li>
</ul>
</li>
<li><strong>프로그램 제어</strong>
<ul>
<li>검사와 분기 명령어</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-6">원천/결과 오퍼랜드의 위치</h3>
<p>오퍼랜드가 존재할 수 있는 위치는 아래와 같다.</p>
<ul>
<li><strong>주기억장치 or 가상 기억장치</strong>
<ul>
<li>가상 기억장치: HDD 공간의 일부를 임시 Main Memory로 사용하는 것이다.</li>
</ul>
</li>
<li><strong>프로세서 레지스터</strong></li>
<li><strong>I/O 장치</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="operand-">한 명령어 내의 주소(Operand) 개수</h2>
<h3 id="section-7">주소 개수?</h3>
<ul>
<li>‘한 명령어 내의 주소의 개수’는 <strong>프로세서의 구조를 설명하는 방법 중의 하나</strong>이다.</li>
</ul>
<br/>
<h3 id="section-8">한 명령어에 필요한 주소의 종류</h3>
<ul>
<li>오퍼랜드의 참조를 위한 주소</li>
<li>연산 결과를 저장하기 위한 주소</li>
</ul>
<br/>
<h3 id="section-9">3-주소 체계: 한 명령어 내에 3개의 주소가 존재하는 경우</h3>
<ul>
<li>
<p>주소 개수에 따른 명령어를 확인하기 위해, 다음 프로그램(연산)을 처리한다고 가정하자.</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2027.png" alt="Untitled" /></p>
</li>
<li>
<p>처리과정</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2028.png" alt="Untitled" /></p>
<ul>
<li><strong>총 3개의 주소</strong>를 사용하여, 명령어를 구성하는 것을 확인할 수 있다.</li>
<li>임시 저장 공간인 T를 사용한다.</li>
<li>위 순서대로 명령어를 실행하면 위 프로그램(연산)을 수행할 수 있다.</li>
</ul>
</li>
<li>
<p>3-주소 체계 특징</p>
<ul>
<li><strong>상대적으로 긴 명령어 형식이 필요하다.</strong></li>
<li><strong>필요한 명령어 개수는 적지만, 각 명령어의 길이가 길다.</strong></li>
<li>별로 사용되지 않는 방식이다.</li>
</ul>
</li>
</ul>
<br/>
<p>이어서, 동일한 프로그램에 대해 2-주소, 1-주소 체계에서는 어떻게 처리되는지 확인해보자.</p>
<br/>
<h3 id="section-10">2-주소 체계: 한 명령어 내에 2개의 주소가 존재하는 경우</h3>
<ul>
<li>
<p>처리과정</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2029.png" alt="Untitled" /></p>
<ul>
<li><strong>총 2개의 주소</strong>를 사용하여, 명령어를 구성하는 것을 확인할 수 있다.</li>
</ul>
</li>
<li>
<p>2-주소 체계 특징</p>
<ul>
<li><strong>주소 하나가 ‘오퍼랜드의 주소’와 ‘결과의 주소’를 모두 지정한다.</strong>
<ul>
<li>Y : ‘오퍼랜드 주소(A)’ 지정, ‘결과의 주소(Y-B, Y/T)’ 지정
<ul>
<li><code>Y ← A</code> , <code>Y ← Y-B</code> , <code>Y ← Y/T</code></li>
</ul>
</li>
<li>T : 오퍼랜드 주소(D) 지정, 결과의 주소(T*E, T+C) 지정
<ul>
<li><code>T ← D</code> , <code>T ← T*E</code> , <code>T ← T+C</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>명령어의 길이가 줄어든다.</strong></li>
<li><strong>필요한 명령어의 개수가 많아지지만, 각 명령어의 길이가 짧다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">1-주소 체계: 한 명령어 내에 1개의 주소가 존재하는 경우</h3>
<ul>
<li>
<p>처리과정</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2030.png" alt="Untitled" /></p>
<ul>
<li><strong>총 1개의 주소</strong>를 사용하여, 명령어를 구성하는 것을 확인할 수 있다.</li>
</ul>
</li>
<li>
<p>1-주소 체계 특징</p>
<ul>
<li><strong>두번째 주소는 묵시적으로 사용한다.</strong>
<ul>
<li>즉, “두번째 주소 == AC(누산기)” 라고 가정하고 명령어를 수행한다.</li>
<li>대개 레지스터(누산기, AC)를 두번째 주소로 사용한다.</li>
</ul>
</li>
<li>초기 컴퓨터에서 흔히 사용되곤 했다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-12">0-주소 체계: 한 명령어 내에 주소가 없는 경우</h3>
<ul>
<li>
<p><strong>0-주소 체계는 스택을 사용한다.</strong></p>
</li>
<li>
<p>처리과정</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2031.png" alt="Untitled" /></p>
<ul>
<li>스택에 대해, 위 연산들을 수행하여 계산한다.</li>
</ul>
</li>
<li>
<p>0-주소 체계 특징</p>
<ul>
<li>모든 주소가 묵시적이다.</li>
<li><strong>스택을 사용한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">정리</h3>
<ul>
<li>
<p><strong>주소가 많을수록</strong></p>
<ul>
<li>명령어가 복잡해진다.</li>
<li>레지스터가 더 많이 필요하다.
<ul>
<li>임시 저장공간이 더 많이 필요하다.</li>
</ul>
</li>
<li>프로그램 당 명령어의 수가 적어진다.</li>
</ul>
</li>
<li>
<p><strong>주소가 적을수록</strong></p>
<ul>
<li>명령어가 덜 복잡해진다.</li>
<li>명령어 길이가 짧아진다.</li>
<li>프로그램 당 명령어의 수가 증가한다.</li>
<li>명령어의 인출/실행이 더 빨라진다.
<ul>
<li>명령어가 짧기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-14">명령어 세트 설계</h2>
<h3 id="section-15">명령어 세트 설계시 고려사항</h3>
<p>명령어 세트를 설계한다면, 아래와 같은 항목을 고려해야 한다. 이것들을 참고하여, 학습 Point를 잡자.</p>
<ul>
<li><strong>데이터 유형</strong></li>
<li><strong>연산의 종류</strong>
<ul>
<li>연산의 개수</li>
<li>연산의 기능</li>
<li>연산의 복잡도</li>
</ul>
</li>
<li><strong>명령어 형식</strong>
<ul>
<li>명령어의 길이</li>
<li>주소의 개수</li>
<li>각 필드의 크기</li>
</ul>
</li>
<li><strong>주소지정 방식</strong>
<ul>
<li>오퍼랜드의 주소가 지정되는 방식</li>
</ul>
</li>
<li><strong>레지스터</strong>
<ul>
<li>명령어에 의해, 참조될 레지스터의 개수</li>
<li>명령어에 의해, 참조될 레지스터의 용도</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-16">오퍼랜드 종류</h3>
<p>오퍼랜드의 종류는 아래와 같다. 즉, 아래 항목들이 명령어의 Operand 필드에 들어올 수 있는 값의 종류이다.</p>
<ul>
<li><strong>주소</strong>
<ul>
<li>값이 들어있는 공간의 주소</li>
</ul>
</li>
<li><strong>수</strong>
<ul>
<li>정수, 부동소수점 수</li>
</ul>
</li>
<li><strong>문자</strong>
<ul>
<li>ASCII 등</li>
</ul>
</li>
<li><strong>논리적인 데이터</strong>
<ul>
<li>비트</li>
<li>플래그 등</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-17">연산의 종류들</h2>
<h3 id="section-18">연산의 종류</h3>
<p>연산의 종류는 무엇이 있을까. 이는 아래와 같다.</p>
<ul>
<li><strong>데이터 전송</strong></li>
<li><strong>산술</strong></li>
<li><strong>논리</strong></li>
<li><strong>제어의 이동</strong></li>
<li><strong>변환</strong></li>
<li><strong>입출력</strong></li>
<li><strong>시스템 제어</strong></li>
</ul>
<p>이제부터 중요한 내용들에 대해, 상세히 설명하겠다.</p>
<br/>
<h3 id="section-19">연산: 데이터 전송</h3>
<ul>
<li>데이터 전송 명령어가 명시해야하는 사항
<ul>
<li>
<p><strong>근원지·목적지 오퍼랜드 위치</strong></p>
<ul>
<li>기억장치나 레지스터, 스택의 최상위 등의 위치를 말한다.</li>
</ul>
</li>
<li>
<p><strong>전송될 데이터의 길이</strong></p>
</li>
<li>
<p><strong>각 오퍼랜드의 주소지정 방식</strong></p>
<ul>
<li>주소를 어떤 방식으로 지정하는지 알아야 한다.</li>
</ul>
<blockquote>
<p>주소를 지정하는 방식은 아래에서 상세히 설명한다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>데이터 전송 과정 (프로세서 동작 과정)
<ul>
<li><strong>만약, 오퍼랜드의 근원지·목적지의 위치가 모두 레지스터인 경우</strong>
<ul>
<li>프로세서 내부에서 레지스터 간의 데이터 교환이 수행된다.</li>
</ul>
</li>
<li><strong>만약, 오퍼랜드의 근원지·목적지의 위치가 기억장치(Main Memory)인 경우</strong>
<ol>
<li>
<p>주소 지정 방식에 근거하여, 기억장치의 주소를 계산한다.</p>
<blockquote>
<p>다시 말하지만, 주소 지정 방식에 대한 상세한 내용은 나중에 설명하겠다.</p>
</blockquote>
</li>
<li>
<p>만약 주소가 가상 기억장치를 참조한다면, 가상 주소를 실제 기억장치 주소로 변환한다.</p>
</li>
<li>
<p>주소 지정된 항목이 캐시에 있는지 확인한다.</p>
</li>
<li>
<p>캐시에 없다면, 기억장치 모듈로 명령(데이터 전송 명령)을 보낸다.</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-20">연산: 산술</h3>
<ul>
<li>
<p>산술 종류</p>
<ul>
<li><strong>덧셈</strong></li>
<li><strong>뺄셈</strong></li>
<li><strong>곱셈</strong></li>
<li><strong>나눗셈</strong></li>
</ul>
</li>
<li>
<p>단일 오퍼랜드 연산 종류</p>
<ul>
<li><strong>절대화</strong>
<ul>
<li>|a|</li>
</ul>
</li>
<li><strong>증가</strong>
<ul>
<li>a++</li>
</ul>
</li>
<li><strong>감소</strong>
<ul>
<li>a–</li>
</ul>
</li>
<li><strong>음수화</strong>
<ul>
<li>-a</li>
</ul>
</li>
</ul>
</li>
<li>
<p>‘프로세서의 ALU’에서 산술 연산을 수행한다.</p>
</li>
<li>
<p><strong>산술 연산을 위해 “ALU ↔ Main Memory 간 데이터를 이동시키는 것”까지, 산술연산에 포함된다.</strong></p>
</li>
</ul>
<br/>
<h3 id="section-21">연산: 논리</h3>
<ul>
<li>
<p>논리 연산은 비트를 조작하는 연산을 한다.</p>
</li>
<li>
<p>논리 연산 종류</p>
<ul>
<li><strong>AND</strong></li>
<li><strong>OR</strong></li>
<li><strong>NOT</strong></li>
</ul>
</li>
<li>
<p>기본적인 논리 연산들</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2032.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-22">시프트와 회전 연산</h3>
<ul>
<li>
<p>시프트 연산 종류</p>
<ul>
<li>
<p><strong>논리적 시프트</strong></p>
<ul>
<li>모든 비트를 옮긴다.</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2033.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>산술적 시프트</strong></p>
<ul>
<li>부호 비트는 유지한채로 옮긴다.</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2034.png" alt="Untitled" /></p>
</li>
</ul>
</li>
<li>
<p><strong>회전 연산</strong></p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2035.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-23">논리적 시프트의 사용</h3>
<ul>
<li>Main Memory의 <strong>한 Word가 두개의 문자를 저장</strong>한다면, 이것을 구분하기 위해 논리적 시프트가 사용될 수 있다.</li>
<li>예시를 통해 알아보자.</li>
</ul>
<br/>
<ul>
<li>
<p>문제</p>
<ul>
<li>
<p>각 기억장치 Word의 길이 : 16비트</p>
</li>
<li>
<p>한 Word에 두 개의 문자를 저장한다.</p>
<ul>
<li>즉, 하나의 문자는 8비트이다.</li>
</ul>
<blockquote>
<p>실제로 ASCII 체계에서 1Byte (8 bit)를 하나의 문자로 설정한다.</p>
</blockquote>
</li>
<li>
<p>이 두 개의 문자를 구분하여 출력해보자.</p>
</li>
</ul>
</li>
<li>
<p><strong>좌측 문자를 출력하는 절차: 논리적 우측 시프트</strong></p>
<ol>
<li>해당 Word를 레지스터에 적재한다.</li>
<li>우측으로 8번 시프트한다.</li>
<li>I/O를 수행한다. I/O 모듈이 하위 8비트를 읽는다.</li>
</ol>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2036.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>우측 문자를 출력하는 절차: AND 논리 연산</strong></p>
<ol>
<li>해당 Word를 레지스터에 적재한다.</li>
<li>00000000 11111111 와 AND 연산을 수행한다. (좌측 문자를 제거한다.)</li>
<li>I/O 를 수행한다.</li>
</ol>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2037.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-24">산술적 시프트의 사용</h3>
<ul>
<li>숫자에 곱셈을 해야할 때, 사용할 수 있다.</li>
<li>비트 연산은 상당히 빠르므로, 계산시 유용하게 사용될 수 있다.</li>
<li><strong>산술적 좌측 시프트</strong>
<ul>
<li>곱하기 2와 같다.</li>
<li>예시
<ul>
<li>8 = 00001000</li>
<li>00001000 에 대해, 좌측 시프트 1번 ⇒ 00010000 = 16</li>
</ul>
</li>
</ul>
</li>
<li><strong>산술적 우측 시프트</strong>
<ul>
<li>나누기 2와 같다.</li>
<li>예시
<ul>
<li>8 = 00001000</li>
<li>00001000 에 대해, 우측 시프트 1번 ⇒ 00000100 = 4</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-25">연산: 제어의 이동</h3>
<ul>
<li>
<p><strong>분기</strong></p>
<ul>
<li>분기를 통해, 제어를 이동시킨다.</li>
</ul>
</li>
<li>
<p>분기의 종류</p>
<ul>
<li><strong>무조건 분기</strong> : 조건없이 항상 분기된다.
<ul>
<li><strong>BR X</strong> : 위치 X로 분기하라</li>
</ul>
</li>
<li><strong>조건 분기</strong> : 조건에 따라, 분기된다.
<ul>
<li><strong>BRP X</strong> : 결과가 양수면, 위치 X로 분기하라.</li>
<li><strong>BRN X</strong> : 결과가 음수면, 위치 X로 분기하라.</li>
<li><strong>BRZ X</strong> : 결과가 0이면, 위치 X로 분기하라.</li>
<li><strong>BRO X</strong> : 오버플로우가 발생하면, 위치 X로 분기하라.</li>
<li><strong>BRE R1, R2, X</strong> : R1의 내용과 R2의 내용이 일치하면, 위치 X로 분기하라.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>분기 예시</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2038.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="skip">연산: Skip</h3>
<ul>
<li>
<p>하나의 명령어를 건너뛰게 한다.</p>
</li>
<li>
<p><strong>건너뛸 때, PC(Program Counter)를 업데이트해야 한다.</strong></p>
<ul>
<li><strong>”‘다음 명령어의 주소’에 ‘하나의 명령어의 길이’를 더한 값”으로 업데이트한다.</strong></li>
<li><strong>하나의 명령어의 길이 = I (대문자 i)</strong></li>
<li>즉, <strong>PC ← PC + I</strong> 으로 업데이트해야 한다.</li>
</ul>
</li>
<li>
<p>예시</p>
<ul>
<li>ISZ: Increment and Skip if Zero
<ul>
<li>특정 값에 1을 더하고 결과가 0이라면, 바로 아래 명령어를 Skip하라.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2039.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-26">주소지정</h2>
<h3 id="section-27">다양한 주소 지정 방식을 사용하는 이유</h3>
<ul>
<li><strong>오퍼랜드의 주소 길이가 액세스 가능한 기억장치의 크기를 결정한다.</strong>
<ul>
<li>하지만, 전형적인 명령어 형식에서는 짧은 길이의 주소 필드를 사용한다.</li>
</ul>
</li>
<li><strong>따라서 보다 큰 주기억장치 또는 가상기억장치 영역을 사용하기 위해서, 다양한 주소 지정 방식을 사용한다.</strong></li>
</ul>
<br/>
<h3 id="point">주소지정 기법에서의 고려사항 (학습 Point)</h3>
<ul>
<li>‘주소지정 영역’과 ‘주소지정 유연성’ 간의 적절한 조절</li>
<li>‘기억장치 참조의 횟수’와 ‘주소 계산의 복잡성’</li>
</ul>
<h3 id="section-28">일반적인 주소지정 방식</h3>
<ul>
<li><strong>즉시</strong></li>
<li><strong>직접</strong></li>
<li><strong>간접</strong></li>
<li><strong>레지스터</strong></li>
<li><strong>레지스터 간접</strong></li>
<li><strong>변위</strong></li>
<li><strong>스택</strong></li>
</ul>
<p>지금부터 하나씩 살펴보자.</p>
<br/>
<h3 id="section-29">주소지정 방식: 즉시 주소지정</h3>
<ul>
<li>
<p><strong>오퍼랜드가 명령어에 포함</strong>된다.</p>
<ul>
<li>즉, Operand 필드에 실제 값이 들어 있다.</li>
</ul>
</li>
<li>
<p>예시</p>
<ul>
<li>ADD 5</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2040.png" alt="Untitled" /></p>
</li>
<li>
<p>특징</p>
<ul>
<li>오퍼랜드를 인출하기 위해서, <strong>기억장치를 참조하지 않는다.</strong>
<ul>
<li>즉, ‘명령어 사이클’에서 하나의 ‘기억장치 사이클’ 또는 ‘캐시 사이클’을 줄일 수 있다.</li>
<li>명령어 사이클: 명령어인출 → 명령어해독 → 데이터인출 → 계산 → 결과저장
<ul>
<li><strong>여기서, 데이터인출 과정이 필요없다!</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>‘사용할 수 있는 수의 크기’가 ‘주소필드의 크기’로 제한된다.</strong>
<ul>
<li>왜냐하면, Operand로 값을 표현하기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-30">주소지정 방식: 직접 주소지정</h3>
<ul>
<li>
<p><strong>‘명령어의 주소 필드’가 ‘오퍼랜드의 유효 주소’를 갖는다.</strong></p>
<ul>
<li>유효 주소: 원하는 실제 값이 들어있는 곳의 실제 주소</li>
</ul>
</li>
<li>
<p><strong>EA (Effective Address, 유효주소) = Address Field (A, 오퍼랜드·주소 필드)</strong></p>
</li>
<li>
<p>예시</p>
<ul>
<li>ADD A</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2041.png" alt="Untitled" /></p>
</li>
<li>
<p>특징</p>
<ul>
<li><strong>기억장치를 한번만 참조한다.</strong>
<ul>
<li>유효 주소 계산을 위한 추가 작업이 없다.</li>
</ul>
</li>
<li><strong>주소 공간 제한</strong>
<ul>
<li>Operand 필드 크기에 따라, 액세스 가능한 공간의 크기(개수)가 제한되기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-31">주소지정 방식: 간접 주소지정</h3>
<ul>
<li>
<p><strong>‘주소 필드’는 ‘기억장치에 저장된 단어의 주소’를 가리킨다.</strong></p>
<ul>
<li>그리고 <strong>그 기억장치에 ‘오퍼랜드에 대한 주소 전체’를 저장</strong>한다.</li>
</ul>
<blockquote>
<p>‘pointer의 주소’를 주소필드에 담는다고 생각하면 쉽다.</p>
</blockquote>
</li>
<li>
<p><strong>EA = (A)</strong></p>
<ul>
<li>괄호: 간접</li>
</ul>
</li>
<li>
<p>예시</p>
<ul>
<li>ADD (A)</li>
</ul>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2042.png" alt="Untitled" /></p>
</li>
<li>
<p>실제 동작 방식</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2043.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>특징
<ul>
<li><strong>큰 주소 공간을 갖는다.</strong>
<ul>
<li>Operand 길이가 아닌, Word 길이에 대해 접근 가능한 주소 개수가 결정되기 때문이다.</li>
</ul>
</li>
<li><strong>두 번의 기억장치 참조가 필요하다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-32">주소지정 방식: 레지스터 주소지정</h3>
<ul>
<li>
<p>직접 주소지정과 유사하다.</p>
</li>
<li>
<p><strong>‘주소 필드’가 ‘레지스터’를 가리킨다.</strong></p>
<ul>
<li>주소 필드가 주기억장치 주소를 가리키지 않는다.</li>
</ul>
</li>
<li>
<p><strong>EA = R</strong></p>
<ul>
<li>R : 레지스터</li>
</ul>
</li>
<li>
<p>구조</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2044.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>특징
<ul>
<li><strong>명령어에서 주소 필드가 작아도 된다.</strong>
<ul>
<li>‘레지스터를 지정하는 주소 필드’는 3~5개의 비트를 가진다.</li>
<li>보통 사용 가능한 레지스터의 개수를 고려했을 때, 그 정도의 비트 수면 적당하다.</li>
</ul>
</li>
<li><strong>기억장치 액세스가 불필요하다.</strong>
<ul>
<li>따라서, 명령어 실행이 빨라진다.</li>
</ul>
</li>
<li><strong>주소 공간이 제한된다.</strong>
<ul>
<li>레지스터의 수가 제한적이기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-33">주소지정 방식: 레지스터 간접 주소지정</h3>
<ul>
<li>
<p>간접 주소지정 방식과 유사하다.</p>
</li>
<li>
<p><strong>EA = (R)</strong></p>
</li>
<li>
<p>구조</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2045.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>특징
<ul>
<li><strong>‘주소 필드에 의해 주소 공간이 제한되는 문제’를 그 필드가 ‘주소를 가지고 있는 단어의 위치’를 가리키도록 함으로써 해결한다.</strong></li>
<li><strong>간접 주소지정 방식보다 기억장치 액세스 횟수가 1회 더 작다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-34">주소지정 방식: 변위 주소지정</h3>
<ul>
<li>
<p><strong>‘직접 주소지정 + 레지스터 간접 주소지정’ 형태이다.</strong></p>
</li>
<li>
<p><strong>EA = A + (R)</strong></p>
<ul>
<li>A : 직접</li>
<li>(R) : 레지스터 간접</li>
</ul>
</li>
<li>
<p><strong>총 두개의 주소 필드를 가지며, 둘 중 하나는 명시적이다.</strong></p>
<ul>
<li>A = 기준 (base value)
<ul>
<li>A: 명시적</li>
</ul>
</li>
<li>R = 기준으로부터 얼마나 떨어졌는가에 대한 정보
<ul>
<li>R: 묵시적</li>
</ul>
</li>
</ul>
<blockquote>
<p>A와 R의 역할이 서로 변경될 수 있다.</p>
</blockquote>
</li>
<li>
<p>구조</p>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2046.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li>변위 주소지정 방식의 종류: 사용하는 레지스터에 따른 종류
<ul>
<li>
<p><strong>PC 상대 주소지정</strong></p>
<ul>
<li><strong>PC를 레지스터로 사용한다.</strong></li>
<li><strong>EA = A + (PC)</strong>
<ul>
<li>A: 변위값 (얼마나 떨어져있는가?) (A: 명령어 내의 Operand 필드)</li>
<li>PC: 기준주소</li>
</ul>
</li>
<li>대부분의 기억장치 참조들이 현재 실행되고 있는 명령어에 인접시, 상대 주소지정 방식을 이용하면 명령어의 주소 비트를 절약할 수 있다.</li>
<li>적용 예시) 분기 명령어</li>
</ul>
</li>
<li>
<p><strong>베이스-레지스터 주소지정</strong></p>
<ul>
<li><strong>베이스 레지스터를 레지스터로 사용한다.</strong></li>
<li><strong>EA = A + (BR)</strong>
<ul>
<li>A: 변위값 (얼마나 떨어져있는가?) (A: 명령어 내의 Operand 필드)</li>
<li>BR: 기준주소</li>
</ul>
</li>
<li>적용 예시) 프로그램(데이터)의 위치 이동</li>
</ul>
</li>
<li>
<p><strong>인덱스 주소지정</strong></p>
<ul>
<li><strong>인덱스 레지스터를 레지스터로 사용한다.</strong></li>
<li><strong>EA = A + R</strong>
<ul>
<li>A: 기준주소</li>
<li>R: 변위값 (얼마나 떨어져있는가?)</li>
<li>이때, 레지스터 참조는 명시적일 수도 있고, 묵시적일 수도 있다.</li>
</ul>
</li>
<li>명령어의 주소 필드가 기억장치 주소로 사용되므로, 베이스 레지스터 명령어에 비하여 주소 필드의 비트수가 더 많아진다.</li>
<li>적용 예시) 배열 데이터 연산 (반복 연산에 유리하다.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-35">주소지정 방식: 스택 주소지정</h3>
<ul>
<li><strong>오퍼랜드는 스택의 최상위에 위치한다.</strong>
<ul>
<li>묵시적인 주소지정의 한 형태이다.
<ul>
<li>왜냐하면, 스택의 최상위부터 참조하기 때문이다.</li>
</ul>
</li>
</ul>
</li>
<li>예시
<ul>
<li>ADD : 스택에서 pop 2번하여 나온 값들을 더한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-36">정리</h3>
<p><img src="/assets/img/2021-11-18-ComputerStructure_InstructionSet/Untitled%2047.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-37">명령어 형식들</h2>
<h3 id="section-38">명령어 형식?</h3>
<ul>
<li>명령어 형식은 <strong>연산코드와 한 개 이상의 오퍼랜드를 포함</strong>한다.</li>
<li>대부분의 명령어 세트에서 <strong>하나 이상의 명령어 형식들이 사용</strong>된다.</li>
</ul>
<br/>
<h3 id="section-39">명령어 길이</h3>
<ul>
<li>명령어 길이에 영향을 주는 요소들
<ul>
<li><strong>기억장치의 용량</strong>
<ul>
<li>기억장치의 용량만큼을 오퍼랜드에 표현해야 하기 때문이다.</li>
</ul>
</li>
<li><strong>기억장치의 구조</strong>
<ul>
<li>사용하는 기억장치가 Register인지, Main Memory인지</li>
</ul>
</li>
<li><strong>버스의 구조</strong></li>
<li><strong>프로세서의 복잡도 및 속도</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>‘명령어의 종류’와 ‘공간 절약’ 관계</strong></p>
<ul>
<li><strong>연산 코드의 종류는 프로그램 길이에 반비례한다.</strong>
<ul>
<li>연산코드 종류 ↑ , 프로그램 길이 ↓</li>
<li>연산코드의 종류가 적으면, 프로그램적으로 처리해야 하는 것이 많기 때문이다.</li>
</ul>
</li>
<li><strong>오퍼랜드 개수는 프로그램 길이에 반비례한다.</strong>
<ul>
<li>오퍼랜드 개수 ↑ , 프로그램 길이 ↓</li>
<li>하나의 명령어에서 갖는 오퍼랜드 개수가 많으면, 자연스럽게 프로그램의 길이는 작아진다.</li>
</ul>
</li>
<li><strong>주소 지정방식이 다양하면, 다중 분기에 유연성을 제공한다.</strong></li>
<li><strong>주기억장치 및 가상 기억장치의 증가는 명령어 길이의 증가를 초래한다.</strong></li>
</ul>
<blockquote>
<p>즉, ‘명령어의 길이 ↑’면 ‘프로그램 길이↓’</p>
</blockquote>
</li>
<li>
<p>명령어 길이는 기억장치 전송폭(데이터 버스폭)과 같거나, 다른 쪽의 배수가 되어야 한다.</p>
</li>
</ul>
<br/>
<h3 id="section-40">비트할당</h3>
<ul>
<li>‘연산 코드의 종류’와 ‘주소지정 능력’ 관계
<ul>
<li><strong>명령어 길이가 고정되어 있다면, opcode와 operand 크기 간에 조정이 필요하다.</strong></li>
</ul>
</li>
<li>주소지정 비트(operand용 비트)의 용도를 결정하는 요소
<ul>
<li>주소지정 방식의 수</li>
<li>오퍼랜드의 수</li>
<li>레지스터 대 기억장치</li>
<li>레지스터 세트의 수</li>
<li>주소 영역</li>
<li>주소의 세분화</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-41">가변길이 명령어</h3>
<ul>
<li>
<p>가변길이 명령어란?</p>
<ul>
<li>하나의 명령어 세트안에 다양한 길이의 명령어가 존재하는 것</li>
</ul>
</li>
<li>
<p>장점</p>
<ul>
<li>길이가 서로 다른 더 많은 종류의 연산 코드를 쉽게 제공한다.</li>
<li>주소 지정이 융통성있게 된다.</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>프로세서의 복잡도가 증가한다.</li>
</ul>
</li>
<li>
<p>RISC와 수퍼스칼라 구조의 기계들은 성능 개선을 위해 <strong>고정-길이 명령어</strong>를 사용한다.</p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="risc-">RISC 구조</h2>
<h3 id="cisc--">CISC 구조의 특징</h3>
<ul>
<li>명령어의 길이가 가변적이다.</li>
<li>여러 복잡한 형태의 주소 모드가 존재한다.</li>
<li>비교적 <strong>적은 수의 일반 목적용 레지스터 개수</strong>가 존재한다.</li>
</ul>
<br/>
<h3 id="risc--">RISC 구조의 특징</h3>
<ul>
<li><strong>기계 사이클당 하나의 기계어를 실행한다.</strong>
<ul>
<li>기계 사이클이란
<ul>
<li>아래 3가지 동작을 하는데 소요되는 시간
<ul>
<li>레지스터로부터 2개의 오퍼랜드 인출</li>
<li>ALU 동작</li>
<li>결과를 레지스터에 저장</li>
</ul>
</li>
</ul>
</li>
<li>즉, RISC는 “명령어인출·명령어해독·데이터인출·데이터실행·결과저장과 같이 M.M를 기반으로 동작하는 것”을 <strong>CPU 내에서 한번에 처리</strong>한다.</li>
</ul>
</li>
<li><strong>대부분의 연산이 레지스터들을 통해 수행된다.</strong>
<ul>
<li>기계장치를 액세스하는 동작은 LOAD, STORE 명령어로만 구성되어야 한다.</li>
<li>따라서 RISK는 명령어가 더 단순하다.</li>
</ul>
</li>
<li><strong>비교적 많은 수의 일반 목적용 레지스터가 필요하다.</strong></li>
<li><strong>간단한 주소 지정 방식을 갖는다.</strong></li>
<li><strong>간단한 명령어 세트를 갖는다.</strong></li>
<li><strong>명령어 파이프라인의 최적화</strong></li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 최정열 교수님 (2021)</li>
    <li>William Stalling, 『컴퓨터시스템구조론(10판)』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET