I"B=<p><br/><br/></p>
<h1 id="section">컴퓨터 기억장치 시스템 개요</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">메모리의 역할</h3>
<ul>
<li>프로그램 명령이나 데이터를 저장한다.</li>
<li>프로그램은 메모리에서 활동 중이다.
<ul>
<li>따라서, 메인 메모리가 클수록 동시에 많은 프로그램을 실행할 수 있다.</li>
<li>메인 메모리: RAM, Cache</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">메인 메모리의 수행작업</h3>
<ul>
<li>현재 실행 중인 프로그램들을 저장한다.</li>
<li>메모리의 각 영역은 서로 침범하지 못하도록, 시스템 소프트웨어 프로그래머가 정한다.</li>
</ul>
<br/>
<h3 id="section-4">기억장치의 계층구조</h3>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2033.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-5">기억장치의 주요 특성</h2>
<h3 id="section-6">주요 특성들</h3>
<ul>
<li><strong>Location (위치)</strong></li>
<li><strong>Capacity (용량)</strong></li>
<li><strong>Unit of Transfer (전송 단위)</strong></li>
<li><strong>Access Method (데이터 접근 방식)</strong></li>
<li><strong>Performance (성능)</strong></li>
<li><strong>Physical Type (물리적 유형에 따른 기억장치)</strong></li>
<li><strong>Physical Characteristics (기억장치의 물리적인 특징)</strong></li>
</ul>
<br/>
<h3 id="location-">Location: 위치</h3>
<ul>
<li>내부기억 장치</li>
<li>외부기억 장치</li>
</ul>
<p>위 두가지 위치로 기억장치가 구분된다.</p>
<br/>
<h3 id="capacity-">Capacity: 용량</h3>
<ul>
<li>
<p>내부 기억장치의 용량</p>
<ul>
<li><strong>바이트</strong> 또는 <strong>단어</strong> 단위로 표현한다.</li>
<li>일반적인 단어의 길이: 8, 16, 32 비트</li>
<li>단어 = 메모리의 폭(너비)</li>
</ul>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2034.png" alt="Untitled" /></p>
<blockquote>
<p>버스의 대역폭 역시 단어의 길이만큼 넓어한다.</p>
</blockquote>
</li>
<li>
<p>외부 기억장치의 용량</p>
<ul>
<li>일반적으로 <strong>바이트 단위</strong>로 표현한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="unit-of-transfer--">Unit of Transfer: 전송 단위</h3>
<ul>
<li>내부 기억장치에서의 전송 단위
<ul>
<li>기억장치 모듈로의 <strong>데이터 선들의 개수(Data Bus)</strong> 와 같다.</li>
<li>주기억장치에 있어서, <strong>전송 단위는 한번에 읽고 쓸수있는 비트의 수</strong>이다.</li>
</ul>
</li>
<li>외부 기억장치에서의 전송 단위
<ul>
<li>단어보다 훨씬 더 큰 단위인 <strong>블록단위</strong>를 사용한다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2035.png" alt="Untitled" /></p>
<ul>
<li>
<p><strong>단어 (word)</strong></p>
<ul>
<li>기억 장치 조직의 단위</li>
<li>단어의 길이
<ul>
<li>일반적으로 수를 표현하기 위해 사용되는 비트의 수</li>
<li>명령어의 길이</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>주소지정 단위</strong></p>
<ul>
<li>주소의 길이 A비트와 주소지정 단위의 수 N간의 관계</li>
<li><img src="https://latex.codecogs.com/svg.image?2%5EA=N" alt="2^A=N" />
<ul>
<li>A : 주소의 길이</li>
<li>N : 단어의 개수</li>
</ul>
</li>
<li>예시
<ul>
<li>단어의 개수 = 1024 일때의 단어의 길이(A) 는?</li>
<li><img src="https://latex.codecogs.com/svg.image?2%5E%7BA%7D=1024" alt="2^{A}=1024" /> 이므로, <img src="https://latex.codecogs.com/svg.image?A=10" alt="A=10" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="access-method---">Access Method: 데이터 접근 방식</h3>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2048.png" alt="Untitled" /></p>
<br/>
<h3 id="performance-">Performance: 성능</h3>
<ul>
<li>
<p><strong>액세스 시간 성능</strong></p>
<ul>
<li>임의 액세스 기억장치 (Cache, M.M 등의 반도체 장치)
<ul>
<li>액세스 시간: 주소가 기억장치에 도착하는 순간부터 저장되거나 읽혀지는 순간까지의 시간</li>
<li><strong>액세스 시간이 모든 기억장소에 대해서 동일하다.</strong></li>
</ul>
</li>
<li>비임의 액세스 기억장치 (HDD, Tape 등)
<ul>
<li>
<p>액세스 시간: 읽기-쓰기 매커니즘을 원하는 위치로 이동하는데 걸리는 시간</p>
</li>
<li>
<p><strong>데이터가 저장되어 있는 위치에 따라 다르다.</strong></p>
</li>
<li>
<p>예시(HDD)</p>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2036.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>기억장치 사이클 시간</p>
<ul>
<li>주로 임의 액세스 기억장치에 적용된다.</li>
<li>액세스 시간과 다음 액세스를 시작하기 위해 요구되는 동작에 걸리는 <strong>추가적인 시간을 합한 시간</strong></li>
</ul>
</li>
<li>
<p><strong>전송률 성능</strong></p>
<ul>
<li>데이터가 기억장치로 전송되어 들어가거나 나오는 비율</li>
<li>임의 액세스 기억장치
<ul>
<li><img src="https://latex.codecogs.com/svg.image?TransferRate=%5Cfrac%7BDataBusBandwidth%7D%7BCyclingTime%7D" alt="Transfer_Rate=\frac{DataBus_Bandwidth}{Cycling_Time}" /></li>
</ul>
</li>
<li>비임의 액세스 기억장치
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T_N=T_A+%5Cfrac%7Bn%7D%7BR%7D" alt="T_N = T_A + \frac{n}{R}" /></li>
<li>전송율 = <img src="https://latex.codecogs.com/svg.image?%5Cfrac%7B1%7D%7BT_N%7D" alt="\frac{1}{T_N}" /></li>
<li><img src="https://latex.codecogs.com/svg.image?T_N" alt="T_N" /> : N개의 비트들을 읽거나 쓰는데 걸리는 평균 시간</li>
<li><img src="https://latex.codecogs.com/svg.image?T_A" alt="T_A" /> : 평균 액세스 시간</li>
<li><img src="https://latex.codecogs.com/svg.image?n" alt="n" /> : 비트들의 수</li>
<li><img src="https://latex.codecogs.com/svg.image?R" alt="R" /> : 전송률, 초당 비트수</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="strongphysical-typestrong----"><strong>Physical Type:</strong> 물리적 유형에 따른 기억장치</h3>
<ul>
<li>반도체
<ul>
<li>RAM, Cache, Register, SSD</li>
</ul>
</li>
<li>자기
<ul>
<li>Disk, Tape</li>
</ul>
</li>
<li>광
<ul>
<li>CD, DVD</li>
</ul>
</li>
</ul>
<br/>
<h3 id="strongphysical-characteristics---strong"><strong>Physical Characteristics: 기억장치의 물리적인 특징</strong></h3>
<ul>
<li>휘발성 여부</li>
<li>삭제 가능 여부
<ul>
<li>ROM의 경우, 데이터 삭제가 불가능하다.</li>
</ul>
</li>
</ul>
<p><br/><br/><br/></p>
<h1 id="section-7">기억장치 시스템</h1>
<h2 id="section-8">기억장치 설계시 고려사항</h2>
<h3 id="section-9">주요 고려사항</h3>
<ul>
<li>얼마나 큰가</li>
<li>얼마나 빠른가</li>
<li>가격은 얼마나 비싼가</li>
</ul>
<br/>
<h3 id="tradeoff">기억장치 주요 특성들 간의 Tradeoff</h3>
<ul>
<li>액세스 속도 ↑ , 비트당 가격 ↑</li>
<li>용량 ↑ , 비트당 가격 ↓</li>
<li>용량 ↑ , 액세스 속도 ↓</li>
</ul>
<p>이러한 트레이드오프 관계를 해결하기 위해 <strong>계층적인 기억장치</strong>를 사용한다.</p>
<br/>
<h3 id="section-10">계층적인 기억장치</h3>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2037.png" alt="Untitled" /></p>
<br/>
<h3 id="section-11">기억장치 종류와 액세스 시간</h3>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2038.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-12">기억장치의 효용성</h2>
<h3 id="section-13">효용성 계산 예시 문제</h3>
<ul>
<li>문제
<ul>
<li>프로세서가 두 레벨의 기억장치를 액세스한다고 가정하자.</li>
<li>레벨 1은 1,000개의 단어를 저장하며 액세스 시간은 0.01ms이다.</li>
<li>레벨 2는 100,000 개의 단어를 저장하며 액세스 시간은 0.1ms이다.</li>
<li>만약 액세스될 단어가 레벨 1에 있다면, 프로세서는 그 단어를 직접 액세스한다.</li>
<li>만약 액세스될 단어가 레벨 2에 있다면, 먼저 레벨 1로 이동된 다음에 프로세서에 의해 액세스된다.</li>
<li>이때 기억장치 액세스의 95%가 레벨 1에서 발견된다고 가정할 때, 그 단어를 액세스하는 데 걸리는 평균 시간은?</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>해결</p>
<ul>
<li>해당 단어 평균 접근 시간 = (레벨1에 있을 확률 * 레벨1의 액세스 시간) + (레벨2에 있을 확률 * (레벨1의 액세스 시간 + 레벨2의 액세스 시간))</li>
<li>해당 단어 평균 접근 시간<img src="https://latex.codecogs.com/svg.image?=(0.95*0.01ms)+(0.05*(0.01ms+0.1ms))=0.15ms" alt="R" /></li>
</ul>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2039.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h2 id="section-14">기억장치의 성능 개선 원리</h2>
<h3 id="section-15">참조의 지역성</h3>
<ul>
<li>프로그램 동작의 특성
<ul>
<li>
<p>대부분의 경우 순차적으로 프로그램이 진행되므로, 바로 전에 인출된 마지막 명령어의 다음 명령어가 인출된다.</p>
<blockquote>
<p>프로그램이 실행되는 동안 순차적이지 않은 분기/호출 명령은 작은 부분을 차지한다.</p>
</blockquote>
</li>
<li>
<p>짧은 시간 동안에 몇 개의 프로시저(함수)들로 국한된 명령어들을 참조한다.</p>
<ul>
<li>즉, 한정된 수의 프로시저(함수)를 계속 호출하면서 실행하는 경향이 있다.</li>
</ul>
</li>
<li>
<p>대부분의 반복 구조는 여러 번 반복되는 비교적 적은 수의 명령어들로 구성되어 있다.</p>
</li>
<li>
<p>대부분의 프로그램들에는 “배열 또는 레코드와 같은 데이터 구조를 처리하는 계산”이 많이 포함된다.</p>
<ul>
<li>즉, 서로 인접한 데이터에 대해 처리하는 로직이 많이 존재한다.</li>
</ul>
</li>
<li>
<p><strong>이러한 특징을 참조의 지역성이라고 한다.</strong></p>
</li>
<li>
<p><strong>참조의 지역성을 최대한으로 활용하면 Cache에 원하는 Data나 명령어가 존재할 확률을 높일 수 있다.</strong></p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>참조의 지역성을 고려한 Cache와 Main Memory 동작 방식</p>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2040.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-16">공간적 지역성</h3>
<ul>
<li>공간적 지역성이란?
<ul>
<li>실행들이 특정 클러스터의 기억 장소들에 대하여 이루어지는 경향</li>
<li>(프로세스가 명령어들을 순차적으로 액세스하는 경향)</li>
<li>즉, 명령어 A 실행시 물리적으로 인근에 있는 명령어를 다음에 실행할 가능성이 높다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-17">시간적 지역성</h3>
<ul>
<li>시간적 지역성이란?
<ul>
<li>프로세서가 최근에 사용되었던 기억 장소들을 액세스 하는 경향</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-18">기억장치 동작과 성능</h2>
<h3 id="section-19">기억장치의 동작</h3>
<ul>
<li>상위 단계 기억장치(M1)은 하위 단계 기억장치(M2)보다 용량이 더 작고, 빠르고, 비트당 가격이 비싸다.</li>
<li>M1은 용량이 큰 M2의 내용의 일부분을 저장하는 임시 저장장치로 사용된다.</li>
<li>먼저 M1에 있는 항목을 액세스하려고 시도하되, 성공(Hit, 적중률)하면 액세스가 이루어진다.</li>
<li>성공하지 못하면, 기억장치의 한 블록이 M2에서 M1으로 복사되며, 그런 다음 액세스는 M1을 경유하여 이루어진다.</li>
</ul>
<blockquote>
<p>Hit: M1(캐시)에 원하는 데이터나 명령어가 존재하는 경우</p>
</blockquote>
<br/>
<h3 id="section-20">기억장치의 성능</h3>
<ul>
<li><strong>비용적 성능</strong>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?C_s=%5Cfrac%7BC_1S_1+C_2S_2%7D%7BS_1+S_2%7D" alt="C_S=\frac{C_1S_1+C_2S_2}{S_1+S_2}" />
<ul>
<li><img src="https://latex.codecogs.com/svg.image?C_S" alt="C_S" /> : 결합된 2단계 기억장치의 비트당 평균 비용</li>
<li><img src="https://latex.codecogs.com/svg.image?C_1" alt="C_1" /> : 상위 단계 기억장치 M1의 비트당 평균 비용</li>
<li><img src="https://latex.codecogs.com/svg.image?C_2" alt="C_2" /> : 하위 단계 기억장치 M2의 비트당 평균 비용</li>
<li><img src="https://latex.codecogs.com/svg.image?S_1" alt="S_1" /> : M1의 크기</li>
<li><img src="https://latex.codecogs.com/svg.image?S_2" alt="S_2" /> : M2의 크기</li>
</ul>
</li>
<li><img src="https://latex.codecogs.com/svg.image?C_S" alt="C_S" /> 와 <img src="https://latex.codecogs.com/svg.image?C_2" alt="C_2" /> 가 근접하는 것이 바람직하다.</li>
<li><img src="https://latex.codecogs.com/svg.image?C_1%3E%3EC_2" alt="C_1&gt;&gt;C_2" /> 일때는, <img src="https://latex.codecogs.com/svg.image?S_1%3C%3CS_2" alt="S_1&lt;&lt;S_2" /> 가 되어야 한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>액세스 시간 ($T_s$)</strong>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T_s=H*T_1+(1-H)*(T_1+T_2)=T_1+(1-H)*T_2" alt="T_s=HT_1+(1-H)(T_1+T_2)=T_1+(1-H)*T_2" />
<ul>
<li><img src="https://latex.codecogs.com/svg.image?T_1" alt="T_1" /> : M1의 액세스 시간</li>
<li><img src="https://latex.codecogs.com/svg.image?T_2" alt="T_2" /> : M2의 액세스 시간</li>
<li><img src="https://latex.codecogs.com/svg.image?H" alt="H" /> : 적중률(Hit, 참조가 M1에서 발견되는 비율)</li>
</ul>
</li>
<li><img src="https://latex.codecogs.com/svg.image?T_S" alt="T_S" /> 와 <img src="https://latex.codecogs.com/svg.image?T_1" alt="T_1" /> 가 근접하는 것이 바람직하다.</li>
<li><img src="https://latex.codecogs.com/svg.image?T_1%3C%3CT_2" alt="T_1&lt;&lt;T_2" /> 일때는 적중률이 1에 가까워야 한다.</li>
<li>M1의 최적 사이즈 조건
<ul>
<li>가격을 낮추기 위해서는 M1의 용량이 작아야 하고, 적중률과 성능을 개선하기 위해서는 용량이 커야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>액세스 효율</strong>
<ul>
<li>액세스 효율은 평균 액세스 시간(<img src="https://latex.codecogs.com/svg.image?T_S" alt="T_S" />)이 M1의 액세스 시간(<img src="https://latex.codecogs.com/svg.image?T_1" alt="T_1" />)에 얼마나 가까운지를 측정하는 척도이다.</li>
<li><img src="https://latex.codecogs.com/svg.image?%5Cfrac%7BT_1%7D%7BT_S%7D=%5Cfrac%7B1%7D%7B1+(1-H)%5Cfrac%7BT_2%7D%7BT_1%7D%7D" alt="\frac{T_1}{T_S}=\frac{1}{1+(1-H)\frac{T_2}{T_1}}" /></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>지역성이 적중률에 미치는 영향</strong>
<ul>
<li>
<p>지역성이 강하다면 <strong>상위 단계 기억장치의 크기가 비교적 작아도 높은 적중률</strong>을 얻을 수 있다.</p>
<ul>
<li>캐시의 크기가 비교적 작더라도 주기억장치의 크기에 상관없이 0.75 이상의 적중률을 얻을 수 있다.</li>
</ul>
<p><img src="/assets/img/2021-09-30-ComputerStructure_Memory/Untitled%2041.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 최정열 교수님 (2021)</li>
    <li>William Stalling, 『컴퓨터시스템구조론(10판)』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET