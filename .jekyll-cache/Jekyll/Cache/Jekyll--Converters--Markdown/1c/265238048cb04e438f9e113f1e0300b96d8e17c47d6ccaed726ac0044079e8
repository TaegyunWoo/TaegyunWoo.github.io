I"<p><br/><br/></p>
<h1 id="section">다룰 내용</h1>
<p>이번 포스팅에서 다룰 내용은 아래와 같다.</p>
<ul>
<li><strong>프록시, 즉시로딩, 지연로딩</strong>
<ul>
<li>프록시를 사용하면 연관된 객체를 처음부터 DB에서 조회하지 않는다.</li>
<li>실제 사용하는 시점에 DB에서 조회할 수 있다.</li>
</ul>
</li>
</ul>
<p>하나씩 알아보자.</p>
<p><br/><br/><br/></p>
<h1 id="section-1">프록시</h1>
<h2 id="section-2">프록시가 필요한 이유</h2>
<h3 id="section-3">배경</h3>
<ul>
<li><strong>특정 엔티티를 조회할 때, 이와 연관된 엔티티들이 항상 사용되는 것은 아니다.</strong>
<ul>
<li>예시) 회원 엔티티 조회 시, 이와 연관된 팀 엔티티는 비즈니스 로직에 따라 사용되지 않을 수 있다.</li>
<li>예시 코드를 통해 이 경우에 대해 자세히 알아보자.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-4">예시 코드: 연관된 엔티티를 사용하지 않는 경우</h3>
<ul>
<li>
<p>회원 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

	<span class="c1">//연관</span>
	<span class="nd">@ManyToOne</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>팀 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">//getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>비즈니스 로직 - 연관된 엔티티를 사용하는 로직</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">printUserAndTeam</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
	<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"회원이름: "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>

	<span class="c1">//이때, 연관된 엔티티 team이 실제로 사용된다.</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"팀이름: "</span> <span class="o">+</span> <span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>비즈니스 로직 - 연관된 엔티티를 사용하지 않는 로직</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">printUser</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"회원이름: "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>상세 설명
<ul>
<li>비즈니스 로직에 해당되는 메서드 <code>printUserAndTeam</code> 은 회원과 팀 이름을 출력한다.</li>
<li>비즈니스 로직에 해당되는 메서드 <code>printUser</code> 은 오직 회원 이름을 출력한다. (연관된 엔티티 Team을 사용하지 않는다.)</li>
<li><strong>회원 엔티티만을 사용하는 경우, <code>em.find()</code> 를 통해 회원과 연관된 팀 엔티티까지 DB에서 함께 조회하는 것은 비효율적이다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-5">프록시와 지연 로딩</h3>
<ul>
<li>위 예시의 문제를 극복하기 위해, <strong>JPA는 지연 로딩이라는 기능을 제공</strong>한다.
<ul>
<li><strong>지연 로딩: 엔티티가 실제로 사용될 때까지 DB조회를 지연하는 것</strong></li>
<li>지연 로딩 예시) <code>team.getName()</code> 를 호출했을 때, 그제서야 team 엔티티를 DB에서 조회한다.</li>
</ul>
</li>
<li><strong>프록시 객체를 통해, 지연 로딩을 사용할 수 있다.</strong>
<ul>
<li><strong>프록시 객체: 실제 엔티티 객체 대신 DB 조회를 지연할 수 있는 가짜 객체</strong></li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-6">프록시 기초</h2>
<h3 id="codeentitymanagerfindcode-"><code>EntityManager.find()</code> 메서드</h3>
<ul>
<li><code>EntityManager.find()</code> 메서드는 영속성 컨텍스트에 원하는 엔티티가 없으면, DB를 조회한다.</li>
<li><strong>이 메서드를 통해 엔티티를 직접 조회하면, 조회한 엔티티를 실제로 사용하든 사용하지 않든 DB를 조회한다.</strong></li>
</ul>
<br/>
<h3 id="codeentitymanagergetreferencecode-"><code>EntityManager.getReference()</code> 메서드</h3>
<ul>
<li>
<p><code>EntityManager.getReference()</code> 메서드는 <code>EntityManager.find()</code> 메서드와는 다르게, 엔티티를 실제로 사용하는 시점까지 DB 조회를 미룰 수 있게 해준다.</p>
</li>
<li>
<p>사용 예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>
</li>
<li>
<p><strong><code>EntityManager.getReference()</code> 메서드를 호출할 때, DB를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다!</strong></p>
<ul>
<li>대신에 해당 메서드는 DB 접근을 위임한 <strong>프록시 객체를 반환</strong>한다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2041.png" alt="Untitled" /></p>
<br/>
<h3 id="section-7">프록시의 구조</h3>
<ul>
<li><strong>프록시는 실제 클래스를 상속받아 만들어진다.</strong></li>
<li><strong>따라서, 겉모양은 실제 클래스와 같다.</strong></li>
</ul>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2042.png" alt="Untitled" /></p>
<br/>
<h3 id="section-8">프록시 객체의 초기화</h3>
<ul>
<li>
<p><strong>프록시 객체는 실제 사용될 때 DB를 조회해서 실제 엔티티 객체를 생성한다.</strong></p>
<ul>
<li>이것을 프록시 <strong>객체 초기화</strong>라고 한다.</li>
</ul>
</li>
<li>
<p>프록시 초기화 예제</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//MemberProxy를 실제 엔티티 대신 반환한다.</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"id1"</span><span class="o">);</span>

<span class="c1">//아래 코드 실행시, 프록시 초기화가 수행된다.</span>
<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</code></pre></div></div>
</li>
<li>
<p>그렇다면 프록시 클래스는 어떻게 작성되어있을까? 아래 코드는 프록시의 특징에 맞춰, 예상한 프록시 클래스 내용이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MemberProxy</span> <span class="kd">extends</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="c1">//실제 엔티티 조회시, 결과를 담는 필드 (참조)</span>
	<span class="nc">Member</span> <span class="n">target</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="c1">//오버라이딩된 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>

		<span class="c1">//만약 실제 엔티티가 조회된적 없다면: 프록시 초기화 진행</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 1. 프록시 초기화 요청</span>
			<span class="c1">// 2. DB 조회</span>
			<span class="c1">// 3. 실제 엔티티 생성 및 참조 보관</span>
		<span class="o">}</span>

		<span class="c1">//아래 코드를 통해, 실제 엔티티의 원하는 메서드 호출</span>
		<span class="c1">// 4. target.getName();</span>

		<span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
<p>다시 말하지만, 위 코드는 이해를 위한 예상 코드이다. 실제 프록시 클래스가 위와 동일하게 구현되었다는 이야기가 아니다.</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p>프록시 초기화 과정</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2043.png" alt="Untitled" /></p>
<ol>
<li>프록시 객체에 <code>member.getName()</code> 을 호출해서 실제 데이터 조회를 시도한다.</li>
<li>프록시 객체는 실제 엔티티가 생성되어 있지 않으면, 영속성 컨텍스트에 실제 엔티티 생성을 요청한다. ⇒ 초기화</li>
<li>영속성 컨텍스트는 DB를 조회해서 실제 엔티티 객체를 생성한다.</li>
<li>프록시 객체는 생성된 실제 엔티티 객체의 참조를 <code>Member형 target</code> 멤버변수에 보관한다.</li>
<li>프록시 객체는 실제 엔티티 객체의 <code>getName()</code> 을 호출해서 결과를 반환한다.</li>
</ol>
</li>
</ul>
<br/>
<h3 id="section-9">프록시 특징</h3>
<ul>
<li>
<p>프록시 객체는 처음 사용할 때, 한 번만 초기화된다.</p>
</li>
<li>
<p><strong>프록시 객체를 초기화해도, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다!</strong></p>
<ul>
<li>프록시 객체 초기화시, <strong>프록시 객체를 통해서 실제 엔티티에 접근</strong>할 수 있는 정도이다.</li>
</ul>
</li>
<li>
<p><strong>프록시 객체는 원본 엔티티를 상속받은 객체이므로, 타입 체크 시에 주의해야 한다.</strong></p>
</li>
<li>
<p>영속성 컨텍스트에 찾는 엔티티가 이미 있으면, <code>em.getReference()</code> 를 호출해도 실제 엔티티를 반환한다.</p>
<ul>
<li>
<p>영속성 컨텍스트에 원하는 엔티티가 이미 있다. ⇒ DB를 조회하지 않아도 실제 엔티티를 찾을 수 있다.</p>
</li>
<li>
<p>따라서 이 경우, 프록시를 사용할 이유가 없다!<br />
(프록시는 DB 조회를 미루려고 사용하므로)</p>
</li>
<li>
<p>즉 아래와 같다.</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2044.png" alt="Untitled" /></p>
</li>
</ul>
</li>
<li>
<p><strong>프록시 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다!</strong></p>
<ul>
<li>위 그림 ‘프록시 초기화 과정’ 을 다시 보자.</li>
<li>따라서 <strong>준영속 상태의 프록시를 초기화하면 문제가 발생</strong>하다.
<ul>
<li>이 경우는 아래에서 자세히 알아보자.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">준영속 상태와 초기화</h3>
<blockquote>
<p>참고로 준영속 상태에 대해 잘 모른다면, <a href="https://taegyunwoo.github.io/jpa/JPA_Persistence1#14">이전 게시글</a>을 참고하자.</p>
</blockquote>
<ul>
<li>준영속 상태에서 프록시 초기화를 시도하는 예시 코드를 먼저 보자.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// member 변수에는 프록시 객체가 담긴다.</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"id1"</span><span class="o">);</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 이때, member 엔티티가 준영속 상태로 변경된다.</span>

<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span> <span class="c1">//준영속 상태에서 초기화 시도</span>
<span class="c1">//org.hibernate.LazyInitializationException 예외 발생</span>
</code></pre></div></div>
<br/>
<ul>
<li>상세 설명
<ul>
<li><code>member.getName()</code> 을 호출하면 프록시를 초기화해야 하는데, 영속성 컨텍스트가 없으므로 실제 엔티티를 조회할 수 없다.
<ul>
<li>즉 이 경우는, 프록시 초기화에 사용해야할 영속성 컨텍스트가 없는 경우이다. (<code>close()</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">프록시와 식별자</h3>
<ul>
<li>
<p>엔티티를 프록시로 조회할 때, 식별자(PK) 값을 파라미터로 전달하게 된다.</p>
<ul>
<li><code>em.getReference(A.class, &quot;PK값&quot;)</code></li>
</ul>
</li>
<li>
<p><strong>이때 이 PK 값을 프록시 객체가 보관한다.</strong></p>
</li>
<li>
<p>프록시 객체에서 ‘해당 PK 값을 호출하는 것’으로는 프록시 초기화가 이루어지지 않는다.</p>
</li>
<li>
<p>즉, 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 변수 team에 프록시 객체를 담음</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"team1"</span><span class="o">);</span> <span class="c1">// 식별자 보관</span>

<span class="n">team</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span> <span class="c1">//프록시 초기화가 이루어지지 않는다!!!</span>
</code></pre></div></div>
<ul>
<li>
<p><strong><code>team.getId()</code> 를 호출한 경우, 프록시 초기화가 이루어지지 않는다.</strong></p>
<ul>
<li>왜냐하면 식별자는 DB조회 없이도 알 수 있기 때문이다.</li>
</ul>
</li>
<li>
<p>단, <code>@Access(AccessType.PROPERTY)</code> 로 설정한 경우에만 해당된다.</p>
</li>
<li>
<p><code>@Access(AccessType.FIELD)</code> 로 설정한 경우, 위와 같은 상황이더라도 프록시 객체를 초기화한다.</p>
<ul>
<li>왜냐하면 <code>FIELD</code> 로 설정시, JPA는 <code>getId()</code> 라는 메소드가 id만 조회하는 메소드인지, 다른 필드까지 활용하는 메소드인지 알 수 없다.</li>
<li>즉, <code>getId()</code> 메서드가 getter로 사용되는지 알 수 없다.</li>
</ul>
<blockquote>
<p><code>@Access</code> 에 대한 내용은 <a href="https://taegyunwoo.github.io/jpa/JPA_FieldAndColumnReference#8">이전 게시글</a>을 참고하자.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>프록시는 연관관계를 설정할 때, 유용하게 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span> <span class="c1">//실제 엔티티</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"team1"</span><span class="o">);</span> <span class="c1">//프록시 객체</span>

<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span> <span class="c1">//연관관계 설정</span>
</code></pre></div></div>
<ul>
<li>JPA는 연관관계 설정시, 식별자(PK) 값을 외래키로 사용한다.</li>
<li><strong>즉 연관관계 설정에 필요한 값은 식별자 값밖에 없으므로, 프록시 객체를 사용하여 연관관계를 설정할 수 있다.</strong></li>
</ul>
<blockquote>
<p>참고로 연관관계 설정시에는 <code>FIELD</code> 접근 방식으로 설정해도 프록시를 초기화하지 않는다.</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="section-12">프록시 확인</h3>
<ul>
<li><strong>프록시 인스턴스의 초기화 여부 확인하기</strong>
<ul>
<li>
<p><code>PersistenceUnitUtil.isLoaded(Object entity)</code> 메서드</p>
<ul>
<li>초기화 X ⇒ false</li>
<li>초기화 O ⇒ true</li>
</ul>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">isLoad</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getEntityManagerFactory</span><span class="o">()</span>
				<span class="o">.</span><span class="na">getPersistenceUnitUtil</span><span class="o">().</span><span class="na">isLoaded</span><span class="o">(</span><span class="n">확인할_프록시_엔티티</span><span class="o">);</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>실제 엔티티인지, 프록시 객체인지 확인하기</strong>
<ul>
<li>
<p>클래스명을 직접 출력하여 확인</p>
</li>
<li>
<p>클래스 명 뒤에 <code>javassist</code> 단어가 붙으면 프록시 객체이다.</p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>프록시 강제 초기화하기</strong>
<ul>
<li><code>org.hibernate.Hibernate.initialize(프록시_객체)</code></li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-13">즉시 로딩과 지연 로딩</h2>
<h3 id="section-14">즉시 로딩과 지연 로딩 요약</h3>
<ul>
<li><strong>즉시 로딩</strong>
<ul>
<li>엔티티를 조회할 때, 연관된 엔티티도 함께 조회한다.</li>
<li>예시
<ul>
<li><code>em.find(Member.class, &quot;member1&quot;)</code> 을 호출할 때, 회원 엔티티와 연관된 팀 엔티티도 함께 조회한다.</li>
</ul>
</li>
<li>설정 방법
<ul>
<li><code>@ManyToOne(fetch = FetchType.EAGER)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>지연 로딩</strong>
<ul>
<li>연관된 엔티티를 실제 사용할 때 조회한다.</li>
<li>예시
<ul>
<li><code>member.getTeam().getName()</code> 처럼 조회한 팀 엔티티를 실제로 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회한다.</li>
</ul>
</li>
<li>설정 방법
<ul>
<li><code>@ManyToOne(fetch = FetchType.LAZY)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>각각에 대해 자세히 알아보자.</p>
<br/>
<h3 id="eager-loading">즉시 로딩 (Eager Loading)</h3>
<ul>
<li>즉시 로딩을 사용하려면, <code>@ManyToOne</code> 의 속성 <code>fetch</code>를 <code>FetchType.EAGER</code> 로 지정한다.</li>
</ul>
<br/>
<ul>
<li>예시 코드
<ul>
<li>
<p>즉시 로딩 설정</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="c1">//...</span>

	<span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>즉시 로딩 실행 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//아래 코드 실행 시, 연관된 엔티티 Team도 같이 조회된다.</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span> <span class="c1">//객체 그래프 탐색</span>
</code></pre></div></div>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2045.png" alt="Untitled" /></p>
</li>
<li>
<p>상세 설명</p>
<ul>
<li><code>em.find(Member.class, &quot;member1&quot;)</code> 로 회원을 조회하는 순간 팀도 함께 조회한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>JPA 구현체들은 즉시 로딩을 최적화하기 위해, 가능하면 조인 쿼리를 사용한다.</strong>
<ul>
<li>연관된 엔티티까지 동시에 조회시
<ul>
<li>“기존 엔티티 SELECT 후, 연관된 엔티티 SELECT” 방식 사용 X</li>
<li><strong>“두 테이블을 외부 조인하여, 기존 엔티티와 연관 엔티티 모두 한번에 SELECT” 방식 사용 O</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="null--jpa--">즉시 로딩: NULL 제약조건과 JPA 조인 전략</h3>
<ul>
<li>
<p>즉시 로딩 시, <strong>외부조인</strong>을 사용하여 한번에 연관 엔티티까지 조회한다.</p>
</li>
<li>
<p>외부조인을 사용하는 이유</p>
<ul>
<li><strong>테이블의 FK 칼럼에 NOT NULL 제약조건이 없을 때를 대비하기 위해 외부조인을 사용한다.</strong></li>
<li>FK 칼럼에 null이 허용될 때, 내부조인을 사용하면 누락되는 데이터가 많다.</li>
</ul>
</li>
<li>
<p>하지만 성능상 내부조인이 좋다.</p>
<ul>
<li>
<p>외래키에 NOT NULL 제약조건이 걸리면, 내부조인을 사용할 수 있다.</p>
</li>
<li>
<p><strong>따라서 외래키에 NOT NULL 제약조건이 걸리면, <code>@JoinColumn</code> 의 속성 <code>nullable</code> 을 <code>false</code> 로 설정하여 JPA에서 내부조인을 사용하라고 알릴 수 있다.</strong></p>
</li>
<li>
<p><strong>혹은 <code>@JoinColumn</code> 의 속성 <code>optional</code> 을 <code>false</code> 로 설정해도 된다.</strong></p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="c1">// ...</span>

	<span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">,</span> <span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">//내부조인이 가능하다고 알린다.</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="c1">// ...</span>

<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
</li>
<li>
<p>정리</p>
<ul>
<li>선택적 관계 ⇒ 외부조인</li>
<li>필수 관계 ⇒ 내부조인 (성능이 더 좋음)</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-15">지연 로딩</h3>
<ul>
<li>지연 로딩을 사용하려면, <code>@ManyToOne</code> 의 <code>fetch</code> 속성을 <code>FetchType.LAZY</code> 로 지정하면 된다.</li>
<li>예시 코드
<ul>
<li>
<p>지연 로딩 설정</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="c1">//...</span>

	<span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>지연 로딩 실행 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//member = 실제 엔티티, member.team = 프록시 객체</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>

<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span> <span class="c1">//객체 그래프 탐색</span>

<span class="c1">//team 객체 실제 사용</span>
<span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span> <span class="c1">//이때, 프록시 초기화 (team 조회)</span>
</code></pre></div></div>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2046.png" alt="Untitled" /></p>
</li>
<li>
<p>상세 설명</p>
<ul>
<li><code>em.find(Member.class, &quot;member1&quot;)</code> 을 호출하면, 회원만 조회하고 팀은 조회하지 않는다.
<ul>
<li>단, 회원의 <code>team</code> 멤버변수에 프록시 객체를 넣어둔다.</li>
</ul>
</li>
<li><code>Team team = member.getTeam();</code>
<ul>
<li>해당 코드에서 team 변수에는 프록시 객체가 들어간다.</li>
<li>이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다.</li>
</ul>
</li>
<li><code>team.getName();</code>
<ul>
<li>이때 실제 데이터 로딩을 진행한다. (프록시 초기화)</li>
<li>조회 대상이 영속성 컨텍스트에 있으면 프록시 객체를 사용할 이유가 없다. (위에서 설명한 ‘프록시 특징’ 참고)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-16">즉시 로딩, 지연 로딩 정리</h3>
<ul>
<li><strong>지연 로딩 (Lazy Loading)</strong>
<ul>
<li>연관된 엔티티를 프록시로 조회한다.</li>
<li>프록시를 실제로 사용할 때, 초기화하면서 DB를 조회한다.</li>
</ul>
</li>
<li><strong>즉시 로딩 (Eager Loading)</strong>
<ul>
<li>연관된 엔티티를 즉시 조회한다.</li>
<li>하이버네이트는 가능하면 SQL 조인을 사용해서 한번에 조회한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-17">지연 로딩 활용</h2>
<h3 id="section-18">사내 주문 관리 시스템</h3>
<p>지연 로딩을 활용하는 예시를 들어, 지연 로딩이 어떻게 활용될 수 있는지 알아보자. ‘사내 주문 관리 시스템’을 예시로 삼겠다.</p>
<br/>
<ul>
<li>예시
<ul>
<li>
<p>클래스 모델</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2047.png" alt="Untitled" /></p>
</li>
<li>
<p>모델 분석</p>
<ul>
<li>회원은 팀 하나에만 소속할 수 있다. (N:1)</li>
<li>회원은 여러 주문내역을 가진다. (1:N)</li>
<li>주문내역은 상품정보를 가진다. (N:1)</li>
</ul>
</li>
<li>
<p>로직 분석</p>
<ul>
<li><code>Member</code>와 연관된 <code>Team</code>은 자주 함께 사용되었다.
<ul>
<li>그래서 <code>Member</code> 와 <code>Team</code> 을 즉시 로딩으로 설정했다.</li>
</ul>
</li>
<li><code>Member</code>와 연관된 <code>Order</code>은 가끔 함께 사용되었다.
<ul>
<li>그래서 <code>Member</code> 와 <code>Order</code> 을 지연 로딩으로 설정했다.</li>
</ul>
</li>
<li><code>Order</code>와 연관된 <code>Product</code>은 자주 함께 사용되었다.
<ul>
<li>그래서 <code>Order</code>와 <code>Product</code>을 즉시 로딩으로 설정했다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>예시 코드: 회원 엔티티</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>

	<span class="c1">//즉시</span>
	<span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

	<span class="c1">//지연</span>
	<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">,</span> <span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p>회원과 팀의 연관관계를 <code>FetchType.EAGER</code> 로 설정했다.</p>
<ul>
<li>따라서 회원 엔티티를 조회하면 연관된 팀 엔티티도 즉시 조회한다.</li>
</ul>
</li>
<li>
<p>회원과 주문내역의 연관관계를 <code>FetchType.LAZY</code> 로 설정했다.</p>
<ul>
<li>따라서 회원 엔티티를 조회하면 연관된 주문내역 엔티티는 프록시로 조회해서 실제 사용될 때까지 로딩을 지연한다.</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2048.png" alt="Untitled" /></p>
</li>
<li>
<p>회원 조회시</p>
<ul>
<li>외부조인을 사용하여 Member 엔티티와 Team 엔티티를 동시 SELECT 한다.</li>
<li>Order 엔티티 대신 프록시 객체가 조회된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-19">프록시와 컬렉션 래퍼</h3>
<ul>
<li>위 예시에서 즉시 로딩을 위주로 설명했다.</li>
<li>그렇다면 지연 로딩으로 설정한 <code>List&lt;Order&gt; orders</code> 는 어떻게 처리될까? 예시 코드를 통해 알아보자.</li>
</ul>
<br/>
<ul>
<li>
<p>예시 코드: 주문내역 조회</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getOrders</span><span class="o">();</span> <span class="c1">//컬렉션형 프록시가 들어감</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"orders = "</span> <span class="o">+</span> <span class="n">orders</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
<span class="c1">//결과: order = org.hibernate.collection.internal.PersistentBag</span>
</code></pre></div></div>
<ul>
<li>상세 설명
<ul>
<li>출력 결과가 이상한 것을 알 수 있다.</li>
<li><strong>엔티티를 영속 상태로 만들 때, 해당 엔티티에 컬렉션이 있으면 컬렉션을 추적·관리할 목적으로, 원본 컬렉션을 ‘하이버네이트 자체 내장 컬렉션’으로 변경한다.</strong></li>
<li>이 ‘하이버네이트 자체 내장 컬렉션’을 <strong>컬렉션 래퍼</strong>라고 한다.</li>
<li>따라서 출력 결과가 ‘~.PersistentBag’ 으로 나온 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>컬렉션 래퍼
<ul>
<li>컬렉션 래퍼는 컬렉션의 지연 로딩을 처리해준다.</li>
<li>즉 아래와 같이 생각하면 쉽다.
<ul>
<li><strong>컬렉션 래퍼 = 컬렉션용 프록시</strong></li>
</ul>
</li>
<li><strong>컬렉션 래퍼가 프록시 초기화되는 경우</strong>
<ul>
<li><code>member.getOrders()</code> ⇒ 프록시 초기화 X</li>
<li><code>member.getOrders().get(0)</code> ⇒ 프록시 초기화 O</li>
<li>즉 컬렉션에서 실제 데이터를 조회할 때, DB에서 조회하여 초기화한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>참고</p>
<ul>
<li><code>member.getOrders()</code> 가 초기화될 때, 상품(Product)도 같이 조회된다.</li>
<li>왜냐하면 주문(Order)와 상품(Product)가 즉시 로딩으로 설정되어 있기 때문이다.</li>
</ul>
</li>
<li>
<p>시각화</p>
</li>
</ul>
<p><img src="/assets/img/2021-11-14-JPA_Proxy/Untitled%2049.png" alt="Untitled" /></p>
<br/>
<h3 id="jpa---">JPA 기본 페치 전략</h3>
<ul>
<li>
<p><code>fetch</code> 속성의 기본 설정값은 아래와 같다.</p>
<ul>
<li><code>@ManyToOne</code> , <code>@OneToOne</code> : 즉시 로딩</li>
<li><code>@OneToMany</code> , <code>@ManyToMany</code> : 지연 로딩</li>
</ul>
</li>
<li>
<p>JPA의 기본 페치(Fetch) 전략</p>
<ul>
<li><strong>즉시로딩: 연관된 엔티티가 하나일때</strong></li>
<li><strong>지연로딩: 연관된 엔티티가 컬렉션형으로 처리될 때</strong></li>
</ul>
</li>
<li>
<p>컬렉션에 연관 엔티티를 담을 때, 지연로딩으로 동작하는 이유</p>
<ul>
<li>연관된 엔티티의 개수가 수만 건일 때, 즉시로딩으로 처리한다면 매우 비효율적이기 때문이다.</li>
<li>반면에 연관된 엔티티가 하나면 즉시 로딩해도 큰 문제가 발생하지는 않는다.</li>
</ul>
</li>
<li>
<p><strong>권장하는 전략</strong></p>
<ul>
<li><strong>모든 연관관계에 지연 로딩을 사용하라!</strong></li>
<li><strong>그리고 애플리케이션 개발이 어느정도 끝날때, 꼭 필요한 곳에만 즉시 로딩을 사용하도록 수정하라!</strong></li>
</ul>
</li>
<li>
<p>여기서 알 수 있는 JPA의 장점</p>
<ul>
<li>SQL을 직접 다룬다면, 위와 같은 권장 전략을 사용하기 어렵다. 많은 SQL과 코드를 일일이 수정해야 하기 때문이다.</li>
<li>하지만 JPA를 사용하면, 비교적 손쉽게 로딩 설정을 바꿀 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="fetchtypeeager---">컬렉션에 FetchType.EAGER 사용 시 주의점</h3>
<ul>
<li>
<p><strong>컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.</strong></p>
<ul>
<li>컬렉션과 조인하는 것 ⇒ 일대다 조인</li>
<li>서로 다른 컬렉션을 2개 이상 조인한다면, 너무 많은 데이터를 반환할 수 있다.</li>
<li>따라서 애플리케이션 성능이 저하될 수 있다.</li>
</ul>
</li>
<li>
<p><strong>컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.</strong></p>
</li>
<li>
<p><strong>조인 전략 정리</strong></p>
<ul>
<li><code>@ManyToOne</code> , <code>@OneToOne</code>
<ul>
<li><code>(optional = false)</code> : 내부조인</li>
<li><code>(optional = true)</code> : 외부조인</li>
</ul>
</li>
<li><code>@OneToMany</code> , <code>@ManyToMany</code>
<ul>
<li><code>(optional = false)</code> : 외부조인</li>
<li><code>(optional = true)</code> : 외부조인</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET