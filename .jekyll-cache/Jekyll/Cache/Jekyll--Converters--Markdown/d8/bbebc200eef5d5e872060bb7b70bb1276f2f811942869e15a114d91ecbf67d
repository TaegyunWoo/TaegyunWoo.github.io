I"[<p><br/><br/></p>
<h1 id="section">입력과 출력</h1>
<h2 id="section-1">개요</h2>
<h3 id="io-">I/O 모듈</h3>
<ul>
<li>프로세서, 기억장치와 더불어 컴퓨터 시스템의 주요 구성요소이다.</li>
<li>컴퓨터 주변 장치를 시스템 버스에 연결하고, 주변 장치와 버스 사이의 통신 기능을 담당한다.</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20111.png" alt="Untitled" /></p>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20112.png" alt="Untitled" /></p>
<br/>
<h3 id="io---">I/O 모듈이 필요한 이유</h3>
<p>왜 컴퓨터 주변 장치들이 시스템 버스에 직접 연결되지 않고, I/O 모듈을 거쳐서 연결될까?</p>
<ul>
<li>주변 장치들은 종류가 다양하며, 운용방식이 각기 다르기 때문이다.</li>
<li>주변 장치의 데이터 전송률은 기억장치 또는 프로세서에 비해서 훨씬 더 느리기 때문이다.</li>
<li>주변 장치들이 사용하는 데이터 형식 및 단어 길이가 프로세서와 다를 수 있기 때문이다.</li>
</ul>
<p><br/><br/></p>
<h2 id="section-2">외부 장치들</h2>
<h3 id="section-3">주변 기기들</h3>
<ul>
<li><strong>인간이 읽고 쓸 수 있는 장치</strong>
<ul>
<li>컴퓨터 사용자와의 통신에 적합한 장치이다.</li>
<li>예시) 모니터, 프린터, 키보드 등</li>
</ul>
</li>
<li><strong>기계가 읽을 수 있는 장치</strong>
<ul>
<li>기계 장치와의 통신에 적합한 장치이다.</li>
<li>예시) 자기 디스크, 센서 등</li>
</ul>
</li>
<li><strong>통신 장치</strong>
<ul>
<li>원격 장치와의 통신에 적합한 장치이다.</li>
<li>예시) 모뎀, 네트워크 인터페이스 카드 등</li>
</ul>
</li>
</ul>
<br/>
<h3 id="io--">I/O 모듈과의 인터페이스</h3>
<ul>
<li>
<p>“I/O 모듈”과 “외부 I/O 장치” 간의 통신 신호</p>
<ul>
<li>제어 신호</li>
<li>상태 신호</li>
<li>데이터</li>
</ul>
</li>
<li>
<p>외부장치의 블록 다이어그램</p>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20113.png" alt="Untitled" /></p>
<ul>
<li>시스템 버스
<ul>
<li>Control Bus
<ul>
<li>Control 신호(제어신호), Status 신호(상태신호) 처리</li>
</ul>
</li>
<li>Address Bus
<ul>
<li>I/O Module 과 I/O 장치가 직접 연결되어 있어서 Address Bus를 사용할 필요가 없다.</li>
<li>I/O Module 과 I/O 장치가 직접 연결되어 있기 때문에, 주소를 I/O Module이 알고있다.</li>
</ul>
</li>
<li>Data Bus</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="io--1">I/O 모듈</h2>
<h3 id="io---1">I/O 모듈의 기능</h3>
<ul>
<li><strong>제어와 타이밍</strong></li>
<li><strong>프로세서와 통신</strong></li>
<li><strong>장치들과의 통신</strong></li>
<li><strong>데이터 버퍼링</strong></li>
<li><strong>오류검출</strong></li>
</ul>
<p>I/O 모듈의 기능은 위와 같다. 이제부터 하나씩 자세히 알아보자.</p>
<br/>
<h3 id="section-4">제어와 타이밍</h3>
<ul>
<li>내부 자원과 외부 I/O 장치들 사이의 통신 흐름을 조정한다.</li>
<li>예시) 외부 I/O 장치에서 프로세서로의 데이터 전송 제어 절차
<ol>
<li>프로세서가 I/O 모듈에게 그 모듈에 부착된 장치의 상태를 검사하도록 요청한다.</li>
<li>I/O 모듈이 그 장치의 상태를 알려준다.</li>
<li>그 장치가 작동할 수 있고 전송이 가능한 상태라면, 프로세서는 I/O 모듈에게 데이터 전송을 요청한다.</li>
<li>I/O 모듈은 외부 I/O 장치로부터 데이터를 수신한다.</li>
<li>데이터가 I/O 모듈로부터 프로세서로 전송된다.</li>
</ol>
</li>
</ul>
<br/>
<h3 id="section-5">프로세서와 통신</h3>
<ul>
<li>명령 해독: 프로세서로부터 수신한 명령어를 해독한다.</li>
<li>데이터: 프로세서와 I/O 모듈 사이의 데이터 교환</li>
<li>상태보고: 외부 I/O 장치의 속도가 느리므로 I/O 모듈의 상태를 확인해야 한다.</li>
<li>주소 인식: I/O 모듈이 제어하는 주변장치의 주소를 인식한다.</li>
</ul>
<br/>
<h3 id="section-6">장치들과의 통신</h3>
<ul>
<li>명령, 상태 정보 및 데이터를 전송한다.</li>
</ul>
<br/>
<h3 id="section-7">데이터 버퍼링</h3>
<ul>
<li>주기억장치/프로세서와 주변장치 간의 데이터 전송률의 불일치 해소</li>
<li>데이터는 I/O 모듈 내에 일시적으로 저장되었다가 적절한 속도로 주변장치로 전송된다.</li>
</ul>
<br/>
<h3 id="section-8">오류검출</h3>
<ul>
<li>기계적, 전기적 오동작 및 데이터 전송 중 발생하는 비트 오류를 검출한다.</li>
<li>오류 검출 코드를 이용한다.</li>
</ul>
<br/>
<h3 id="io---2">I/O 모듈의 구성요소</h3>
<p>아래는 I/O 모듈의 구성요소이다.</p>
<ul>
<li><strong>신호선</strong>
<ul>
<li>제어, 주소, 데이터 신호선</li>
</ul>
</li>
<li><strong>상태 레지스터</strong></li>
<li><strong>외부 장치 인터페이스</strong></li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20114.png" alt="Untitled" /></p>
<br/>
<h3 id="io---3">I/O 모듈의 기능</h3>
<ul>
<li><strong>외부장치의 속성을 프로세서로부터 감춘다.</strong>
<ul>
<li>즉, 프로세서는 외부 I/O 장치에 대한 구체적인 내용을 몰라도 된다.</li>
<li>I/O 모듈: I/O 장치의 세부적인 내용을 처리한다.</li>
<li>프로세서: 단순히 읽기, 쓰기, 등의 명령만으로 장치를 제어한다.</li>
</ul>
</li>
<li><strong>하나 또는 다수의 외부장치를 지원한다.</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="io">프로그램 I/O</h2>
<h3 id="io----1">I/O 동작의 세가지 기법</h3>
<ul>
<li><strong>프로그램 I/O</strong>
<ul>
<li>프로세서가 “외부 I/O 장치의 상태 감지”, “읽기/쓰기 명령의 전송”, “데이터 전송” 등과 같은 I/O 동작을 직접 제어한다.</li>
<li>즉, I/O모듈이 존재하지 않는다. 프로세서가 모든 것을 처리한다.</li>
<li><strong>프로세서가 읽기/쓰기에 관여한다.</strong></li>
</ul>
</li>
<li><strong>인터럽트-구동 I/O</strong>
<ul>
<li>프로세서가 I/O 명령을 보낸 다음, I/O모듈이 그 일을 완료하고 인터럽트를 보낼때까지 다른 명령어들을 수행한다.</li>
<li>I/O 명령후, 다른 일을 프로세서가 수행한다. (인터럽트를 받을 때까지)</li>
<li><strong>프로세서가 읽기/쓰기에 관여한다.</strong></li>
</ul>
</li>
<li><strong>직접 기억장치 액세스 (DMA)</strong>
<ul>
<li>I/O 모듈과 주기억장치가 프로세서의 개입없이 데이터를 직접 교환한다.</li>
<li>DMA 칩을 통해 수행된다.</li>
<li><strong>프로세서가 읽기/쓰기에 관여하지 않는다.</strong></li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20115.png" alt="Untitled" /></p>
<br/>
<h3 id="io--2">프로그램 I/O의 동작</h3>
<ul>
<li>프로세서가 프로그램 수행 도중 I/O 관련 명령어를 만나면, 해당 I/O 모듈에게 명령을 보냄으로써 그 명령어를 실행한다.</li>
<li>I/O 모듈은 요구된 연산을 수행한 뒤에, I/O 상태 레지스터를 세팅한다.
<ul>
<li>이때 I/O 모듈은 프로세서를 방해하지 않는다.</li>
</ul>
</li>
<li>연산이 완료될 때까지 주기적으로 I/O 모듈의 상태를 검사하는 것은 프로세서의 책임이다.
<ul>
<li>프로세서는 I/O 모듈의 상태에 따라 대기할 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="io--3">I/O 명령들</h3>
<ul>
<li>제어</li>
<li>검사</li>
<li>읽기</li>
<li>쓰기</li>
</ul>
<p>위 항목은 I/O 관련 명령들이다.</p>
<br/>
<h3 id="io----2">I/O 장치의 주소 지정방식</h3>
<ul>
<li><strong>기억장치-사상 I/O</strong>
<ul>
<li>기억장소와 I/O 장치들이 하나의 주소 공간을 갖는다.</li>
<li>프로세서는 I/O 모듈 내의 레지스터를 기억장치와 동일하게 취급한다.</li>
<li>기억장치의 읽기/쓰기 동작과 유사하게 I/O 장치에 읽기/쓰기가 가능하다.
<ul>
<li>하지만 메모리 주소가 낭비된다. (따로 떼어내서 줘야하므로)</li>
</ul>
</li>
</ul>
</li>
<li><strong>고립형 I/O</strong>
<ul>
<li>I/O에 대한 주소 공간과 기억장치의 주소 공간이 분리된다.</li>
<li>I/O 장치와 기억장치 선택선(line)이 필요하다.
<ul>
<li>선택선: I/O 장치인지, 기억장치인지 구분할 수 있는 선</li>
</ul>
</li>
<li>I/O 장치 조작을 위한 별도의 명령어가 필요하다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20116.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="io-1">인터럽트-구동 I/O</h2>
<h3 id="io--4">프로그램 I/O의 문제점</h3>
<ul>
<li><strong>I/O 모듈이 데이터를 수신 또는 송신할 준비가 될 때까지 프로세서가 대기</strong>한다.</li>
<li>전체 시스템의 성능 저하가 유발된다.</li>
</ul>
<br/>
<h3 id="io-2">인터럽트-구동 I/O란?</h3>
<ul>
<li>프로세서로부터 입출력 명령을 받은 I/O 모듈이 동작하는 동안, <strong>프로세서가 다른 프로그램을 처리</strong>하도록 한다.</li>
<li>I/O 모듈은 <strong>프로세서와 데이터 교환이 준비되었을 때, 프로세서에게 인터럽트를 보내어 서비스를 요구</strong>한다.</li>
<li>이때 프로세서는 그에 따른 데이터 전송을 수행한 다음, 이전에 처리하던 일을 계속 수행한다.</li>
<li>하지만 <strong>데이터는 반드시 프로세서를 거처야하므로, 인터럽트 I/O도 여전히 많은 프로세서 시간을 소비</strong>한다.</li>
</ul>
<br/>
<h3 id="io---4">인터럽트-구동 I/O의 동작: 읽기</h3>
<ul>
<li>
<p><strong>I/O 모듈 관점</strong></p>
<ol>
<li>프로세서로부터 READ 명령을 수신한다.</li>
<li>I/O 모듈은 해당 입출력 장치로부터 데이터를 읽는다.</li>
<li>데이터가 I/O 모듈의 데이터 레지스터에 저장되면, 모듈은 제어선을 통해 프로세서로 인터럽트 신호를 보낸다.</li>
<li>I/O 모듈은 프로세서가 데이터를 요구할 때까지 기다린다.</li>
<li>요구가 오면 모듈은 그 데이터를 데이터 버스로 보낸 다음, 다른 I/O 동작을 위해서 준비한다.</li>
</ol>
</li>
<li>
<p><strong>프로세서 관점</strong></p>
<ol>
<li>프로세서가 I/O 모듈로 READ 명령을 보낸다.</li>
<li>다른 일을 처리한다.</li>
<li>각 명령어 사이클의 마지막 순간에, 프로세서가 인터럽트 검사를 한다.
<ul>
<li>인터럽트 검사: 인터럽트가 발생했는가?</li>
</ul>
</li>
<li>I/O 모듈로부터 인터럽트가 발생하면, 프로세서는 현재 프로그램 문맥을 저장한 후 인터럽트를 처리한다.</li>
<li>프로세서는 I/O 모듈로부터 데이터를 읽어서 기억장치에 저장한다.</li>
<li>인터럽트 처리 후, 이전에 수행하던 프로그램 문맥을 복구하여 그 일을 계속한다.</li>
</ol>
</li>
</ul>
<br/>
<h3 id="section-9">인터럽트 처리 과정</h3>
<ol>
<li>I/O 모듈이 프로세서로 인터럽트를 보낸다.</li>
<li>프로세서는 인터럽트에 응답하기 전, 현재 실행 중인 명령어의 실행을 완료한다.
<ul>
<li>현재 실행 중이던 <strong>하나의 명령어</strong>를 마저 수행한다.</li>
</ul>
</li>
<li>프로세서는 인터럽트를 검사하고 인터럽트가 있다면, 그 요구를 발생한 장치에 확인 신호를 보낸다.</li>
<li>프로세서는 인터럽트 서비스 루틴(ISR)으로 제어를 넘겨줄 준비를 한다.
<ul>
<li>프로그램 상태 단어(PSW)와 프로그램 카운터(PC) 내용을 스택에 저장한다.</li>
</ul>
</li>
<li>인터럽트 처리 프로그램의 시작 주소를 PC에 저장한다.</li>
<li>PC가 인터럽트 서비스 루틴의 시작 위치를 가리키도록 갱신한다.</li>
<li>인터럽트 처리기가 인터럽트를 처리한다.</li>
<li>인터럽트 처리가 완료되면, 저장된 레지스터의 내용들이 스택으로 인출되어 레지스터들로 복원된다.</li>
<li>PWD와 PC의 내용을 스택으로부터 복원한다.
<ul>
<li>기존에 수행 중이던 컨텍스트로 돌아온다.</li>
</ul>
</li>
</ol>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20117.png" alt="Untitled" /></p>
<br/>
<h3 id="io----">인터럽트-구동 I/O 구현을 위한 설계 이슈</h3>
<ul>
<li><strong>수많은 I/O 모듈 중에서, 인터럽트를 발생한 장치를 어떻게 찾아낼 것인가?</strong></li>
<li><strong>여러 개의 인터럽트가 발생했을 때, 처리할 인터럽트를 어떻게 결정하는가?</strong></li>
</ul>
<p>인터럽트-구동 I/O를 구현하기 위해 고려해야 하는 것은 위와 같다. 하나씩 자세히 알아보자.</p>
<br/>
<h3 id="section-10">설계 이슈 해결방법 종류</h3>
<ul>
<li><strong>다수 인터럽트 선 (Multiple Interrupt Lines)</strong></li>
<li><strong>소프트웨어 폴 (Software Poll)</strong></li>
<li><strong>데이지 체인 (Daisy Chain, Hardware Poll)</strong></li>
</ul>
<p>각 방법들에 대해 하나씩 알아보자.</p>
<br/>
<h3 id="section-11">설계 이슈 해결방법: 다수 인터럽트 선</h3>
<ul>
<li><strong>프로세서와 I/O 모듈 사이에 여러 개의 인터럽트 선을 제공하는 방식</strong>이다.
<ul>
<li>인터럽트 요구 선 (Interrupt Request: INTR)</li>
<li>인터럽트 확인 선 (Interrupt Acknowledge: INTA)</li>
<li>위 선들이 각 I/O 모듈과 프로세서를 연결해준다.</li>
</ul>
</li>
</ul>
<br/>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20118.png" alt="Untitled" /></p>
<br/>
<ul>
<li>장점
<ul>
<li>인터럽트를 요구한 장치를 찾기가 쉽다.</li>
</ul>
</li>
<li>단점
<ul>
<li>HW가 복잡하다.</li>
<li>I/O 장치 수가 프로세서의 인터럽트 요구 입력 핀 수에 제한된다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-12">설계 이슈 해결방법: 소프트웨어 폴</h3>
<ul>
<li><strong>모든 I/O모듈에 접속된 TEST I/O 선을 이용하여, 프로세서가 인터럽트를 요구한 장치를 검사</strong>한다.</li>
<li>프로세서는 특정 명령선을 활성화시키고, I/O 모듈들의 주소를 순서대로 내보낸다.</li>
<li>I/O 모듈 검사 순서를 우선 순위로 삼는다.
<ul>
<li>즉 인터럽트가 동시에 요청되었을 때, Test I/O로 <strong>먼저 확인된 제어기를 먼저 처리</strong>하게 된다.</li>
</ul>
</li>
</ul>
<br/>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20119.png" alt="Untitled" /></p>
<br/>
<ul>
<li>장점
<ul>
<li>우선 순위의 변경이 용이하다.</li>
<li>하드웨어가 필요하지 않다.</li>
</ul>
</li>
<li>단점
<ul>
<li>처리 시간이 오래 걸린다.
<ul>
<li>일일이 제어기에게 물어봐야하기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">설계 이슈 해결방법: 데이지 체인</h3>
<ul>
<li>
<p>모든 I/O 모듈이 하나의 인터럽트 요구 선 (INTR)을 공유한다.</p>
</li>
<li>
<p>인터럽트 확인 신호 (INTA)를 위해, 데이지 체인 형태로 연결한다.</p>
<ul>
<li><strong>프로세서와 가까운 모듈의 우선순위가 높다.</strong></li>
</ul>
</li>
<li>
<p>동작 원리</p>
<ol>
<li>I/O 모듈이 인터럽트를 요구한다.</li>
<li>프로세서가 확인신호를 보낸다.
<ul>
<li>이 신호는 요구한 모듈에 도착할 때까지 모듈들을 통과하여 전파된다.</li>
</ul>
</li>
<li>인터럽트를 요구한 모듈은 데이터 버스를 통해, 인터럽트 벡터를 보낸다.</li>
</ol>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20120.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-14">설계 이슈 해결방법: 버스 중재</h3>
<ul>
<li>I/O 모듈이 인터럽트를 요구하기 전에 먼저 버스에 대한 사용권을 얻는다.</li>
<li>어느 한 순간에 하나의 모듈만이 인터럽트를 보낼 수 있다.</li>
<li>프로세서는 인터럽트를 감지하면 인터럽트 확인 신호를 활성화함으로써 응답한다.</li>
</ul>
<p><br/><br/></p>
<h2 id="direct-memory-access-dma">직접 기억장치 액세스 (Direct Memory Access: DMA)</h2>
<h3 id="io---io-">프로그램 I/O와 인터럽트-구동 I/O의 결점</h3>
<ul>
<li>I/O 전송률이 프로세서가 장치를 검사하고 서비스하는 속도에 의해 제한된다.</li>
<li>프로세서가 I/O 전송 관리를 위해 많은 시간을 소모한다.</li>
</ul>
<br/>
<h3 id="dma">DMA란?</h3>
<ul>
<li>
<p><strong>기억장치와 I/O 모듈 간의 데이터 전송을 별도의 하드웨어인 DMA 모듈(제어기)가 처리</strong>한다.</p>
</li>
<li>
<p><strong>프로세서는 전송의 시작과 끝부분에만 관여</strong>한다.</p>
</li>
<li>
<p>기존 방식</p>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20121.png" alt="Untitled" /></p>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20122.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="dma-">DMA 동작</h3>
<ol>
<li>CPU가 DMA 제어기로 아래 정보를 포함한 명령을 전송한다.
<ul>
<li>연산(쓰기/읽기) 지정</li>
<li>I/O 장치의 주소</li>
<li>데이터가 읽히거나 쓰여질 주기억장치 영역의 시작 주소</li>
<li>전송될 데이터 단어들의 수</li>
</ul>
</li>
<li>DMA 제어기는 CPU로 버스 요구 신호 (Bus Request)를 전송한다.</li>
<li>CPU가 DMA 제어기로 버스 승인 (Bus Grant) 신호를 전송한다.</li>
<li>DMA 제어기가 주기억장치로부터 데이터를 읽거나 쓴다.</li>
<li>전송할 데이터가 남아있으면 2~4번까지를 반복한다.</li>
<li>모든 데이터들의 전송이 완료되면 DMA가 CPU로 INTR(인터럽트) 신호를 전송한다.</li>
</ol>
<blockquote>
<p><strong>프로세서가 DMA에 명령을 보낸 다음 프로세서는 다른 일을 계속한다.</strong></p>
</blockquote>
<br/>
<h3 id="dma----cycle-stealing">DMA 전송 사이클 스틸링 (Cycle Stealing)</h3>
<ul>
<li>사이클 스틸링이란?
<ul>
<li><strong>CPU와 Main Memory가 서로 통신을 하지 않을 때만 DMA가 시스템 버스를 사용하는 것을 의미한다.</strong></li>
</ul>
</li>
<li>DMA 제어기가 데이터 전송을 위해서 버스 사이클을 사용한다.
<ul>
<li>DMA 모듈은 한 단어를 전송한 뒤에 버스를 프로세서에 돌려준다.</li>
</ul>
</li>
<li><strong>사이클 스틸링은 인터럽트가 아니다.</strong>
<ul>
<li>프로세서가 상태 정보를 저장하지 않으며, 한 버스 사이클 동안 잠시 정지하는 것이다.</li>
<li>즉, 단순히 프로세서는 기다린다.</li>
</ul>
</li>
<li>프로세서의 실행속도가 저하되기는 한다.
<ul>
<li>하지만, 인터럽트-구동 I/O 보다는 효율적이다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20123.png" alt="Untitled" /></p>
<br/>
<h3 id="dma--">여러 가지 DMA 구성 방법</h3>
<ul>
<li>
<p><strong>단일 버스, 분리된 DMA</strong></p>
<ul>
<li>모든 모듈이 한 개의 시스템 버스를 공유한다.</li>
<li>비용은 적지만 비효율적이다.</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20124.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>단일 버스, 통합된 DMA-I/O</strong></p>
<ul>
<li>DMA 모듈과 I/O 모듈 사이에 별도의 경로가 존재한다.</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20125.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>I/O 버스</strong></p>
<ul>
<li>I/O 모듈들은 I/O 버스를 통해 DMA 모듈에 연결된다.</li>
</ul>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20126.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="a-dma-">예시: 인텔 8237A DMA 제어기</h3>
<p>인텔 사의 8237A DMA 제어기 칩을 예시로 삼아, DMA가 데이터를 기억장치에서 디스크로 전송하는 과정을 알아보자.</p>
<p><img src="/assets/img/2021-10-28-ComputerStructure_IO/Untitled%20127.png" alt="Untitled" /></p>
<ol>
<li>I/O 장치가 <strong>DREQ(DMA Request)</strong> 를 통해서, DMA에 서비스를 요구한다.</li>
<li>DMA는 <strong>HRQ(Hold Request)</strong> 를 통해서, CPU에 버스 사용을 요구한다.</li>
<li>CPU는 <strong>HDLA(Hold Acknowledge)</strong> 를 통해서, DMA에 버스 사용을 허락한다.</li>
<li>DMA는 <strong>DACK(DMA Acknowledge)</strong> 를 통해서, 데이터 전송을 알린다.</li>
<li>DMA는 블록의 첫번째 바이트의 주소를 버스에 싣는다. 그리고 MEMR 신호를 활성화시켜 데이터 전송을 시작한다.</li>
<li>데이터 전송 후, DMA는 HRQ를 비활성화시켜 CPU에 버스 사용 종료를 알린다.</li>
</ol>
<p><br/><br/></p>
<h2 id="io--5">I/O 채널</h2>
<h3 id="io----3">I/O 기능의 발전 과정</h3>
<p>I/O 기능이 어떻게 발전해왔는지 알아봄과 동시에 지금까지의 내용을 정리해보자. 추가적으로 <strong>I/O 채널</strong>에 대해서도 알아보자.</p>
<ol>
<li>CPU가 I/O 주변장치를 직접 제어한다.</li>
<li>제어기 또는 I/O 모듈이 추가된다.
<ul>
<li>프로세서가 인터럽트 없는 <strong>프로그램 I/O</strong>를 사용한다.</li>
<li>아직까진 프로세서가 직접 데이터 R/W 작업에 관여한다.</li>
</ul>
</li>
<li>인터럽트가 추가된다.
<ul>
<li>프로세서가 I/O 동작이 수행되는 것을 기다리지 않으므로 효율이 향상된다.</li>
</ul>
</li>
<li>DMA를 통하여 I/O 모듈이 기억장치를 직접 액세스한다.
<ul>
<li>프로세서의 개입 없이 데이터 전송이 가능하다.</li>
</ul>
</li>
<li>I/O 모듈이 ‘I/O 동작을 위한 특수 명령어 세트를 가진 프로세서’를 포함한다.
<ul>
<li>이것을 <strong>I/O 채널</strong>이라고 한다.</li>
<li>I/O채널 = I/O 작업만을 위한 프로세서</li>
<li>프로세서는 기억장치에 있는 I/O 프로그램의 수행을 I/O 프로세서에 지시하고, 동작 전체가 완료된 시점에만 인터럽트된다.</li>
</ul>
</li>
<li>I/O 모듈이 자신의 지역기억장치를 포함한다.</li>
</ol>
<br/>
<h3 id="io---5">I/O 채널의 특성</h3>
<ul>
<li>I/O 채널은 DMA 개념을 확장한 것이다.</li>
<li>I/O 채널은 I/O 명령어를 실행할 수 있는 능력을 가지므로, I/O 동작에 대한 완전한 제어권을 갖는다.</li>
<li>프로세서가 I/O 명령어를 실행하지 않고, <strong>I/O 채널 내에 있는 특수목적용 프로세서</strong>가 실행된다.
<ul>
<li>프로세서가 I/O 채널에게 기억장치에 있는 프로그램을 실행하도록 지시함으로써 I/O 전송을 시작한다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 최정열 교수님 (2021)</li>
    <li>William Stalling, 『컴퓨터시스템구조론(10판)』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET