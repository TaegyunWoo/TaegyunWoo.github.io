I"R<p><br/><br/></p>
<h1 id="cpu-">CPU 스케줄링</h1>
<h2 id="section">개요</h2>
<h3 id="section-1">기본 개념</h3>
<ul>
<li>
<p>CPU 스케줄링의 목적</p>
<ul>
<li>CPU 사용률의 극대화</li>
</ul>
</li>
<li>
<p>보편적인 CPU 작업 사이클의 특성</p>
<ul>
<li>일반적으로 CPU는 아래 그림과 같은 작업 사이클을 갖는다.</li>
</ul>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2018.png" alt="Untitled" /></p>
<ul>
<li><strong>일반적으로 I/O wait의 시간이 CPU execution 시간보다 훨씬 길다.</strong></li>
<li>보통 CPU Burst 후, I/O Burst가 온다.</li>
<li>Burst : 집중 사용시간, 연속사용시간</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>일반적인 CPU Burst 길이 별 빈도수 히스토그램</strong></p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2019.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="cpu--1">CPU 스케줄러란?</h3>
<ul>
<li>
<p><strong>CPU 스케줄러 == Short-term Scheduler</strong></p>
</li>
<li>
<p>Short-term Scheduler 란?</p>
<ul>
<li><strong>ready → running 프로세스 상태로 바꿔주는 스케줄러이다.</strong></li>
<li><strong>즉, ready queue에서 프로세스를 선택하여 CPU에 할당시키는 스케줄러이다.</strong>
<ul>
<li><strong>이때 스케줄링 기준(Criteria)에 따라, 어떤 프로세스를 선택할지 달라진다!</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>자세한 것은 <a href="https://taegyunwoo.github.io/os/OS_Process1#24">이전 포스팅</a>을 참고하자.</p>
</blockquote>
</li>
<li>
<p><strong>CPU 스케줄러(Short-term Scheduler)가 동작하는 부분</strong></p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2020.png" alt="Untitled" /></p>
</li>
<li>
<p>(ready)큐: 연결 큐</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2021.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-2">선점 스케줄링</h2>
<h3 id="cpu----">CPU 스케줄링 결정이 일어나는 상황</h3>
<p>아래 항목들은 프로세스의 상태가 변화함에 따라, CPU 스케줄링 결정이 일어나는 상황이다.</p>
<ol>
<li><strong>Running → Waiting</strong></li>
<li><strong>Running → Ready</strong></li>
<li><strong>Waiting → Ready</strong></li>
<li><strong>New → Ready</strong></li>
<li><strong>Terminates</strong></li>
</ol>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2022.png" alt="Untitled" /></p>
<blockquote>
<p>프로세스 상태는 <a href="https://taegyunwoo.github.io/os/OS_Process1#8">이전 게시글</a>을 참고하자.</p>
</blockquote>
<br/>
<ul>
<li><strong>Ready → Running 은?</strong>
<ul>
<li><strong>해당 경우는 CPU 스케줄링 결정이 일어나지 않는다.</strong></li>
<li><strong>이 경우에는, 스케줄러가 이미 정리해둔(기준;Criteria에 따라 정리) Ready Queue 에서 Dispatcher가 프로세스를 꺼내어 CPU로 할당시키는 것이기 때문이다.</strong></li>
<li>즉, Dispatcher가 이미 정리되어 있는 Ready Queue에서 단순히 프로세스를 꺼내는 것이기 때문이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">선점 스케줄링이란?</h3>
<ul>
<li>선점 스케줄링 == Preemptive Scheduling
<ul>
<li>선점 스케줄링은 새치기와 비슷한 개념으로 생각할 수 있다.</li>
<li>선점: CPU를 강제로 할당받는다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="cpu--">선점이 일어나는 경우 (CPU 스케줄링 결정에서)</h3>
<ul>
<li><strong>Running → Ready</strong></li>
<li><strong>Waiting → Ready</strong></li>
<li><strong>New → Ready</strong></li>
<li>위 경우들은 모두 <strong>선점으로 동작</strong>한다.</li>
</ul>
<br/>
<h3 id="cpu---1">선점이 일어나지 않는 경우 (CPU 스케줄링 결정에서)</h3>
<ul>
<li><strong>Running → Waiting</strong></li>
<li><strong>Terminates</strong></li>
<li>위 경우들은 모두 <strong>비선점으로 동작</strong>한다.</li>
<li><strong>즉, ’해당 작업이 완료될 때(CPU 할당 후 수행 완료)’까지 방해받지 않는다.</strong></li>
</ul>
<br/>
<h3 id="section-4">선점 동작 방식에서의 주의사항</h3>
<ul>
<li>공유하는 자료를 갱신하고 있는 동안 선점 당하면 문제가 생긴다.</li>
<li>커널 작업 중에 선점 당하면, 커널의 중요한 자료에 문제가 생길 수 있다.</li>
<li>중요한 운영체제 작업 중에는 인터럽트의 발생을 불허한다.</li>
</ul>
<p><br/><br/></p>
<h2 id="dispatcher">디스패처 (Dispatcher)</h2>
<h3 id="section-5">디스패처의 기능</h3>
<ul>
<li>디스패처는 Short-term Scheduler(CPU 스케줄러)가 선택한 프로세스에게 CPU 제어권을 준다.
<ul>
<li>이때 ‘Ready → Running’으로 상태가 변화한다.</li>
<li><strong>따라서 디스패처가 ‘Ready → Running’로 변환해줄 때는 스케줄링 결정이 이루어지지 않는다!</strong></li>
<li><strong>Short-term Scheduler가 디스패처에게 넘겨줄 프로세스를 선택할 때, 스케줄링 결정이 루어진다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-6">디스패처에 의한 제어권 변경 예시</h3>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2023.png" alt="Untitled" /></p>
<ul>
<li><strong>디스패치 지연 (Dispatch Latency)</strong>
<ul>
<li>디스패치 지연이란, <strong>디스패처가 현재 실행 중인 프로세스를 멈추고, 다른 프로세스를 실행하는 시간을 의미</strong>한다.</li>
<li>즉, Context Switching 시간을 말한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="scheduling-criteria">스케줄링 기준 (Scheduling Criteria)</h2>
<h3 id="section-7">스케줄링하는 기준의 종류</h3>
<ul>
<li><strong>CPU Utilization (CPU 이용률)</strong>
<ul>
<li>CPU를 최대한 일하게 한다.</li>
</ul>
</li>
<li><strong>Throughput (처리량)</strong>
<ul>
<li>단위시간당 실행을 완료하는 프로세스들의 개수</li>
</ul>
</li>
<li><strong>Turnaround Time (총 처리 시간)</strong>
<ul>
<li>프로세스의 제출시간과 완료시간의 간격
<ul>
<li>제출시간: 프로세스가 Ready Queue에 들어온 시간</li>
<li>완료시간: 프로세스가 ‘Terminated’되거나, ‘Waiting을 거쳐 Ready’로 변경된 순간의 시간(시각) ⇒ ‘I/O 시간’을 의미한다.</li>
</ul>
</li>
<li>‘Ready Queue 대기시간’ + ‘CPU 실행시간’ + ‘I/O 시간’</li>
</ul>
</li>
<li><strong>Waiting Time (대기 시간)</strong>
<ul>
<li>Ready Queue에서 대기하면서 보낸 시간의 합</li>
</ul>
</li>
<li><strong>Response Time (응답 시간)</strong>
<ul>
<li>대화식 시스템에서 응답이 시작되는 데 까지 걸리는 시간</li>
<li>예시) 터미널에 키보드로 A 입력시, A가 입력되었음을 시스템이 알아차리는데 걸리는 시간</li>
<li>평균 응답시간이 짧아야 할 뿐만 아니라, 응답시간의 편차도 작아야 한다.
<ul>
<li>즉, 어쩔땐 짧고 어쩔땐 길면 안된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-8">스케줄링 알고리즘을 최적화하는 기준</h3>
<ul>
<li>Max CPU Utilization (CPU 이용률 최대화)</li>
<li>Max Throughput (처리량 최대화)</li>
<li>Min Turnaround Time (총 처리시간 최소화)</li>
<li>Min Waiting Time (대기시간 최소화)</li>
<li>Min Response Time (응답시간 최소화)</li>
</ul>
<p>위와 같은 기준으로 스케줄링 알고리즘을 최적화할 수 있다.</p>
<p><br/><br/></p>
<h2 id="cpu---fcfs">CPU 스케줄링 종류: FCFS</h2>
<h3 id="first-come-first-served-scheduling-fcfs">First-Come, First-Served Scheduling (FCFS)</h3>
<ul>
<li><strong>FCFS == FIFO == 선입선출</strong>
<ul>
<li>모두 같은 의미이다.</li>
</ul>
</li>
<li><strong>FCFS는 비선점 방식의 스케줄링 방법이다.</strong>
<ul>
<li>즉, 중간에 CPU를 뺏기지 않는다.</li>
</ul>
</li>
<li>Short-term Scheduler가 동작하는 방식 중 하나이다.</li>
</ul>
<br/>
<ul>
<li>
<p>바로 예시를 통해, 어떻게 스케줄링하는지 알아보자.</p>
</li>
<li>
<p>예시</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2024.png" alt="Untitled" /></p>
<ul>
<li>각 프로세스의 Burst Time이 위와 같다고 가정하자.</li>
<li>그리고 프로세스가 순차적으로 도착했다고 가정하자.
<ul>
<li>“P1 , P2 , P3” 순으로 도착</li>
</ul>
</li>
<li>이때, FCFS 스케줄링이 작동하는 방식을 간트차트로 나타낸 것이 아래 그림이다.</li>
</ul>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2025.png" alt="Untitled" /></p>
<ul>
<li><strong>대기시간</strong>
<ul>
<li><strong>FCFS에서의 특정 프로세스 대기시간 = 특정 프로세스의 시작시간</strong></li>
<li>P1 = 0</li>
<li>P2 = 24</li>
<li>P3 = 27</li>
</ul>
</li>
<li><strong>평균 대기시간</strong>
<ul>
<li>(0+24+27)/3 = 17</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>호위 효과 (Convoy Effect)</strong>
<ul>
<li><strong>FCFS 방식은 호위 효과라는 것을 유발시킨다.</strong></li>
<li>호위 효과란, 긴 프로세스 뒤에 작은 프로세스가 있는 것을 말한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="first-come-first-served-scheduling-fcfs-">First-Come, First-Served Scheduling (FCFS) 예시</h3>
<p>또 다른 예시를 보자.</p>
<ul>
<li>
<p>가정</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2026.png" alt="Untitled" /></p>
<ul>
<li>프로세스 도착 순서는 아래와 같다고 하자.
<ul>
<li>P2 , P3 , P1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>간트차트 시각화</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2027.png" alt="Untitled" /></p>
<ul>
<li><strong>대기 시간</strong>
<ul>
<li>P1 = 6</li>
<li>P2 = 0</li>
<li>P3 = 3</li>
</ul>
</li>
<li><strong>평균 대기 시간</strong>
<ul>
<li>(6+0+3)/3 = 3</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>이 경우, 호위 효과가 발생하지 않아 평균 대기 시간이 비교적 짧아졌다. (위 예시보단)</strong></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="cpu---sjf">CPU 스케줄링 종류: SJF</h2>
<h3 id="shortest-job-first-scheduling-sjf">Shortest-Job-First Scheduling (SJF)</h3>
<ul>
<li>
<p>SJF란?</p>
<ul>
<li>최단작업우선 방식</li>
<li><strong>가장 작은 CPU 버스트를 갖는 프로세스를 다음 프로세스로 스케줄링한다.</strong></li>
</ul>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2028.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<ul>
<li><strong>SJF 방식이 최적의 스케줄링 방식이다.</strong>
<ul>
<li>이것은 가장 적은 평균 대기 시간을 보장한다.</li>
<li><strong>하지만 각 프로세스의 CPU Burst Time을 미리 알기가 힘들다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="shortest-job-first-scheduling-sjf-">Shortest-Job-First Scheduling (SJF) 예시</h3>
<ul>
<li>
<p>가정</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2029.png" alt="Untitled" /></p>
</li>
<li>
<p>간트차트 시각화</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2030.png" alt="Untitled" /></p>
<ul>
<li>짧은 Burst Time 순으로 실행된다.</li>
</ul>
</li>
<li>
<p><strong>평균 대기 시간</strong></p>
<ul>
<li>(3 + 16 + 9 + 0) / 4 = 7</li>
</ul>
</li>
</ul>
<br/>
<h3 id="sjf--burst-time--">SJF 에서 Burst Time을 예측하는 방법</h3>
<ul>
<li>
<p>위에서 설명했듯이, SJF는 가장 좋은 스케줄링 방법이지만 <strong>CPU Burst Time을 미리 알 방법이 없다.</strong></p>
</li>
<li>
<p>따라서, Burst Time을 예측해야한다.</p>
<blockquote>
<p>CPU Burst Time을 Burst Time으로 줄여서 이야기하겠다.</p>
</blockquote>
</li>
<li>
<p>SJF의 종류</p>
<ul>
<li><strong>SJF는 ‘선점형’, ‘비선점형’ 모두 존재한다.</strong></li>
<li>선점형의 경우, 가장 적게 남은 시간을 우선한다.</li>
</ul>
<blockquote>
<p>이후에, 예시를 통해 설명한다.</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>예측 방법
<ul>
<li><strong>‘다음 프로세스의 버스트길이’가 ‘직전 프로세스의 버스트길이’와 비슷할 것이다.</strong></li>
<li>위 가정을 통해, 버스트 길이(Time)를 예측한다.</li>
</ul>
</li>
<li>예측 함수
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau_%7Bn+1%7D=%5Calpha%7Bt_n%7D+(1-%5Calpha)%5Ctau_n" alt="O(n^2)" /></li>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau_%7Bn+1%7D" alt="O(n^2)" /> : 다음 프로세스(n+1)의 버스트 길이 예측값</li>
<li><img src="https://latex.codecogs.com/svg.image?%5Calpha" alt="O(n^2)" /> : 가중치 (일반적으로 1/2로 설정한다.)</li>
<li><img src="https://latex.codecogs.com/svg.image?t_n" alt="O(n^2)" /> : 직전 프로세스(n)의 실제 버스트 길이</li>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau_n" alt="O(n^2)" /> : 직전 프로세스(n)의 버스트 길이 예측값</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-9">예측 함수의 상황들</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Calpha=0" alt="O(n^2)" /> 인 경우
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau_%7Bn+1%7D=%5Ctau_n" alt="O(n^2)" /></li>
<li>즉, 최근 히스토리(실제값)을 고려하지 않게 된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Calpha=1" alt="O(n^2)" /> 인 경우
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%5Ctau_%7Bn+1%7D=t_n" alt="O(n^2)" /></li>
<li>즉, 최근 히스토리(실제값)만 고려한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="burst-time---">다음 프로세스의 Burst Time 예측 그래프 예시</h3>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2031.png" alt="Untitled" /></p>
<br/>
<h3 id="shortest-remaining-time-first-srtf">Shortest-Remaining-Time-First (SRTF)</h3>
<ul>
<li>SRTF 란?
<ul>
<li><strong>최소잔여우선</strong></li>
<li><strong>선점형 SJF를 SRTF라고 한다.</strong></li>
<li>SRTF는 분석에 있어서, 도착시간이 다른 것과 선점의 개념을 추가한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>SRTF에서 Turnaround Time (총처리시간) 구하기</strong></p>
<ul>
<li>프로세스의 Turnaround Time = 완료시간 - 도착시간</li>
</ul>
</li>
<li>
<p><strong>SRTF에서 Waiting Time (대기시간) 구하기</strong></p>
<ul>
<li>프로세스의 Waiting Time = Turnaround Time - Burst Time</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>바로 예시를 통해 알아보자.</p>
</li>
<li>
<p>가정</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2032.png" alt="Untitled" /></p>
</li>
<li>
<p>간트차트 시각화</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2033.png" alt="Untitled" /></p>
</li>
<li>
<p>평균 대기 시간</p>
<ul>
<li>Turnaround Time
<ul>
<li>P1 Turnaround Time : 17 - 0 = 17</li>
<li>P2 Turnaround Time : 5 - 1 = 4</li>
<li>P3 Turnaround Time : 26 - 2 = 24</li>
<li>P4 Turnaround Time : 10 - 3 = 7</li>
</ul>
</li>
<li>Waiting Time
<ul>
<li>P1 Waiting Time : 17 - 8 = 9</li>
<li>P2 Waiting Time : 4 - 4 = 0</li>
<li>P3 Waiting Time : 24 - 9 = 15</li>
<li>P4 Waiting Time : 7 - 5 = 2</li>
</ul>
</li>
<li>평균 대기 시간
<ul>
<li>(9 + 0 + 15 + 2) / 4 = 6.5</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="cpu-----1">CPU 스케줄링 종류: 우선순위 스케줄링</h2>
<h3 id="priority-scheduling">Priority Scheduling</h3>
<ul>
<li>Priority Scheduling 란?
<ul>
<li>우선순위 스케줄링</li>
<li>각 프로세스에 숫자로 우선순위를 표기한다.</li>
<li>그리고 우선순위에 따라, 스케줄링 한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>Priority Scheduling 종류
<ul>
<li><strong>선점형(Preemptive) Priority Scheduling</strong>
<ul>
<li>‘새로 도착한 프로세스의 우선순위’가 ‘현재 실행되는 프로세스의 우선순위’보다 높으면 CPU를 선점한다.</li>
</ul>
</li>
<li><strong>비선점형(Nonpreemptive) Priority Scheduling</strong>
<ul>
<li>우선순위가 가장 높은 프로세스를 Ready Queue의 맨 앞에 넣는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>우선순위는 Burst Time(길이)에 반비례한다.
<ul>
<li>긴 Burst ⇒ 낮은 우선순위</li>
<li>짧은 Burst ⇒ 높은 우선순위</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>문제점
<ul>
<li><strong>우선순위 스케줄링의 경우, 기아상태가 발생할 수 있다.</strong></li>
<li>기아상태: 낮은 우선순위의 프로세스가 계속해서 대기만 하는 상태</li>
</ul>
</li>
<li>해결방안
<ul>
<li><strong>Aging 기법을 도입한다.</strong></li>
<li>Aging : 기다린 시간에 비례해서 우선순위를 점점 증가시키는 방법</li>
</ul>
</li>
</ul>
<br/>
<h3 id="priority-scheduling-">Priority Scheduling 예시</h3>
<ul>
<li>
<p>가정</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2034.png" alt="Untitled" /></p>
<ul>
<li>도착시간은 없으므로, 비선점형 우선순위 스케줄링이라고 가정한다.</li>
<li>보통 Burst Time을 고려해서, 우선순위를 결정하지만 정확하지 않을 수 있다.</li>
</ul>
</li>
<li>
<p>간트차트 시각화</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2035.png" alt="Untitled" /></p>
<ul>
<li>단순히 우선순위가 가장 높은 순서대로 실행된다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="cpu-----2">CPU 스케줄링 종류: 라운드 로빈</h2>
<h3 id="round-robin">Round Robin</h3>
<ul>
<li>Round Robin이란?
<ul>
<li>시분할 시스템을 위해 설계된 스케줄링 방식이다.</li>
<li>각 프로세스는 ‘10~100 밀리초’의 CPU 시간을 할당 받는다.
<ul>
<li>시간할당량(CPU 시간) = q (Quantum)</li>
</ul>
</li>
<li>시간 q가 지나면, 실행 중이던 프로세스가 선점당하여 준비완료 큐의 끝에 가게 된다.
<ul>
<li>선점: 새치기</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>예시
<ul>
<li>가정
<ul>
<li>준비완료 큐: 5개의 프로세스 존재</li>
<li>q : 20밀리초</li>
</ul>
</li>
<li>이때, 각 프로세스는 매 100밀리초마다 최대 20밀리초를 할당받게 된다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="q--">시간할당량(q)에 따른 성능</h3>
<ul>
<li><strong>q가 너무 클 때</strong>
<ul>
<li>FCFS와 동일하게 동작한다.</li>
<li>Convoy Effect 가 발생할 수 있다.</li>
</ul>
</li>
<li><strong>q가 너무 작을 때</strong>
<ul>
<li>Context Switching 이 너무 빈번하게 일어난다.</li>
<li>따라서 오버헤드가 자주 발생하여 성능이 떨어진다.</li>
</ul>
</li>
<li>정리
<ul>
<li>따라서 시간할당량(q)는 보통 10ms ~ 100ms로 설정한다.</li>
<li>그리고 Context Switching 시 오버헤드는 10마이크로초 이내여야 한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="round-robin-">Round Robin 예시</h3>
<ul>
<li>
<p>가정</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2036.png" alt="Untitled" /></p>
</li>
<li>
<p>간트차트 시각화</p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2037.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="round-robin--1">Round Robin 특징</h3>
<ul>
<li>일반적으로 SJF 보다 높은 평균 처리시간(Turnaround Time)을 갖는다.</li>
<li>응답시간(Response Time) 측면에서는 RR방식이 더 우수하다.
<ul>
<li>각 프로세스들에게 공평하게 기회를 주기 때문이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="time-quantumq-context-switching--">Time Quantum(q)와 Context Switching 간의 관계</h3>
<ul>
<li>
<p>가정</p>
<ul>
<li>프로세스의 CPU 시간은 10이다. (Burst Time = 10)</li>
</ul>
</li>
<li>
<p><strong>q가 12일 때</strong></p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2038.png" alt="Untitled" /></p>
<ul>
<li>Context Switching이 일어나지 않는다.</li>
</ul>
</li>
<li>
<p><strong>q가 6일 때</strong></p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2039.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>q가 1일 때</strong></p>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2040.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="time-quantumq-turnaround-time---">Time Quantum(q)와 Turnaround Time 간의 관계 예시</h3>
<p><img src="/assets/img/2021-11-10-OS_CPU_Scheduling/Untitled%2041.png" alt="Untitled" /></p>
<ul>
<li>결론
<ul>
<li>프로세스들 중 80%가 ‘q보다 낮은 Burst Time’을 가져야 한다.</li>
<li>이때, 일반적으로 좋은 성능을 기대할 수 있다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET