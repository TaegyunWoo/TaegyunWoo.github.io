I"$?<p><br/><br/></p>
<h1 id="section">개요</h1>
<p>이번 포스팅은 Java가 제공하는 메서드 <code>equals</code> 와 <code>hashCode</code>에 대해 알아볼 것이다. 먼저 이 메서드들이 어떤 기능을 하는지 알아보고, 왜 이런 기능들이 필요한지, 어디에서 사용되는지 알아볼 것이다.</p>
<blockquote>
<p>참고로, HashTable이나 HashMap과 같은 자료구조가 어떻게 동작하는지 알고 있어야 본 글을 이해할 수 있다. 해당 자료구조와 알고리즘에 대한 내용은 <a href="https://taegyunwoo.github.io/algorithm/ALGORITHM_HashAlgorithm">[알고리즘] 해시알고리즘</a>을 참고하자.</p>
</blockquote>
<p><br/><br/></p>
<h1 id="codeequalscode-codehashcodecode--"><code>equals</code>와 <code>hashCode</code> 메서드의 기능</h1>
<h2 id="codeequalscode--"><code>equals</code> 메서드의 기능</h2>
<h3 id="section-1">동일성과 동등성</h3>
<p>먼저 <code>equals</code> 메서드가 어떤 기능을 하는지 알아보기 전에, 동일성 비교와 동등성 비교에 대해 알아보자. 동일성과 동등성에 대한 내용은 아래와 같다.</p>
<ul>
<li>동일성
<ul>
<li>객체의 참조(주소값)를 비교한다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span> <span class="c1">//참조 = 0x10</span>
<span class="nc">Member</span> <span class="n">memberB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span> <span class="c1">//참조 = 0x20</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">memberA</span> <span class="o">==</span> <span class="n">memberB</span><span class="o">);</span> <span class="c1">// 결과: false</span>
</code></pre></div></div>
<ul>
<li>위 코드에서 인스턴스 <code>memberA</code>와 <code>memberB</code>는 서로 다른 메모리 주소에 위치한다. 왜냐하면 <code>new</code> 연산자를 통해, <strong>서로 다른 메모리를 할당받아 인스턴스를 생성했기 때문</strong>이다.</li>
<li>따라서, <code>==</code> 연산자를 통해 동일성을 비교하면 결과가 false이다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>동등성
<ul>
<li>객체의 내용(필드값)을 비교한다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// [Member 클래스의 equals 메서드가 동등성 비교를 위해,</span>
<span class="c1">// 적절하게 오버라이딩되었다고 가정하자.]</span>
<span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span> <span class="c1">//참조 = 0x10</span>
<span class="nc">Member</span> <span class="n">memberB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span> <span class="c1">//참조 = 0x20</span>

<span class="c1">// [Member 클래스에는 id이라는 필드가 하나 존재한다고 가정하자.]</span>
<span class="c1">//서로 같은 필드값으로 설정되었다.</span>
<span class="n">memberA</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">memberB</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">memberA</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">memberB</span><span class="o">));</span> <span class="c1">// 결과: true</span>
</code></pre></div></div>
<ul>
<li>위 코드에서, 인스턴스 <code>memberA</code>와 <code>memberB</code>는 서로 다른 주소값을 갖는다.</li>
<li>이때 두 인스턴스에 대해, <code>equals</code> 메서드로 동등성 비교를 하면 결과가 true이다.</li>
<li><strong><code>Member</code> 클래스의 유일한 필드인 <code>id</code>의 값이 서로 같기 때문</strong>이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="codeequalscode---1"><code>equals</code> 메서드의 기능</h3>
<p>위에서 살펴보았듯이, <code>equals</code> 메서드는 두 객체 간의 동등성을 비교하기 위한 메서드이다. 해당 메서드는 <code>Object</code>에 선언되어있으며, Java의 모든 객체는 Object를 상속받았으므로 <strong>모든 객체 간의 동등성을 비교할 수 있는 것</strong>이다.</p>
<p>하지만, <code>Object</code>에 선언된 <code>equals</code> 메서드를 그저 사용만 하면 되는 것은 아니다. 해당 메서드는 기본적으로 아래와 같이 선언되어있다.</p>
<blockquote>
<p>실제로 아래와 완전히 동일하다는 것은 아니다. 이해를 위해, 아래와 같이 설명한다.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Object</span> <span class="o">{</span>

  <span class="c1">//...</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">;</span> <span class="c1">//동일성을 비교한다.</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p>즉, 기본적인 <code>equals</code> 메서드는 동일성을 비교하는 내용을 작성되어있다. <strong>따라서, 해당 메서드를 오버라이드하여 동등성을 비교할 수 있도록 수정해야 한다.</strong> 이에 대한, 예시 코드는 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="na">id</span><span class="o">;</span> <span class="c1">//내용만을 비교한다.</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<br/>
<h2 id="codehashcodecode--"><code>hashCode</code> 메서드의 기능</h2>
<p>위에서 <code>equals</code> 메서드에 대해 알아보았다. 이번에는 <code>hashCode</code> 메서드에 대해 알아보자. 이 메서드는 <code>equals</code>와 같이 <code>Object</code> 클래스에 선언되어 있다. 따라서, 모든 객체에서 사용할 수 있다.</p>
<p>이 메서드는 현재 인스턴스의 해시값을 반환하는 메서드이다. 즉, 해시함수의 역할을 수행하는 메서드라고 생각하면 된다. 이때, 각 객체의 해시코드는 무조건 다르게 나오는 것이 좋은 것일까? 정답은 아니다. 물론 해시코드 값이 동일하게 나오지 않는다면, 해시 관련 자료구조에서 좋은 성능을 보여줄 수 있다. <strong>하지만, 같은 내용을 가지고 있는 객체들이라면 모두 같은 해시코드를 반환해주어야 한다.</strong> 만약 서로 같은 내용을 가지는 객체들의 해시코드가 다르다면, HashTable이나 HashMap에서 이들을 찾을 방도가 없다.</p>
<blockquote>
<p>다시한번 말하지만, 해시알고리즘에 대해 잘 모른다면 <a href="https://taegyunwoo.github.io/algorithm/ALGORITHM_HashAlgorithm">이전 게시글</a>을 참고하자.</p>
</blockquote>
<br/>
<p><code>hashCode</code> 메서드는 <code>equals</code> 메서드와 마찬가지로 <strong>오버라이딩을 통해 직접 구현</strong>해야 한다. 왜냐하면 이것 역시, <code>Object</code> 클래스에 아래 내용과 같이 선언되어 있기 때문이다.</p>
<blockquote>
<p>이것 역시, 실제로 아래와 완전히 동일하다는 것은 아니다. 이해를 위해, 아래와 같이 설명한다.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Object</span> <span class="o">{</span>

  <span class="c1">//...</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// 객체의 메모리주소를 기반으로 값을 반환한다.</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<br/>
<p>즉, 기존에 작성된 <code>hashCode</code> 메서드는 <strong>객체의 주소를 기반으로 해시코드 값을 반환</strong>한다. 따라서 서로 같은 내용을 갖는 객체 간의 해시코드 값이 다르기 출력되기 때문에, <strong>서로 같은 내용을 갖는다면 같은 해시코드를 반환하도록 적절히 오버라이딩</strong>해주어야 한다. 이에 대한 예시코드는 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">id</span><span class="o">;</span> <span class="c1">// 주소가 아닌, 내용을 기준으로 해시코드를 반환한다.</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p><br/><br/></p>
<h1 id="codeequalscode-codehashcodecode----"><code>equals</code>와 <code>hashCode</code>를 같이 오버라이딩해야 하는 이유</h1>
<p>지금까지 <code>equals</code>와 <code>hashCode</code> 메서드가 어떤 기능을 하고, 왜 오버라이딩을 하여 사용해야 하는지 알아보았다. 하지만 여기서 의문이 생긴다. 보통 사람들은 이 두 가지를 모두 동시에 오버라이딩을 해야 한다고 한다. 그 이유는 무엇일까?</p>
<p>그에 대한, 답을 듣기 위해선 먼저 HashTable, HashMap 등의 자료구조가 어떻게 동작하는지 알아야 한다. 참고로 HashTable과 HashMap 등은 큰 작동원리가 모두 같으므로, HashTable을 통해 설명하겠다.</p>
<br/>
<h2 id="hashtable-">HashTable의 동작원리</h2>
<p>HashTable은 아래 그림과 같이 <strong>저장</strong>한다.</p>
<p><img src="/assets/img/2021-10-27-Java_EqualsAndHashcode/Untitled.png" alt="untitled" /></p>
<ol>
<li>HashTable에 넣고자 하는 (Key, Value) 쌍에서 Key만을 Hash 함수에 넣는다.</li>
<li>Hash 함수가 Key 값을 index 값으로 변환해준다.</li>
<li>해당 index에 해당하는 버킷에 (Key, Value)를 하나의 Entry로 저장한다.
<ul>
<li>이때, 다른 Entry가 이미 존재하면 연결리스트 형태로 저장된다.</li>
</ul>
</li>
</ol>
<p>이러한, 과정에서 <code>equals</code>와 <code>hashCode</code> 메서드가 사용된다.</p>
<br/>
<h2 id="hashtable-codehashcodecode-">HashTable과 <code>hashCode</code> 메서드</h2>
<p>HashTable에 특정 데이터를 put하거나 get하려면, <strong>Key 값을 hash화 해야 한다.</strong>  이때, <code>hashCode</code> 메서드가 사용된다.</p>
<p><img src="/assets/img/2021-10-27-Java_EqualsAndHashcode/Untitled%201.png" alt="untitled" /></p>
<ul>
<li>이때 만약, <code>hashCode</code> 메서드가 적절히 오버라이딩되지 않았다면?
<ul>
<li><code>hashTable.get(key객체)</code>를 통해, 원하는 Entry에 접근할 수 없다.</li>
<li>왜냐하면, <strong>key 객체의 모든 필드 값이 같더라도 다른 해시코드를 반환하기 때문</strong>이다.</li>
<li><strong>따라서, <code>hashCode</code> 메서드가 반드시 오버라이딩되어야 한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h2 id="hashtable-codeequalscode-">HashTable과 <code>equals</code> 메서드</h2>
<h3 id="hashtable---put-">HashTable에 특정 데이터를 put할 때</h3>
<ul>
<li>연결리스트에 존재하는 여러 Entry 중 <strong>Key 값을 대상으로 <code>equals</code> 메서드를 적용하여 비교</strong>한다.</li>
<li>만약 ‘연결리스트에 존재하는 모든 Entry의 Key’가 ‘put하려는 Entry의 Key’와 다를 경우, 연결리스트에 ‘put하려는 Entry’를 추가한다.</li>
<li>만약 ‘연결리스트에 존재하는 Entry의 Key’가 ‘put하려는 Entry의 Key’와 같을 경우, 해당 Entry를 ‘put하려는 Entry’로 덮어쓴다.</li>
</ul>
<p><img src="/assets/img/2021-10-27-Java_EqualsAndHashcode/Untitled%202.png" alt="untitled" /></p>
<br/>
<h3 id="hashtable---get-">HashTable에 특정 데이터를 get할 때</h3>
<ul>
<li>연결리스트에 존재하는 여러 Entry 중 <strong>Key 값을 대상으로 <code>equals</code> 메서드를 적용하여 비교</strong>한다.</li>
<li>만약 ‘연결리스트에 존재하는 모든 Entry의 Key’가 ‘get하려는 Key’와 다를 경우, null을 반환한다.</li>
<li>만약 ‘get하려는 Key’와 같은 Entry를 연결리스트에서 찾은 경우, 해당 Entry를 반환한다.</li>
</ul>
<p><img src="/assets/img/2021-10-27-Java_EqualsAndHashcode/Untitled%203.png" alt="untitled" /></p>
<h2 id="section-2">정리</h2>
<p>지금까지 <code>equals</code>와 <code>hashCode</code> 메서드의 목적과 사용방법 그리고 HashTable에서의 사용까지 알아보았다. 지금까지 설명한 내용을 정리하자면 다음과 같다.</p>
<ul>
<li><code>equals</code> 메서드
<ul>
<li><code>equals</code> 메서드는 동등성 비교를 위해 사용된다.</li>
<li>동등성 비교를 하기 위해선, <code>equals</code> 메서드를 적절히 오버라이딩해야 한다.</li>
<li><code>equals</code> 메서드는 HashTable이나 HashMap의 연결리스트에 존재하는 Entry에 대하여, Key 객체의 동등성 비교를 통해 Entry를 덮어씌우거나 가져올 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>hashCode</code> 메서드
<ul>
<li><code>hashCode</code>는 해시코드 값을 반환시킨다.</li>
<li>같은 내용을 갖는 인스턴스에 대해 같은 해시코드 값을 반환받기 위해선, <code>hashCode</code> 메서드를 적절히 오버라이딩해야 한다.</li>
<li><code>hashCode</code> 메서드는 HashTable이나 HashMap에서 버킷에 대한 index를 찾기 위해 사용된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>따라서, 반드시 <code>equals</code>와 <code>hashCode</code> 메서드를 같이 오버라이딩해야 한다. 그렇지 않으면, Hash 관련 자료구조를 사용하기 어렵다.</strong></li>
</ul>
<p><img src="/assets/img/2021-10-27-Java_EqualsAndHashcode/Untitled%204.png" alt="untitled" /></p>
:ET