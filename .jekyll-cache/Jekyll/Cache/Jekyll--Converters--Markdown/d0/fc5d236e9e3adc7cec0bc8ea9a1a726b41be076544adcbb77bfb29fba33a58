I"-<p><br/><br/></p>
<ul>
<li><a href="https://github.com/TaegyunWoo/jpa-study/tree/master/BasicJpaApp">예시 프로젝트 다운로드</a></li>
</ul>
<p><br/><br/></p>
<h1 id="section">엔티티 매핑</h1>
<h2 id="section-1">개요</h2>
<ul>
<li>JPA를 사용하는 데 가장 중요한 일은 엔티티와 테이블을 정확히 매핑하는 것이다.</li>
<li>따라서 매핑 애너테이션을 숙지하고 사용해야 한다.</li>
<li>아래는 매핑 애너테이션의 종류를 분류한 것이다.</li>
</ul>
<br/>
<h3 id="section-2">매핑 애너테이션의 종류</h3>
<ul>
<li><strong>객체와 테이블 매핑</strong>
<ul>
<li><code>@Entity</code></li>
<li><code>@Table</code></li>
</ul>
</li>
<li><strong>기본 키 매핑</strong>
<ul>
<li><code>@Id</code></li>
</ul>
</li>
<li><strong>필드와 컬럼 매핑</strong>
<ul>
<li><code>@Column</code></li>
</ul>
</li>
<li><strong>연관관계 매핑</strong>
<ul>
<li><code>@ManyToOne</code></li>
<li><code>@JoinColumn</code></li>
</ul>
</li>
</ul>
<p>이번 포스팅 글에서는 ‘객체와 테이블 매핑’, ‘기본 키 매핑’, ‘필드와 컬럼 매핑’에 대해 알아보겠다. ‘연관관계 매핑’은 추후에 포스팅할 예정이다.</p>
<p><br/><br/></p>
<h2 id="codeentitycode"><code>@Entity</code></h2>
<h3 id="section-3">애너테이션 설명</h3>
<ul>
<li>테이블과 매핑할 클래스는 <code>@Entity</code> 애너테이션을 필수적으로 붙여야한다.</li>
<li><code>@Entity</code> 가 붙은 클래스는 JPA가 관리하게 된다. 이러한 클래스를 <strong>엔티티</strong>라고 부른다.</li>
</ul>
<br/>
<ul>
<li><code>@Entity</code> 속성 정리</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>기능</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>- JPA에서 사용할 엔티티 이름을 지정한다.  <br/> - 보통 클래스 이름(기본값)을 사용한다. <br/> - 만약 다른 패키지에 이름이 같은 엔티티 클래스가 있다면, 이름을 지정해서 충돌하지 않도록 해야 한다.</td>
<td>클래스 이름을 그대로 사용한다.</td>
</tr>
</tbody>
</table>
<br/>
<h3 id="codeentitycode--"><code>@Entity</code> 적용시 주의사항</h3>
<ul>
<li><strong>기본 생성자가 필수적으로 필요하다.</strong>
<ul>
<li>기본 생성자: 매개변수가 없는 생성자</li>
<li>JPA가 엔티티 객체를 생성할 때, 기본 생성자를 사용하므로 이 생성자가 반드시 필요하다.</li>
</ul>
</li>
<li><strong>final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.</strong></li>
<li><strong>저장할 필드에 final을 사용하면 안된다.</strong></li>
</ul>
<p><br/><br/></p>
<h2 id="codetablecode"><code>@Table</code></h2>
<h3 id="section-4">애너테이션 설명</h3>
<ul>
<li>엔티티와 매핑할 테이블을 지정하는 애너테이션이다.</li>
<li>생략시, 매핑한 엔티티 이름을 테이블 이름으로 사용한다.</li>
</ul>
<br/>
<ul>
<li><code>@Table</code> 속성 정리</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>기능</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>- 매핑할 테이블의 이름</td>
<td>엔티티(클래스)이름 사용</td>
</tr>
<tr>
<td>catalog</td>
<td>- catalog 기능이 있는 DB에서 catalog를 매핑한다.</td>
<td></td>
</tr>
<tr>
<td>schema</td>
<td>-schema 기능이 있는 DB에서 schema를 매핑한다.</td>
<td></td>
</tr>
<tr>
<td>uniqueConstraints</td>
<td>- DDL 생성 시에 유니크 제약조건을 만든다. <br/> - 2개 이상의 복합 유니크 제약조건도 만들 수 있다. <br/> - 자동생성기능을 사용해서 DDL을 만들 때만 사용된다. <br/> (추후 설명 예정)</td>
<td></td>
</tr>
</tbody>
</table>
<p><br/><br/></p>
<h2 id="section-5">다양한 매핑 사용 예시</h2>
<ul>
<li>예시 코드는 글 상단을 참고하자.</li>
</ul>
<br/>
<h3 id="section-6">추가된 요구사항</h3>
<p>기존에 작성한 회원 관리 프로그램에 아래 요구사항이 추가되었다고 하자.</p>
<ol>
<li>회원은 일반 회원과 관리자로 구분된다.</li>
<li>회원 가입일과 수정일이 있어야 한다.</li>
<li>회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.</li>
</ol>
<br/>
<h3 id="codemembercode--"><code>Member</code> 엔티티 수정</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

  <span class="nd">@Id</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"NAME"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>

	<span class="c1">//--------추가 내용-----------</span>
  <span class="nd">@Enumerated</span><span class="o">(</span><span class="nc">EnumType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span> <span class="c1">//Enum Type 매핑시 필요한 애너테이션</span>
  <span class="kd">private</span> <span class="nc">RoleType</span> <span class="n">roleType</span><span class="o">;</span>

  <span class="nd">@Temporal</span><span class="o">(</span><span class="nc">TemporalType</span><span class="o">.</span><span class="na">TIMESTAMP</span><span class="o">)</span> <span class="c1">//날짜 매핑시 필요한 애너테이션</span>
  <span class="kd">private</span> <span class="nc">Date</span> <span class="n">createdDate</span><span class="o">;</span>

  <span class="nd">@Temporal</span><span class="o">(</span><span class="nc">TemporalType</span><span class="o">.</span><span class="na">TIMESTAMP</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Date</span> <span class="n">lastModifiedDate</span><span class="o">;</span>

  <span class="nd">@Lob</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">description</span><span class="o">;</span>

  <span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>roleType</code>
<ul>
<li>자바의 enum을 사용해서 회원 타입을 구분한다.</li>
<li>자바의 enum을 사용하려면 <code>@Enumerated</code> 애너테이션을 통해 매핑해야 한다.</li>
</ul>
</li>
<li><code>createdDate</code> , <code>lastModifiedDate</code>
<ul>
<li>자바의 날짜 타입은 <code>@Temporal</code> 을 사용해서 매핑한다.</li>
</ul>
</li>
<li><code>description</code>
<ul>
<li>회원을 설명하는 필드는 길이 제한이 없다.</li>
<li>DB의 VARCHAR 타입 대신, CLOB 타입으로 저장해야한다.</li>
<li><code>@Lob</code> 애너테이션을 사용하면, CLOB, BLOB 타입을 매핑할 수 있다.</li>
</ul>
</li>
</ul>
<p>각 항목에 대해서는 글 후반부에서 자세히 다룬다.</p>
<br/>
<h3 id="coderoletypecode-enum--"><code>RoleType</code> Enum 클래스 추가</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">RoleType</span> <span class="o">{</span>
	<span class="no">ADMIN</span><span class="o">,</span> <span class="no">USER</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br/><br/></p>
<h2 id="db---">DB 스키마 자동 생성</h2>
<h3 id="jpa---">JPA의 스키마 자동 생성이란?</h3>
<ul>
<li>JPA는 DB 스키마를 자동으로 생성하는 기능을 지원한다.</li>
<li>JPA는 이 매핑정보와 DB 방언을 사용해서 DB 스키마를 생성한다.</li>
</ul>
<br/>
<h3 id="section-7">스키마 자동 생성 기능 사용 설정</h3>
<ul>
<li>스키마 자동 생성 기능을 사용하기 위해, <code>persistence.xml</code> 에 아래 내용을 추가해야한다.</li>
</ul>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.hbm2ddl.auto"</span> <span class="na">value=</span><span class="s">"create"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<ul>
<li><strong>이 속성을 추가하면, APP 실행 시점에 DB 테이블을 자동으로 생성한다.</strong></li>
<li><code>value</code>의 값은 여러 속성으로 변경될 수 있다.</li>
</ul>
<br/>
<h3 id="section-8">스키마 자동 생성 특징</h3>
<ul>
<li>개발자의 수고를 덜어준다.</li>
<li>스키마 자동 생성 기능이 만든 DDL은 운영 환경에서 사용할 만큼 완벽하지는 않다.
<ul>
<li>따라서, 개발 환경에서 사용하거나 매핑을 어떻게 해야 한는지 참호하는 정도로만 사용하는 것이 좋다.</li>
</ul>
</li>
<li>스키마 자동 생성하기는 엔티티와 테이블을 어떻게 매핑해야 하는지 알려주는 가장 훌륭한 학습 도구이다.</li>
</ul>
<br/>
<h3 id="hibernatehbm2ddlauto-">hibernate.hbm2ddl.auto 속성</h3>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.hbm2ddl.auto"</span> <span class="na">value=</span><span class="s">"create"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<p>위 코드에서 <code>value</code> 의 값을 변경하여 다양한 옵션을 적용할 수 있다.</p>
<br/>
<ul>
<li>hibernate.hbm2ddl.auto 속성</li>
</ul>
<table>
<thead>
<tr>
<th>옵션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>- 기존 테이블이 존재한다면, 해당 테이블을 삭제하고 새로 생성한다.<br/> - DROP+CREATE</td>
</tr>
<tr>
<td>create-drop</td>
<td>- create 옵션과 함께, 애플리케이션 종료시 생성한 DDL을 제거한다.<br/>- DROP+CREATE+DROP</td>
</tr>
<tr>
<td>update</td>
<td>- DB 테이블과 엔티티 매핑정보를 비교해서 변경사항만 수정한다.</td>
</tr>
<tr>
<td>validate</td>
<td>- DB 테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고 애플리케이션을 실행하지 않는다.<br/>- DDL을 수정하지 않는다.</td>
</tr>
<tr>
<td>none</td>
<td>- 자동 생성 기능을 사용하지 않도록 한다.<br/>- 단순히 관련 &lt;property&gt; 태그를 없애도 된다.</td>
</tr>
</tbody>
</table>
<br/>
<h3 id="section-9">주의사항</h3>
<ul>
<li>운영서버에서 <code>create</code> , <code>create-drop</code> , <code>update</code> 처럼 DDL을 수정하는 옵션은 절대로 사용하면 안된다.</li>
<li>왜냐하면, 운영 DB의 정보가 날라갈 수 도 있고 임의적으로 변경될 수 있기 때문이다.</li>
<li>개발 환경에 따른 추천 전략
<ul>
<li>테스트 서버
<ul>
<li><code>update</code></li>
<li><code>validate</code></li>
</ul>
</li>
<li>스테이징과 운영 서버
<ul>
<li><code>validate</code></li>
<li><code>none</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="ddl--">DDL 생성 기능</h2>
<h3 id="section-10">추가된 제약조건</h3>
<ul>
<li>회원 이름
<ul>
<li>필수적으로 입력해야한다.</li>
<li>10자를 초과하면 안된다.</li>
</ul>
</li>
</ul>
<p>위 제약조건을 예시 프로젝트에 추가해보자.</p>
<br/>
<h3 id="codemembercode---1"><code>Member</code> 엔티티 수정</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

  <span class="nd">@Id</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"NAME"</span><span class="o">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">false</span><span class="o">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="o">)</span> <span class="c1">//제약조건 추가</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

  <span class="c1">// 나머지 생략...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li>
<p><code>nullable=false</code></p>
<ul>
<li>자동 생성되는 DDL에 <code>not null</code> 제약조건을 추가할 수 있다.</li>
</ul>
</li>
<li>
<p><code>length</code></p>
<ul>
<li>자동 생성되는 DDL에 문자의 크기를 지정할 수 있다.</li>
</ul>
</li>
<li>
<p>위 코드를 통해 자동으로 만들어진, 테이블 생성 SQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">MEMBER</span> <span class="p">(</span>
	<span class="n">ID</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
	<span class="n">NAME</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">not</span> <span class="n">nullm</span>
	<span class="p">...</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">ID</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>
<ul>
<li>DDL의 NAME 컬럼을 보면, <code>not null</code> 제약조건이 추가되었음을 확인할 수 있다.</li>
<li>또한, <code>varchar(10)</code> 으로 문자의 크기가 10자리로 제한되었다.</li>
</ul>
</li>
<li>
<p>이번에는 유니크 제약조건을 만들어보자.</p>
<ul>
<li>유니크 제약조건: 중복된 값을 허락하지 않는 것, 여러 컬럼 조합에 대해서 중복이 되지 않도록 설정할 수도 있다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">,</span> <span class="n">uniqueConstraints</span> <span class="o">=</span> <span class="o">{</span>
	<span class="nd">@UniqueConstraint</span><span class="o">(</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">"NAME_AGE_UNIQUE"</span><span class="o">,</span> <span class="c1">// 제약조건 이름 설정</span>
		<span class="n">columnNames</span> <span class="o">=</span> <span class="o">{</span><span class="s">"NAME"</span><span class="o">,</span> <span class="s">"AGE"</span><span class="o">}</span> <span class="c1">//NAME과 AGE 칼럼의 조합이 중복되는 튜플 허가 X</span>
	<span class="o">)</span>
<span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

  <span class="nd">@Id</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"NAME"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

  <span class="c1">// 나머지 생략...</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p><strong>이런 기능들은 오직 DDL을 자동 생성할 때만 사용된다.</strong></p>
</li>
<li>
<p><strong>실제 JPA 실행 로직에는 영향을 주지 않는다.</strong></p>
</li>
<li>
<p>해당 기능을 사용하면 애플리케이션 개발자가 엔티티만 보고도 손쉽게 다양한 제약조건을 파악할 수 있는 장점이 있다.</p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-11">기본 키 매핑</h2>
<h3 id="section-12">기본 키를 매핑하는 방법들</h3>
<p>기존에는 <code>@Id</code> 애너테이션만 사용하여 기본키를 매핑하였다. 이러한 방식은 애플리케이션에서 (로직상) 직접 값을 할당하여 매핑하는 방식이었다. 그렇다면, DB가 생성해주는 값을 사용하려면 어떻게 매핑해야 할까?</p>
<p>아래는 JPA가 제공하는 DB 기본 키 생성 전략의 종류이다.</p>
<ul>
<li><strong>직접 할당</strong>
<ul>
<li>기본 키를 애플리케이션에서 직접 할당한다.</li>
</ul>
</li>
<li><strong>자동 생성</strong>
<ul>
<li>대리 키를 사용하는 방식이다.</li>
<li><strong>IDENTITY</strong>
<ul>
<li>기본 키를 애플리케이션에서 직접 할당한다.</li>
</ul>
</li>
<li><strong>SEQUENCE</strong>
<ul>
<li>DB 시퀀스를 사용해서 기본 키를 할당한다.</li>
</ul>
</li>
<li><strong>TABLE</strong>
<ul>
<li>키 생성 테이블을 사용한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>이처럼 다양한 방식으로 기본 키를 할당할 수 있다. 그 중 자동 생성을 통해 기본 키를 매핑하는 방식은 총 3가지 있는데, 이것은 DB 벤더(제조사)마다 지원하는 방식이 다르기 때문이다.</p>
<br/>
<h3 id="section-13">설정 추가</h3>
<p>키 생성 전략을 사용하기 전에, <code>persistence.xml</code> 에 아래 속성을 추가해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">"hibernate.id.new_generator_mappings"</span> <span class="n">value</span><span class="o">=</span><span class="s">"true"</span> <span class="o">/&gt;</span>
</code></pre></div></div>
<p>이제 본격적으로, 기본 키 할당 전략에 대해 자세히 알아보자.</p>
<br/>
<h3 id="section-14">기본키 직접 할당 전략</h3>
<ul>
<li>기본 키를 직접 할당하려면 다음 코드와 같이 <code>@Id</code>로 매핑하면 된다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span>
<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
</code></pre></div></div>
<ul>
<li>
<p><code>@Id</code> 적용 가능한 자바 타입은 아래와 같다.</p>
<ul>
<li>자바 기본형</li>
<li>자바 래퍼형 (wrapper)</li>
<li>String</li>
<li>java.util.Date</li>
<li>java.sql.Date</li>
<li>java.math.BigDecimal</li>
<li>java.math.BigInteger</li>
</ul>
</li>
<li>
<p>기본키 직접 할당 전략은 <code>em.persist()</code> 로 <strong>엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법</strong>이다. 이에 대한 예시 코드는 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
<span class="n">board</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"id1"</span><span class="o">);</span> <span class="c1">//기본 키 직접 할당</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
</code></pre></div></div>
</li>
<li>
<p>만약 식별자 값 없이 저장(<code>em.persist()</code>)하면 예외가 발생한다.</p>
</li>
</ul>
<br/>
<h3 id="identity-">IDENTITY 전략</h3>
<ul>
<li>
<p>IDENTITY는 기본 키 생성을 DB에 위임하는 전략이다.</p>
</li>
<li>
<p>주로 MySQL 등에서 사용한다. 예시는 아래와 같다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">BOARD</span> <span class="p">(</span>
	<span class="n">ID</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
	<span class="n">MY_DATA</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">BOARD</span><span class="p">(</span><span class="n">MY_DATA</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="s1">'A'</span><span class="p">);</span> <span class="o">//</span><span class="n">ID</span><span class="err">값</span> <span class="err">없이</span> <span class="err">튜플을</span> <span class="err">저장한다</span><span class="p">.</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">BOARD</span><span class="p">(</span><span class="n">MY_DATA</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="s1">'B'</span><span class="p">);</span> <span class="o">//</span><span class="n">ID</span><span class="err">값</span> <span class="err">없이</span> <span class="err">튜플을</span> <span class="err">저장한다</span><span class="p">.</span>
</code></pre></div></div>
<ul>
<li>여기서 <strong>AUTO_INCREMENT</strong> 옵션을 통해, DB가 직접 기본키 값을 생성해준다.</li>
<li>따라서, 추가하려는 튜플의 ID 칼럼의 값을 지정할 필요가 없다.</li>
</ul>
</li>
<li>
<p><strong>IDENTITY 전략은 DB에 값을 저장하고 나서야 기본 키 값을 구할 수 있을 때 사용한다.</strong></p>
</li>
</ul>
<br/>
<ul>
<li>
<p>DB가 생성한 키 값을 엔티티에 바인딩하려면 <code>@GeneratedValue</code> 애너테이션을 사용해야 한다. 이에 대한 예시코드는 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span> <span class="c1">//IDENTITY 전략 사용 설정</span>
	<span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>

	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><strong><code>@GeneratedValue</code> 의 <code>strategy</code> 속성의 값을 <code>GenerationType.IDENTITY</code> 로 설정한다.</strong></li>
<li><strong>이 전략을 사용하면, JPA는 기본 키 값을 얻어오기 위해 DB를 추가로 조회한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>IDENTITY 전략을 통한, 엔티티 활용 예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span> <span class="c1">//기본키 지정없이 DB에 저장</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"board.id = "</span> <span class="o">+</span> <span class="n">board</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span>
<span class="c1">// 출력: board.id = 1</span>
</code></pre></div></div>
<ul>
<li>이때 출력된 값 ‘1’은 <strong>저장 시점에 DB가 생성한 값을 JPA가 조회한 것</strong>이다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>IDENTITY 전략의 최적화</strong>
<ul>
<li>엔티티에 식별자 값을 할당하려면 JPA는 추가로 DB를 조회해야 한다.</li>
<li>이때 성능이 저하된다.</li>
<li><strong><code>Statement.getGeneratedKeys()</code> 를 사용하면, 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어 올 수 있다.</strong></li>
<li>따라서, <strong>하이버네이트는 이 메서드를 사용해서 DB와 한 번만 통신한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>IDENTITY 전략과 영속성 컨텍스트</strong>
<ul>
<li>엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다.</li>
<li>하지만, IDENTITY 전략은 엔티티를 DB에 저장해야만 식별자를 구할 수 있다.</li>
<li><strong>따라서, <code>em.persist()</code> 를 호출하는 즉시 INSERT SQL이 DB에 전달된다.</strong></li>
<li><strong>결론적으로 이 전략은 트랜잭션을 지원하는 “쓰기 지연”이 작동하지 않는다.</strong></li>
<li><strong>DB에 데이터가 저장되고 난 후에서야, 엔티티가 영속성 컨텍스트에 등록된다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="sequence-">SEQUENCE 전략</h3>
<ul>
<li>데이터베이스 시퀀스란?
<ul>
<li>유일한 값을 순서대로 생성하는 특별한 DB 오브젝트이다.</li>
</ul>
</li>
<li>SEQUENCE 전략은 이 시퀀스를 사용해서 기본 키를 생성한다.</li>
<li>오라클, H2 등에서 사용할 수 있다.</li>
</ul>
<br/>
<ul>
<li>전략 사용법
<ol>
<li>
<p>시퀀스 생성</p>
<ul>
<li>DB에 시퀀스를 생성해야한다.</li>
</ul>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">BOARD</span> <span class="p">(</span>
	<span class="n">ID</span> <span class="nb">BIGINT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
	<span class="n">MY_DATA</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="p">)</span>

<span class="o">//</span><span class="err">시퀀스</span> <span class="err">생성</span>
<span class="k">CREATE</span> <span class="n">SEQUENCE</span> <span class="n">BOARD_SEQ</span> <span class="k">START</span> <span class="k">WITH</span> <span class="mi">1</span> <span class="k">INCREMENT</span> <span class="k">BY</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
</li>
<li>
<p>시퀀스 매핑</p>
<ul>
<li>애플리케이션으로 돌아와서, 시퀀스 매핑 코드를 아래와 같이 작성한다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@SequenceGenerator</span><span class="o">(</span>
	<span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_SEG_GENERATOR"</span><span class="o">,</span> <span class="c1">//식별자 생성기 이름</span>
	<span class="n">sequenceName</span> <span class="o">=</span> <span class="s">"BOARD_SEQ"</span><span class="o">,</span> <span class="c1">// DB에 등록되어 있는 시퀀스 이름</span>
	<span class="n">initialValue</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="c1">// DDL 생성할 때, 처음 시작하는 수를 지정한다.</span>
	<span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">//시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">SEQUENCE</span><span class="o">,</span>
							<span class="n">generator</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span><span class="o">)</span> <span class="c1">//사용할 시퀀스 생성기 이름</span>
	<span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>

	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li><code>@SequenceGenerator</code> 애너테이션
<ul>
<li>해당 애너테이션을 사용해서, <code>BOARD_SEQ_GENERATOR</code> 라는 시퀀스 생성기를 등록한다.</li>
<li>또한, JPA가 시퀀스 생성기를 실제 DB에서 매핑할 시퀀스인 <code>BOARD_SEQ</code> 와 연결한다.</li>
<li>아래는 관련 속성에 대한 설명이다.</li>
<li><code>name</code>
<ul>
<li>식별자 생성기 이름을 설정한다.</li>
</ul>
</li>
<li><code>sequenceName</code>
<ul>
<li>DB에 등록되어 있는 시퀀스 이름을 설정한다.</li>
</ul>
</li>
<li><code>initialValue</code>
<ul>
<li>DDL 생성 시에만 사용된다.</li>
<li>시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정한다.</li>
<li>기본값 = 1</li>
</ul>
</li>
<li><code>allocationSize</code>
<ul>
<li>시퀀스 한 번 호출에 증가하는 수를 설정한다.</li>
<li>성능 최적화에 사용된다.</li>
<li>기본값 = 50</li>
<li>자세한 설명은 나중에 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>@GeneratedValue</code> 애너테이션
<ul>
<li>키 생성 전략을 <code>GenerationType.SEQUENCE</code> 로 설정한다.</li>
<li><code>generator</code> 속성을 통해, <code>BOARD_SEQ_GENERATOR</code> 시퀀스 생성기를 선택한다.
<ul>
<li><code>BOARD_SEQ_GENERATOR</code> 는 위에서 <code>@SequenceGenerator</code> 를 통해 만든 생성기의 이름이다.</li>
</ul>
</li>
<li>그러면 이제부터 <code>id</code> 프로퍼티 식별자 값은 <code>BOARD_SEQ_GENERATOR</code> 시퀀스 생성기가 할당한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>SEQUENCE 전략을 통한, 엔티티 활용 예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span> <span class="c1">//기본키 지정없이 DB에 저장</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"board.id = "</span> <span class="o">+</span> <span class="n">board</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span>
<span class="c1">// 출력: board.id = 1</span>
</code></pre></div></div>
<ul>
<li>코드 자체는 위에서 설명한 IDENTITY 전략과 같다. 하지만 내부 동작 방식은 다르다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>SEQUENCE 전략의 내부 동작 순서
<ol>
<li><code>em.persist()</code> 를 호출할 때, <strong>먼저 DB 시퀀스를 사용해서 식별자를 조회</strong>한다.</li>
<li><strong>조회한 식별자를 엔티티에 할당한 후에, 엔티티를 영속성 컨텍스트에 저장</strong>한다.</li>
<li>트랜잭션을 커밋하여 <strong>플러시가 일어나면 엔티티를 DB에 저장</strong>한다.</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>IDENTITY 전략 vs SEQUENCE 전략
<ul>
<li>IDENTITY 전략
<ol>
<li><strong>엔티티를 먼저 DB에 저장한다.</strong></li>
<li>식별자를 조회해서 다시 엔티티에 바인딩한다.</li>
<li>이제 엔티티를 영속성 컨텍스트에 저장한다.</li>
</ol>
</li>
<li>SEQUENCE 전략
<ol>
<li><strong>먼저 시퀀스를 사용하여 식별자를 조회한다.</strong></li>
<li>조회된 식별자를 엔티티에 바인딩한다.</li>
<li>엔티티를 영속성 컨텍스트에 저장한다.</li>
<li>트랜잭션이 커밋되어 플러시가 일어나면, DB에 엔티티를 저장한다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>@SequenceGenerator.allocationSize</code> 속성
<ul>
<li>
<p>JPA가 생성하는 기본 시퀀스</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">SEQUENCE</span> <span class="p">[</span><span class="n">sequence_name</span><span class="p">]</span> <span class="k">START</span> <span class="k">WITH</span> <span class="mi">1</span> <span class="k">INCREMENT</span> <span class="k">BY</span> <span class="mi">50</span>
</code></pre></div></div>
<ul>
<li>즉, JPA가 기본적으로 생성하는 시퀀스는 50씩 증가한다.</li>
</ul>
</li>
<li>
<p>따라서, <code>@SequenceGenerator.allocationSize</code> 의 기본값도 50으로 설정되어있다.</p>
</li>
<li>
<p>만약 <strong>DB 시퀀스 값이 1씩 증가한다면, 반드시 값을 1로 설정해야 한다.</strong></p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>SEQUENCE 전략과 최적화</strong>
<ul>
<li>SEQUENCE 전략은 DB 시퀀스를 통해, 식별자를 조회하는 추가 작업이 필요하다.</li>
<li>따라서, DB와 2번 통신하게 된다.
<ul>
<li>먼저 식별자를 구하려고, DB 시퀀스를 조회하는 통신</li>
<li>조회한 시퀀스를 기본 키 값으로 사용해서, DB에 저장하는 통신</li>
</ul>
</li>
<li>그에 따라, JPA는 시퀀스에 접근하는 횟수를 줄이기 위해 <code>@SequenceGenerator.allocationSize</code> 를 사용한다.</li>
<li><code>@SequenceGenerator.allocationSize</code>에 설정한 값만큼, 한 번에 시퀀스 값을 증가시키고 나서 그만큼 메모리에 시퀀스 값을 할당한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="table-">TABLE 전략</h3>
<ul>
<li>TABLE 전략은 <strong>키 생성 전용 테이블을 하나 만들고, 여기에 이름과 값으로 사용할 칼럼을 만들어 DB 시퀀스를 흉내내는 전략</strong>이다.</li>
<li>이 전략은 모든 DB에 적용할 수 있다.</li>
</ul>
<br/>
<ul>
<li>전략 사용법
<ol>
<li>
<p>키 생성 테이블 만들기</p>
<ul>
<li>키 생성 용도로 사용할 테이블을 만들어야 한다.</li>
</ul>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">MY_SEQUENCES</span> <span class="p">(</span>
	<span class="n">sequence_name</span> <span class="n">VARCHER</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">next_val</span> <span class="nb">BIGINT</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">sequence_name</span><span class="p">)</span>
<span class="err">}</span>
</code></pre></div></div>
<ul>
<li><code>sequence_name</code> : 시퀀스 이름을 저장할 칼럼</li>
<li><code>next_val</code> : 시퀀스 값을 저장할 칼럼</li>
<li><strong>위 칼럼명들은 TABLE 전략에서 사용되는 기본적인 이름이다.</strong>
<ul>
<li>칼럼명을 변경할 수 있지만, 나중에 설명하도록 하겠다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>시퀀스 매핑</p>
<ul>
<li>애플리케이션으로 돌아와서, 테이블 전략 매핑 코드를 아래와 같이 작성한다.</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@TableGenerator</span><span class="o">(</span>
	<span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_SEG_GENERATOR"</span><span class="o">,</span> <span class="c1">//식별자 생성기 이름</span>
	<span class="n">table</span> <span class="o">=</span> <span class="s">"MY_SEQUENCES"</span><span class="o">,</span> <span class="c1">// DB에 등록되어 있는 키 생성 테이블 이름</span>
	<span class="n">pkColumnValue</span> <span class="o">=</span> <span class="s">"BOARD_SEQ"</span> <span class="c1">// 사용할 시퀀스 이름</span>
	<span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">//시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">TABLE</span><span class="o">,</span>
							<span class="n">generator</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span><span class="o">)</span> <span class="c1">//사용할 테이블 키 생성기 이름</span>
	<span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>

	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li><code>@TableGenerator</code> 애너테이션
<ul>
<li>해당 애너테이션을 사용하여, 테이블 키 생성기를 등록한다.</li>
<li><code>BOARD_SEQ_GENERATOR</code> 라는 이름으로 테이블 키 생성기를 등록한다.</li>
<li>위에서 생성한 <code>MY_SEQUENCES</code> 테이블을 키 생성용 테이블로 매핑한다.</li>
<li>아래는 관련 속성에 대한 설명이다.</li>
<li><code>name</code>
<ul>
<li>식별자 생성기 이름을 설정한다.</li>
</ul>
</li>
<li><code>table</code>
<ul>
<li>DB의 키 생성 테이블 이름을 설정한다.</li>
<li>기본값 = hibernate_sequences</li>
</ul>
</li>
<li><code>pkColumnName</code>
<ul>
<li>시퀀스 칼럼명을 설정한다.</li>
<li><strong>기본값 = sequence_name</strong></li>
</ul>
</li>
<li><code>valueColumnName</code>
<ul>
<li>시퀀스 값 칼럼명을 설정한다.</li>
<li><strong>기본값 = next_val</strong></li>
</ul>
</li>
<li><code>pkColumnValue</code>
<ul>
<li>키로 사용할 값 이름을 설정한다.</li>
<li><strong>기본값 = 엔티티 이름</strong></li>
</ul>
</li>
<li><code>initialValue</code>
<ul>
<li>초기 값을 설정한다.</li>
<li>마지막으로 생성된 값이 기준이다.</li>
</ul>
</li>
<li><code>allocationSize</code>
<ul>
<li>시퀀스 한 번 호출에 증가하는 수를 설정한다.</li>
<li>성능 최적화에 사용된다.</li>
<li>기본값 = 50</li>
</ul>
</li>
<li><code>uniqueConstraints(DDL)</code>
<ul>
<li>유니크 제약 조건을 지정할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>위 속성 중 table, pkColumnName, valueColumnName 의 기본값은 하이버네이트 기준이다.</p>
</blockquote>
<br/>
<ul>
<li><code>@GeneratedValue</code> 애너테이션
<ul>
<li>해당 애너테이션을 사용하여, 등록된 테이블 키 생성기를 사용한다.</li>
<li><code>GenerationType.TABLE</code> 을 선택하여 TABLE 전략을 선택한다.</li>
<li><code>@GeneratedValue.generator</code> 속성에 방금 만든 테이블 키 생성기를 지정한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>TABLE 전략을 통한, 엔티티 활용 예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span> <span class="c1">//기본키 지정없이 DB에 저장</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"board.id = "</span> <span class="o">+</span> <span class="n">board</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span>
<span class="c1">// 출력: board.id = 1</span>
</code></pre></div></div>
<ul>
<li>시퀀스 대신 테이블을 사용한다는 것을 제외하면, 시퀀스 전략과 내부동작이 같다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>MY_SEQUENCES</code> 키 생성 테이블의 변화
<ol>
<li>
<p>초기 상태</p>
<p><img src="/assets/img/2021-10-11-JPA_EntityMapping/Untitled%2021.png" alt="Untitled" /></p>
</li>
<li>
<p>처음 키 생성기 사용시</p>
<ul>
<li>만약 <code>@TableGenerator.pkColumnValue</code> 으로 지정한 이름을 sequence_name 칼럼에서 찾지 못하면 튜플을 새로 추가한다.</li>
</ul>
<p><img src="/assets/img/2021-10-11-JPA_EntityMapping/Untitled%2022.png" alt="Untitled" /></p>
<ul>
<li>next_val 칼럼이 1로 설정되었다가, 해당 값을 생성기에 전달하고 1이 증가되었다.</li>
<li>왜냐하면 next_val, 즉 다음 키 값을 의미하기 때문이다.</li>
</ul>
</li>
<li>
<p>두 번째 키 생성기 사용시</p>
<p><img src="/assets/img/2021-10-11-JPA_EntityMapping/Untitled%2023.png" alt="Untitled" /></p>
<ul>
<li>next_val 칼럼의 값을 생성기에 전달하고 1이 증가되었다.</li>
</ul>
</li>
<li>
<p>같은 키 생성 테이블을 사용하지만, <code>@TableGenerator.pkColumnValue</code> 속성의 값이 ‘MEMBER_SEQ’인 다른 생성기 사용시</p>
<p><img src="/assets/img/2021-10-11-JPA_EntityMapping/Untitled%2024.png" alt="Untitled" /></p>
<ul>
<li>이와 같이, 다른 테이블에 대한 키 생성을 할 수 있다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>흐름 정리
<ol>
<li><code>em.persist(엔티티A)</code></li>
<li>키 생성 테이블에서 <code>@TableGenerator.pkColumnValue</code> 로 설정한 값을 pk로 갖는 튜플 찾기
<ul>
<li>만약 튜플을 못찾을 경우: JPA가 알아서 INSERT 및 초기화</li>
<li>만약 튜플을 찾을 경우: 해당 튜플의 next_val 칼럼의 값을 가져옴</li>
</ul>
</li>
<li>가져온 next_val 칼럼의 값을 ‘엔티티A.기본키’에 바인딩</li>
<li>해당 튜플의 next_val 칼럼 값에 1을 더하여 값 UPDATE</li>
<li>엔티티A를 영속성 컨텍스트에 등록</li>
</ol>
</li>
</ul>
<br/>
<h3 id="auto-">AUTO 전략</h3>
<ul>
<li>
<p><code>[GenerationType.AUTO](http://GenerationType.AUTO)</code> 는 선택한 DB 방언에 따라, IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다.</p>
</li>
<li>
<p>예시 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span> <span class="c1">// AUTO 전략 선택</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

	<span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>AUTO 전략 사용시 SEQUENCE나 TABLE 전략이 선택되면, <strong>시퀀스나 키 생성 테이블을 미리 만들어 두어야 한다.</strong>
<ul>
<li>만약, 스키마 자동 생성 기능 (<code>&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&gt;</code>) 을 사용한다면, JPA가 알아서 적절한 테이블이나 시퀀스를 생성해준다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-15">정리</h3>
<p>지금까지 여러가지 식별자 할당 전략을 살펴보았다. 지금까지 설명한 내용을 정리해보자.</p>
<ul>
<li><strong>직접 할당</strong>
<ul>
<li><code>em.persist()</code> 를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.</li>
<li>만약 식별자 값이 없으면 예외가 발생한다.</li>
</ul>
</li>
<li><strong>IDENTITY</strong>
<ul>
<li>DB에 엔티티를 저장하고 난 뒤, 식별자 값을 획득하여 엔티티에 바인딩하고, 영속성 컨텍스트에 엔티티를 저장한다.</li>
</ul>
</li>
<li><strong>SEQUENCE</strong>
<ul>
<li>DB 시퀀스에서 식별자 값을 획득한 후, 엔티티에 바인딩하고, 영속성 컨텍스트에 저장한다.</li>
</ul>
</li>
<li><strong>TABLE</strong>
<ul>
<li>DB 키 생성용 테이블에서 식별자 값을 획득한 후, 엔티티에 바인딩하고, 영속성 컨텍스트에 저장한다.</li>
</ul>
</li>
<li><strong>AUTO</strong>
<ul>
<li>알아서 적절한 전략을 선택하게 된다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET