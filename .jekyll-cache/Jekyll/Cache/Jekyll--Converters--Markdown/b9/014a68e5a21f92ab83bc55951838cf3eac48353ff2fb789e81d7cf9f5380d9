I"KL<p><br/><br/></p>
<h1 id="section">연결리스트</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">특징</h3>
<ul>
<li><strong>논리적순서 ≠ 물리적순서</strong></li>
</ul>
<blockquote>
<p>연결리스트에 ‘a, b, c’ 을 저장이 했을 때, 메모리 주소는 ‘0x1, 0x53, 0x31’처럼 비순차적으로 저장된다.</p>
</blockquote>
<h3 id="section-3">장점</h3>
<ul>
<li>연속 메모리 공간 필요 X</li>
<li>삽입, 삭제 용이</li>
<li>크기 제한X</li>
</ul>
<h3 id="section-4">단점</h3>
<ul>
<li>오류 발생 쉬움</li>
<li>구현 어려움</li>
</ul>
<h3 id="section-5">구조</h3>
<ul>
<li>노드 구성요소
<ul>
<li>데이터 필드</li>
<li>링크 필드</li>
</ul>
</li>
<li>헤드 포인터
<ul>
<li>첫 번째 노드의 주소를 저장하는 포인터 변수</li>
<li>헤드포인터 == top</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0_%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%EC%8A%A4%ED%83%9D/Untitled_47.png" alt="연결리스트 구조" /></p>
<p><br/><br/><br/></p>
<h2 id="section-6">연결리스트로 구현한 스택</h2>
<h3 id="section-7">구성요소</h3>
<p><img src="/assets/img/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0_%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%EC%8A%A4%ED%83%9D/Untitled_48.png" alt="연결리스트 구성요소" /></p>
<h3 id="section-8">노드 구조</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Element</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 데이터 타입 정의</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LinkedNode</span> <span class="p">{</span>
	<span class="n">Element</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//저장할 데이터</span>
	<span class="k">struct</span> <span class="n">LinkedNode</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span> <span class="c1">//다음 노드의 주소값</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//최상단 노드의 주소값</span>
</code></pre></div></div>
<br>
<blockquote>
<p><code>typedef</code> 로 선언한 구조체의 정확한 이름으로 자체 참조 구조체 만들어야함</p>
</blockquote>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">AA</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">a</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span> <span class="c1">// ⇒ 불가</span>
<span class="p">}</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div>
<p><br><br></p>
<h3 id="section-9">공백상태</h3>
<ul>
<li>헤드 포인터 top이 NULL값을 갖는 경우</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">top</span><span class="o">==</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="section-10">포화상태</h3>
<ul>
<li>계속해서 추가할 수 있기 때문에 의미없다.</li>
</ul>
<br>
<h3 id="section-11">스택 초기화</h3>
<p><code>top == NULL</code></p>
<br>
<h3 id="push-">push 연산</h3>
<ol>
<li>‘삽입할 노드의 링크 필드’가 후행노드를 가리키도록 함</li>
<li>‘헤더 포인터 top’이 ‘삽입할 노드’를 가리키도록 함</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">Element</span> <span class="n">inputData</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//추가할 노드 생성</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">inputNodeAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>

	<span class="c1">//추가할 데이터를 새 노드의 data에 저장</span>
	<span class="n">inputNodeAddr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">inputData</span><span class="p">;</span>

	<span class="c1">//기존에 top이 가르키던 노드의 주소값을 새 노드의 link에 저장</span>
	<span class="n">inputNodeAddr</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>

	<span class="c1">//top이 가르키는 주소값을 새 노드의 주소값으로 변경</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">inputNodeAddr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>
<p>가장 먼저, 추가할 데이터를 가지는 노드 객체를 생성해야함 (동적 할당으로)</p>
</li>
<li>
<p>가장 마지막에 있는 노드의 link는 NULL값을 갖는다.</p>
</li>
</ul>
<br>
<h3 id="pop-">pop 연산</h3>
<ol>
<li>공백검사</li>
<li>‘새로운 포인터 변수’가 ‘삭제할 노드’를 가르킴 (top의 값 가져옴)
be) return할 노드 기억</li>
<li>‘헤더 포인터 top’이 ‘삭제할 노드가 가르키는 노드’를 가리키도록 함</li>
<li>‘기억해둔 노드’의 data를 저장</li>
<li>‘기억해둔 노드’를 메모리에서 해제</li>
<li>‘기억해둔 data’를 반환</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Element</span> <span class="nf">pop</span><span class="p">(</span><span class="n">Element</span> <span class="n">inputData</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//return할 노드의 주소값을 담을 포인터변수</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">returnNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="c1">//반환할 데이터</span>
	<span class="n">Element</span> <span class="n">returnData</span>

	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"스택 공백 에러"</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//기존에 top이 가르키던 노드 주소값 저장</span>
	<span class="n">returnNode</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>

	<span class="c1">//top이 가르킬 '다음 노드'의 주소값</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">returnNode</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="c1">//return 노드의 data 저장</span>
	<span class="n">Element</span> <span class="n">returnData</span> <span class="o">=</span> <span class="n">returnNode</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="c1">//삭제할 노드를 메모리에서 해제</span>
	<span class="n">free</span><span class="p">(</span><span class="n">returnNode</span><span class="p">);</span>

	<span class="c1">//pop한 노드의 데이터 반환</span>
	<span class="k">return</span> <span class="n">returnData</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="peek-">peek 연산</h3>
<ol>
<li>공백상태 검사</li>
<li>top이 가르키는 노드의 data멤버 반환</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Element</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//공백검사</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="err">'공백오류'</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="destroystack-">destroy_stack 연산</h3>
<ul>
<li>스택 사용이 끝났다면, 스택을 메모리에서 해제해야함</li>
</ul>
<ol>
<li>공백상태가 아닐 때까지 pop 반복</li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">destroy_stack</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">is_empty</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="size-">size 연산</h3>
<ul>
<li>모든 노드들을 따라가면서 연결된 횟수 검사</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="c1">//마지막 노드의 link값이 NULL이므로, NULL까지 찾는다.</span>
	<span class="k">for</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">top</span><span class="p">;</span> <span class="n">node</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br>
<h3 id="section-12">종합예시</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">Element</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LinkedNode</span> <span class="p">{</span>
	<span class="n">Element</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">LinkedNode</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init_stack</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">top</span><span class="o">==</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">Element</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">Element</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"스택공백에러"</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">node</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	
	<span class="n">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Element</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">is_empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">"공백 스택 에러"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">top</span><span class="p">;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroy_stack</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">init_stack</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pop</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pop</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pop</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pop</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pop</span><span class="p">());</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"size=%d"</span><span class="p">,</span> <span class="n">size</span><span class="p">());</span>
	
	<span class="n">destroy_stack</span><span class="p">();</span>
	
<span class="p">}</span>
</code></pre></div></div>
:ET