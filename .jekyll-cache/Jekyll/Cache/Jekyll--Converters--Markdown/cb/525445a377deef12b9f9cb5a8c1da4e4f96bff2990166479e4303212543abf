I"I<p><br/><br/></p>
<h1 id="section">트리</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">트리란?</h3>
<ul>
<li>계층적인 구조를 나타내는 자료구조</li>
<li>부모-자식 관계의 노드들로 이루어짐</li>
</ul>
<br/>
<h3 id="section-3">용어 총정리</h3>
<ul>
<li>
<p><strong>노드</strong></p>
<ul>
<li>트리의 구성요소</li>
</ul>
</li>
<li>
<p><strong>루트</strong></p>
<ul>
<li>부모가 없는 노드</li>
</ul>
</li>
<li>
<p><strong>서브 트리</strong></p>
<ul>
<li>
<p>하나의 노드와 자손들로 이루어짐</p>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_24.png" alt="트리구조" /></p>
</li>
</ul>
</li>
<li>
<p><strong>단말 노드</strong></p>
<ul>
<li>자식이 없는 노드</li>
</ul>
</li>
<li>
<p><strong>비단말 노드</strong></p>
<ul>
<li>자식을 가지는 노드</li>
</ul>
</li>
<li>
<p><strong>간선, 엣지</strong></p>
<ul>
<li>연결선</li>
</ul>
</li>
<li>
<p><strong>자식</strong></p>
<ul>
<li>직계 자손</li>
</ul>
</li>
<li>
<p><strong>부모</strong></p>
<ul>
<li>직계 조상</li>
</ul>
</li>
<li>
<p><strong>형제</strong></p>
<ul>
<li>같은 부모를 갖는 노드 관계</li>
</ul>
</li>
<li>
<p><strong>조상</strong></p>
</li>
<li>
<p><strong>자손</strong></p>
</li>
<li>
<p><strong>차수</strong></p>
<ul>
<li>어떤 노드의 자식 노드의 수</li>
</ul>
</li>
<li>
<p><strong>트리의 차수</strong></p>
<ul>
<li>트리가 가지고 있는 노드의 차수 중 가장 큰 값</li>
</ul>
</li>
<li>
<p><strong>레벨</strong></p>
<ul>
<li>트리의 각 층의 번호</li>
<li>루트노드는 레벨1이다.</li>
</ul>
</li>
<li>
<p><strong>높이</strong></p>
<ul>
<li>트리의 최대 레벨
<img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_25.png" alt="트리높이" /></li>
</ul>
</li>
<li>
<p><strong>포레스트</strong></p>
<ul>
<li>여러 개의 트리의 집합</li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-4">일반 트리 표현</h2>
<h3 id="section-5">배열활용</h3>
<ul>
<li>
<p>노드 구조를 이용</p>
</li>
<li>
<p>데이터 필드와 링크 필드 존재</p>
</li>
<li>
<p>링크 필드: 배열형태</p>
<blockquote>
<p>배열로 구현된 링크필드:<br />
각 요소가 해당 노드의 자식을 각각 의미함
(링크필드의 길이 == 노드의 차수)</p>
</blockquote>
<blockquote>
<p>노드마다 배열의 길이가 달라짐 (자식의 개수가 다르므로)</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_26.png" alt="배열 트리" /></p>
<br/>
<h3 id="section-6">연결 리스트 활용</h3>
<ul>
<li>노드 구조를 이용</li>
<li>데이터 필드</li>
<li>링크 필드 1: 연결 리스트 형태, 현 노드의 첫 번째 자식노드</li>
<li>링크 필드 2: 연결 리스트 형태, 현 노드의 오른쪽 형제노드</li>
</ul>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_27.png" alt="연결리스트 트리" /></p>
<blockquote>
<p><em>하지만 너무 복잡하다.</em></p>
</blockquote>
<p><br/><br/></p>
<h2 id="section-7">이진 트리</h2>
<h3 id="section-8">이진 트리란?</h3>
<ul>
<li>모든 노드가 최대 두 개의 서브트리를 가지고 있는 것</li>
<li>모든 노드의 차수가 2이하</li>
<li>자식들간(서브 트리)의 순서가 존재 (왼쪽, 오른쪽)</li>
</ul>
<br/>
<h3 id="section-9">이진 트리 성질</h3>
<ul>
<li>
<p>노드의 개수가 $n$개일때,<br />
간선의 개수는 $n-1$개이다.</p>
</li>
<li>
<p>$h$: 높이 일 때,<br />
최소 $h$개~최대 $2^h-1$개의 노드를 가짐</p>
<ul>
<li>
<p>노드개수가 최소인 경우
<img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_28.png" alt="이진트리 성질1" /></p>
</li>
<li>
<p>노드개수가 최대인 경우
<img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_29.png" alt="이진트리 성질2" /></p>
</li>
</ul>
</li>
<li>
<p>n: 노드개수 일 때,<br />
<em>$ceiling(log_2(n+1))$이상 $n$이하의 높이</em>를 가짐</p>
</li>
</ul>
<br/>
<h3 id="section-10">이진트리 분류</h3>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_30.png" alt="이진트리 분류1" /></p>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_31.png" alt="이진트리 분류2" /></p>
<p><br/><br/></p>
<h2 id="section-11">포화 이진 트리</h2>
<h3 id="section-12">포화 이진 트리란?</h3>
<ul>
<li>트리의 각 레벨에 노드가 꽉 차있는 이진 트리</li>
</ul>
<h3 id="section-13">특징</h3>
<ul>
<li>높이가 k이고 노드 개수가 n일 때,
$n = 2^k-1$</li>
</ul>
<h3 id="section-14">노드 번호</h3>
<ul>
<li>레벨 단위로 왼쪽에서 오른쪽으로 순서대로 번호를 붙임</li>
<li>번호는 항상 일정하다 (루트노드의 오른쪽 자식노드의 번호 == 항상 3)</li>
</ul>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_32.png" alt="노드 번호" /></p>
<p><br/><br/></p>
<h2 id="section-15">완전 이진 트리</h2>
<h3 id="section-16">완전 이진 트리란?</h3>
<ul>
<li>높이가 h일 때,
레벨1 ~ 레벨(h-1) 까지는 노드가 모두 채워짐</li>
<li>마지막 레벨 h에서는 노드가 순서대로 채워짐
(중간에 빈 곳이 있으면 안됨)</li>
</ul>
<br/>
<h3 id="section-17">노드 번호</h3>
<ul>
<li>포화 이진트리와 동일</li>
</ul>
<h3 id="section-18">예시</h3>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_33.png" alt="완전이진트리 예시" /></p>
<p><br/><br/></p>
<h2 id="section-19">이진 트리의 추상 자료형</h2>
<h3 id="section-20">데이터 (전체 이진트리의 데이터)</h3>
<ul>
<li>노드의 집합
<ul>
<li>공집합</li>
<li>루트 노드</li>
<li>왼쪽 서브 트리</li>
<li>오른쪽 서브 트리</li>
</ul>
<blockquote>
<p>(모든 서브 트리는 이진트리이어야 함)</p>
</blockquote>
</li>
</ul>
<h3 id="section-21">연산</h3>
<ul>
<li><strong>init()</strong>
<ul>
<li>이진 트리 초기화</li>
</ul>
</li>
<li><strong>is_empty()</strong>
<ul>
<li>이진 트리가 공백 상태인지 확인</li>
</ul>
</li>
<li><strong>create_tree( e, left, right )</strong>
<ul>
<li>이진 트리 left와 right를 자식노드로,</li>
<li>e를 루트로 하는 이진 트리 생성</li>
</ul>
</li>
<li><strong>get_root()</strong>
<ul>
<li>이진 트리의 루트 노드를 반환</li>
</ul>
</li>
<li><strong>get_count()</strong>
<ul>
<li>이진 트리의 노드의 수를 반환</li>
</ul>
</li>
<li><strong>get_leaf_count()</strong>
<ul>
<li>이진 트리의 단말 노드의 수를 반환</li>
</ul>
</li>
<li><strong>get_height()</strong>
<ul>
<li>이진 트리의 높이 반환</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-22">이진 트리 표현: 배열</h3>
<ul>
<li>
<p>포화 이진 트리 or 완전 이진 트리 or 일반 이진 트리 표현가능</p>
</li>
<li>
<p>표현 예시</p>
<ul>
<li>
<p>전제</p>
<ul>
<li>
<p>완전트리</p>
</li>
<li>
<p>높이에 따라 배열의 길이 결정</p>
</li>
<li>
<p>높이 k: 길이가 $2^k-1$인 배열이 필요</p>
<blockquote>
<p>완전 이진 트리가 최대로 가질 수 있는 노드 수 = 포화 이진 트리의 노드 수</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>표현법</p>
<ul>
<li>각 노드에 번호를 붙여서 그 번호를 배열의 인덱스로 삼아 노드의 데이터를 배열에 저장
<img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_34.png" alt="배열트리 표현법" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>특징
<ul>
<li>어떤 노드의 인덱스를 알면, 그 노드의 부모나 자식 인덱스 계산 가능</li>
</ul>
<blockquote>
<p>be) 노드의 번호 == 배열 인덱스</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>노드 i의 부모 노드 인덱스
<ul>
<li>i가 왼쪽 자식일 때: <strong>i/2</strong></li>
<li>i가 오른쪽 자식일 때: <strong>floor(i/2)</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>노드 i의 왼쪽 자식 노드 인덱스
<ul>
<li>2*i</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>노드 i의 오른쪽 자식 노드 인덱스
<ul>
<li>2*i + 1</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>문제점</p>
<ul>
<li>기억 공간 낭비</li>
<li>배열의 크기에 따라 트리의 높이 제한</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-23">이진 트리 표현: 링크</h3>
<ul>
<li>
<p>부모 노드가 자식 노드를 가리키게 함 (with 포인터)</p>
</li>
<li>
<p>주요 표현법
<img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_35.png" alt="링크트리 표현법1" /></p>
<p><img src="/assets/img/2021-07-14-DATASTRUCTURE_BinaryTree_Begin/Untitled_36.png" alt="링크트리 표현법2" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-24">이진트리 구현 - 링크 이용</h2>
<h3 id="section-25">노드 구조체</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">char</span> <span class="n">TElement</span><span class="p">;</span> <span class="c1">//트리의 노드에 저장할 데이터 타입</span>

<span class="c1">//노드 구조체</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BinTrNode</span> <span class="p">{</span>
	<span class="n">TElement</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//노드에 저장될 데이터</span>
	<span class="k">struct</span> <span class="n">BinTrNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span> <span class="c1">//노드의 왼쪽 자식노드</span>
	<span class="k">struct</span> <span class="n">BinTrNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span> <span class="c1">//노드의 오른쪽 자식노드</span>
<span class="p">}</span> <span class="n">TNode</span><span class="p">;</span>

<span class="n">TNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//루트노드를 가르킬 포인터 변수</span>
</code></pre></div></div>
<br/>
<h3 id="inittree">init_tree()</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">init_tree</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br/>
<h3 id="isemptytree">is_empty_tree()</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_empty_tree</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br/>
<h3 id="getroot">get_root()</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TNode</span><span class="o">*</span> <span class="nf">get_root</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br/>
<h3 id="createtreetelement-value-tnode--left-tnode-right">create_tree(TElement value, TNode * left, TNode* right)</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TNode</span><span class="o">*</span> <span class="nf">create_tree</span><span class="p">(</span><span class="n">TElement</span> <span class="n">value</span><span class="p">,</span> <span class="n">TNode</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">TNode</span><span class="o">*</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">TNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">TNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TNode</span><span class="p">));</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<br/>
<h3 id="section-26">전체 예시</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">char</span> <span class="n">TElement</span><span class="p">;</span> <span class="c1">//트리의 노드에 저장할 데이터 타입</span>

<span class="c1">//노드 구조체</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BinTrNode</span> <span class="p">{</span>
	<span class="n">TElement</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//노드에 저장될 데이터</span>
	<span class="k">struct</span> <span class="n">BinTrNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span> <span class="c1">//노드의 왼쪽 자식노드</span>
	<span class="k">struct</span> <span class="n">BinTrNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span> <span class="c1">//노드의 오른쪽 자식노드</span>
<span class="p">}</span> <span class="n">TNode</span><span class="p">;</span>

<span class="n">TNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//루트노드를 가르킬 포인터 변수</span>

<span class="kt">void</span> <span class="nf">init_tree</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty_tree</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TNode</span><span class="o">*</span> <span class="nf">get_root</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TNode</span><span class="o">*</span> <span class="nf">create_tree</span><span class="p">(</span><span class="n">TElement</span> <span class="n">value</span><span class="p">,</span> <span class="n">TNode</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">TNode</span><span class="o">*</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">TNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">TNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TNode</span><span class="p">));</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">TNode</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="n">init_tree</span><span class="p">();</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'E'</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'B'</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'F'</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'C'</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
:ET