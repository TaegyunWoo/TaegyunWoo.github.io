I"#`<p><br/><br/></p>
<h1 id="section">웹 애플리케이션의 기본 동작</h1>
<h2 id="section-1">웹 애플리케이션의 특징</h2>
<ul>
<li>웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.</li>
</ul>
<p><img src="/assets/img/2021-07-25-SPRING_Singleton/Untitled%2010.png" alt="싱글톤 적용 X" /></p>
<ul>
<li>각 클라이언트와 1대1로 대응되어 총 3개의 객체가 생성된다.
<ul>
<li>각 고객마다 객체를 생성하게 된다면, <strong>메모리 낭비가 발생</strong> 한다.</li>
</ul>
</li>
<li><strong>따라서 해당 객체가 딱 1개만 생성되고, 클라이언트들이 해당 객체를 공유하도록 설계해야한다.</strong>
<ul>
<li>이것을 <strong>싱글톤 패턴</strong> 이라고 한다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-2">싱글톤이 적용되지 않은 컨테이너 테스트코드</h2>
<blockquote>
<p><code>AppConfig</code> , <code>MemberService</code> 관련 내용은 <a href="https://taegyunwoo.github.io/spring/SPRING_OCP_DIP">이전 게시글</a> 참고</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">hello.core.AppConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.member.MemberService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.DisplayName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest</span> <span class="o">{</span>
	
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"스프링 없는 순수한 DI 컨테이너"</span><span class="o">)</span>
	<span class="kt">void</span> <span class="nf">pureContainer</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">AppConfig</span> <span class="n">appConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AppConfig</span><span class="o">();</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService1</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>

		<span class="c1">//2. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService2</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>
		
		<span class="c1">//참조값이 다른 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService1 = "</span> <span class="o">+</span> <span class="n">memberService1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService2 = "</span> <span class="o">+</span> <span class="n">memberService2</span><span class="o">);</span>

		<span class="c1">//memberService1 != memberService2</span>
		<span class="c1">// 서로 다른 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">memberService1</span><span class="o">).</span><span class="na">isNotSameAs</span><span class="o">(</span><span class="n">memberService2</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p><br><br><br></p>
<h1 id="section-3">싱글톤 패턴</h1>
<h2 id="section-4">개요</h2>
<h3 id="section-5">싱글톤 패턴이란?</h3>
<ul>
<li>클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.</li>
</ul>
<br>
<h3 id="section-6">싱글톤 패턴 적용하기</h3>
<ul>
<li>객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.</li>
<li>따라서 생성자를 <code>private</code> 으로 설정하여 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.</li>
</ul>
<p><br><br></p>
<h2 id="section-7">싱글톤이 적용된 컨테이너 테스트코드</h2>
<h3 id="singletonservice-">SingletonService 클래스</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonService</span> <span class="o">{</span>
	
	<span class="c1">//1. static 영역에 객체를 딱 1개만 생성해둔다.</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">SingletonService</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonService</span><span class="o">();</span>
	
	<span class="c1">//2. public으로 열어서 객체 인스터스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">SingletonService</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.</span>
	<span class="kd">private</span> <span class="nf">SingletonService</span><span class="o">()</span> <span class="o">{}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"싱글톤 객체 로직 호출"</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ol>
<li>static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.</li>
<li>이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.</li>
<li>딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 <code>private</code> 으로 막아둔다.</li>
</ol>
<br>
<h3 id="section-8">테스트 코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">hello.core.AppConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.SingletonService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.member.MemberService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.DisplayName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest</span> <span class="o">{</span>
	
	<span class="c1">// 싱글톤이 적용되지 않은 기존의 테스트코드</span>
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"스프링 없는 순수한 DI 컨테이너"</span><span class="o">)</span>
	<span class="kt">void</span> <span class="nf">pureContainer</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">AppConfig</span> <span class="n">appConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AppConfig</span><span class="o">();</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService1</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>

		<span class="c1">//2. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService2</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>
		
		<span class="c1">//참조값이 다른 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService1 = "</span> <span class="o">+</span> <span class="n">memberService1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService2 = "</span> <span class="o">+</span> <span class="n">memberService2</span><span class="o">);</span>

		<span class="c1">//memberService1 != memberService2</span>
		<span class="c1">// 서로 다른 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">memberService1</span><span class="o">).</span><span class="na">isNotSameAs</span><span class="o">(</span><span class="n">memberService2</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">//싱글톤이 적용된 싱글톤패턴 테스트코드</span>
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"싱글톤 패턴을 적용한 객체 사용"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">singletonServiceTest</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//private으로 생성자를 막아두었다. 컴파일 오류가 발생한다.</span>
		<span class="c1">//new SingletonService();</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 같은 객체를 반환</span>
    <span class="nc">SingletonService</span> <span class="n">singletonService1</span> <span class="o">=</span> <span class="nc">SingletonService</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="c1">//2. 조회: 호출할 때 마다 같은 객체를 반환</span>
		<span class="nc">SingletonService</span> <span class="n">singletonService2</span> <span class="o">=</span> <span class="nc">SingletonService</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="c1">//참조값이 같은 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"singletonService1 = "</span> <span class="o">+</span> <span class="n">singletonService1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"singletonService2 = "</span> <span class="o">+</span> <span class="n">singletonService2</span><span class="o">);</span>
		
		<span class="c1">// singletonService1 == singletonService2</span>
		<span class="c1">// 서로 같은 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">singletonService1</span><span class="o">).</span><span class="na">isSameAs</span><span class="o">(</span><span class="n">singletonService2</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br><br></p>
<h2 id="section-9">싱글톤 패턴 문제점</h2>
<ul>
<li>싱글톤 패턴을 구현하는 코드가 많이 들어간다.</li>
<li><strong>의존관계상 클라이언트(</strong> <code>singletonServiceTest</code> 테스트 메서드 <strong>)가 구체 클래스(</strong> <code>SingletonService</code> 클래스 <strong>)에 의존한다.
⇒ DIP를 위반한다.</strong>
<ul>
<li><code>구체클래스.getInstance()</code> 를 사용해야하기 때문이다.</li>
</ul>
</li>
<li>클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.</li>
<li><code>private</code> 생성자로 인해 자식 클래스를 만들기 어렵다.</li>
<li>즉, 결론적으로 <strong>유연성이 떨어진다</strong>.</li>
</ul>
<p><br><br><br></p>
<h1 id="section-10">싱글톤 컨테이너</h1>
<p>스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하고, 객체 인스턴스를 싱글톤으로 관리한다.</p>
<p><br><br></p>
<h2 id="section-11">스프링 컨테이너의 싱글톤 기능</h2>
<ul>
<li>스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
<ul>
<li>싱글톤 객체를 생성하고 관리하는 기능을 <strong>싱글톤 레지스트리</strong>라고 한다.</li>
</ul>
</li>
<li>싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.</li>
<li>DIP, OCP, 테스트, <code>private</code> 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.</li>
</ul>
<p><br><br></p>
<h2 id="section-12">스프링 컨테이너 테스트 코드</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">hello.core.AppConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.SingletonService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">hello.core.member.MemberService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.DisplayName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest</span> <span class="o">{</span>
	
	<span class="c1">// 싱글톤이 적용되지 않은 기존의 테스트코드</span>
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"스프링 없는 순수한 DI 컨테이너"</span><span class="o">)</span>
	<span class="kt">void</span> <span class="nf">pureContainer</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">AppConfig</span> <span class="n">appConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AppConfig</span><span class="o">();</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService1</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>

		<span class="c1">//2. 조회: 호출할 때 마다 객체를 생성</span>
		<span class="nc">MemberService</span> <span class="n">memberService2</span> <span class="o">=</span> <span class="n">appConfig</span><span class="o">.</span><span class="na">memberService</span><span class="o">();</span>
		
		<span class="c1">//참조값이 다른 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService1 = "</span> <span class="o">+</span> <span class="n">memberService1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService2 = "</span> <span class="o">+</span> <span class="n">memberService2</span><span class="o">);</span>

		<span class="c1">//memberService1 != memberService2</span>
		<span class="c1">// 서로 다른 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">memberService1</span><span class="o">).</span><span class="na">isNotSameAs</span><span class="o">(</span><span class="n">memberService2</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">//싱글톤이 적용된 싱글톤패턴 테스트코드</span>
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"싱글톤 패턴을 적용한 객체 사용"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">singletonServiceTest</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//private으로 생성자를 막아두었다. 컴파일 오류가 발생한다.</span>
		<span class="c1">//new SingletonService();</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 같은 객체를 반환</span>
    <span class="nc">SingletonService</span> <span class="n">singletonService1</span> <span class="o">=</span> <span class="nc">SingletonService</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="c1">//2. 조회: 호출할 때 마다 같은 객체를 반환</span>
		<span class="nc">SingletonService</span> <span class="n">singletonService2</span> <span class="o">=</span> <span class="nc">SingletonService</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="c1">//참조값이 같은 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"singletonService1 = "</span> <span class="o">+</span> <span class="n">singletonService1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"singletonService2 = "</span> <span class="o">+</span> <span class="n">singletonService2</span><span class="o">);</span>
		
		<span class="c1">// singletonService1 == singletonService2</span>
		<span class="c1">// 서로 같은 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">singletonService1</span><span class="o">).</span><span class="na">isSameAs</span><span class="o">(</span><span class="n">singletonService2</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">// 스프링 컨테이너를 사용하는 테스트 코드</span>
	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"스프링 컨테이너와 싱글톤"</span><span class="o">)</span>
	<span class="kt">void</span> <span class="nf">springContainer</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">ApplicationContext</span> <span class="n">ac</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		
		<span class="c1">//1. 조회: 호출할 때 마다 같은 객체를 반환</span>
		<span class="nc">MemberService</span> <span class="n">memberService1</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberService"</span><span class="o">,</span> <span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

		<span class="c1">//2. 조회: 호출할 때 마다 같은 객체를 반환</span>
		<span class="nc">MemberService</span> <span class="n">memberService2</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberService"</span><span class="o">,</span> <span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

		<span class="c1">//참조값이 같은 것을 확인</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService1 = "</span> <span class="o">+</span> <span class="n">memberService1</span><span class="o">);</span>     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"memberService2 = "</span> <span class="o">+</span> <span class="n">memberService2</span><span class="o">);</span>

		<span class="c1">//memberService1 == memberService2</span>
		<span class="c1">//서로 같은 객체이다.</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">memberService1</span><span class="o">).</span><span class="na">isSameAs</span><span class="o">(</span><span class="n">memberService2</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p><br><br></p>
<h2 id="section-13">싱글톤 컨테이너 (스프링 컨테이너) 적용 후</h2>
<p><img src="/assets/img/2021-07-25-SPRING_Singleton/Untitled%2011.png" alt="싱글톤 적용 O" /></p>
<ul>
<li>
<p>각 클라이언트들이 하나의 객체를 공유한다.</p>
</li>
<li>
<p>스프링 컨테이너는 바이트코드를 조작하여 싱글톤을 유지할 수 있다.</p>
<blockquote>
<p>자세한 내용은 <a href="https://taegyunwoo.github.io/spring/SPRING_Configuration">다음 게시글</a>에서 다룬다.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>참고로 요청마다 새로운 객체를 생성해서 반환하는 기능 역시 스프링이 지원한다.</p>
</blockquote>
<p><br><br></p>
<h2 id="section-14">싱글톤 방식의 주의점</h2>
<ul>
<li>여러 클라이언트(요청자, 고객)이 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 <strong>무상태(stateless)</strong> 로 설계해야 한다.
<ul>
<li>특정 클라이언트에 의존적인 필드가 있으면 안된다.</li>
<li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.</li>
<li>가급적 읽기만 가능해야 한다.</li>
<li>필드 대신 지역변수, 파라미터 등을 사용해야 한다.
<ul>
<li>필드: 클래스 레벨에서 선언된 변수</li>
<li>지역변수: 메서드 내에서 선언된 변수</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<hr />
<br>
<p><a href="https://inf.run/pcN8"><img src="/assets/img/Inflearn_Spring_SpringCore/Logo.png" width="400px" height="250px"></a></p>
<ul>
<li><em>본 게시글은 김영한님의 강의를 토대로 정리한 글입니다.</em></li>
<li><em>더 자세한 내용을 알고 싶으신 분들이 계신다면, 해당 강의를 수강하시는 것을 추천드립니다.</em></li>
</ul>
:ET