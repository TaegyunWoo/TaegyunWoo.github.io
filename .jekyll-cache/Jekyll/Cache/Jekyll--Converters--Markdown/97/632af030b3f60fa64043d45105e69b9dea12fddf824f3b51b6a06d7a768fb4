I"<p><br/><br/></p>
<ul>
<li>이전 게시글
<ul>
<li><a href="https://taegyunwoo.github.io/jpa/JPA_Mapping_Expert_1">[JPA] 고급매핑 (1)</a></li>
</ul>
</li>
</ul>
<br/>
<h1 id="section">이번 포스팅에서 다룰 내용</h1>
<p><a href="https://taegyunwoo.github.io/jpa/JPA_Mapping_Expert_1">이전 포스팅</a>에서 다룬 고급 매핑 내용은 아래와 같다.</p>
<ul>
<li>상속 관계 매핑</li>
<li><code>@MappedSuperclass</code></li>
</ul>
<p>아래는 이번 포스팅에서 다룰 고급 매핑 내용이다.</p>
<ul>
<li>복합 키와 식별 관계 매핑</li>
</ul>
<p>아래는 다음 포스팅에서 다룰 고급 매핑 내용이다.</p>
<ul>
<li>조인 테이블</li>
<li>엔티티 하나에 여러 테이블 매핑하기</li>
</ul>
<p><br/><br/><br/></p>
<h1 id="section-1">복합 키와 식별 관계 매핑</h1>
<h2 id="section-2">개요</h2>
<ul>
<li>기본 복합 키를 매핑하는 방법</li>
<li>식별 관계, 비식별 관계를 매핑하는 방법</li>
</ul>
<p>위 두가지에 대해 지금부터 설명하겠다.</p>
<p><br/><br/></p>
<h2 id="vs--">식별 관계 vs 비식별 관계</h2>
<p>DB 테이블 사이 관계는 ‘외래키가 기본키에 포함되는지 여부’에 따라 식별 관계와 비식별 관계로 구분한다. 지금부터 각 관계의 특징을 이해해보자.</p>
<br/>
<h3 id="section-3">식별 관계</h3>
<ul>
<li>식별 관계는 <strong>부모 테이블의 기본 키를 내려받아서 ‘자식 테이블의 기본키+외래키’로 사용하는 관계</strong>이다.</li>
</ul>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2027.png" alt="Untitled" /></p>
<ul>
<li>위 그림을 보자. <code>PARENT</code> 테이블의 기본키 <code>PARENT_ID</code> 가 <code>CHILD</code> 테이블의 기본키이자 외래키로 사용되었다.</li>
<li>이것을 식별관계라고 한다.</li>
</ul>
<br/>
<h3 id="section-4">비식별 관계</h3>
<ul>
<li>비식별 관계는 <strong>부모 테이블의 기본키를 받아서 ‘자식 테이블의 외래키’로 사용하는 관계</strong>이다.</li>
<li>비식별 관계에는 두 가지 종류가 있다.
<ul>
<li>필수적 비식별 관계</li>
<li>선택적 비식별 관계</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2028.png" alt="Untitled" /></p>
<ul>
<li>위 그림을 보자. <code>PARENT</code> 테이블의 기본키 <code>PARENT_ID</code> 를 <code>CHILD</code> 테이블의 외래키로만 사용한다.</li>
<li>이것을 비식별 관계라고 한다.</li>
<li>필수적 비식별 관계 vs 선택적 비식별 관계
<ul>
<li><strong>필수적 비식별 관계</strong>
<ul>
<li><code>CHILD</code> 테이블의 <code>PARENT_ID</code> 칼럼이 NOT NULL 제약조건을 갖는다.</li>
<li>연관관계를 필수적으로 맺어야 한다.</li>
</ul>
</li>
<li><strong>선택적 비식별 관계</strong>
<ul>
<li><code>CHILD</code> 테이블의 <code>PARENT_ID</code> 칼럼이 NULL을 허용한다.</li>
<li>연관관계를 맺을지 말지 선택할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>최근에는 비식별 관계를 주로 사용하고, 꼭 필요한 곳에만 식별 관계를 사용하는 추세이다.</strong></p>
</blockquote>
<p><br/><br/></p>
<h2 id="section-5">복합 키: 비식별 관계 매핑</h2>
<h3 id="section-6">복합 키를 매핑하기 위한 기본적인 지식</h3>
<ul>
<li>
<p>JPA에서 식별자를 둘 이상 사용하려면, <strong>별도의 식별자 클래스</strong>를 만들어야 한다.</p>
</li>
<li>
<p>즉 아래 코드는 <strong>불가능한 코드</strong>이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>

	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span> <span class="c1">// 실행 시점에 매핑 예외가 발생한다.</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>JPA는 <strong>영속성 컨텍스트에 엔티티를 보관할 때 ‘엔티티의 식별자’를 키로 사용</strong>한다.</p>
<ul>
<li>
<p>식별자를 구분하기 위해, <code>equals</code> 와 <code>hashCode</code> 메서드를 사용하여 동등성 비교를 한다.</p>
</li>
<li>
<p>엔티티를 저장하는 공간인, (영속성 컨텍스트의) <strong>1차 캐시는 HashMap과 유사한 구조</strong>를 갖는다.</p>
</li>
<li>
<p><strong>따라서 어떤 엔티티를 저장하거나 조회할 때, 키에 해당하는 객체(여기선 식별자 객체)의 <code>equals</code> 와 <code>hashCode</code> 메서드가 필요하다.</strong></p>
<blockquote>
<p><code>equals</code> 와 <code>hashCode</code> 메서드에 대해선, <a href="https://taegyunwoo.github.io/java/Java_EqualsAndHashcode">이전에 다룬 포스팅</a>을 참고하자</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>JPA는 복합 키를 지원하기 위해 아래 방법들을 제공한다.
<ul>
<li><code>@IdClass</code>
<ul>
<li>관계형 DB에 가까운 방법이다.</li>
</ul>
</li>
<li><code>@EmbeddedId</code>
<ul>
<li>객체지향에 가까운 방법이다.</li>
</ul>
</li>
</ul>
</li>
<li>지금부터 위 방법들에 대해 하나씩 알아보자.</li>
</ul>
<br/>
<h3 id="codeidclasscode"><code>@IdClass</code></h3>
<p>예시를 통해 <code>@IdClass</code> 애너테이션을 알아보자.</p>
<ul>
<li>예시
<ul>
<li>
<p>가정: 테이블 상태는 아래 그림과 같다.</p>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2029.png" alt="Untitled" /></p>
</li>
<li>
<p>이때, <code>PARENT</code> 테이블은 기본 복합키를 사용한다. (기본키 칼럼이 2개이다.)</p>
</li>
<li>
<p>따라서 기본 복합키를 매핑하기 위해, 식별자 클래스를 별도로 만들어야 한다.</p>
</li>
<li>
<p><strong>부모 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">ParentId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// 사용할 식별자 클래스 지정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span> <span class="c1">//ParentId.id1과 연결된다.</span>

	<span class="nd">@Id</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span> <span class="c1">//ParentId.id2과 연결된다.</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p><strong>부모 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//식별자 클래스는 Serializable 인터페이스를 implements 해야한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span> <span class="c1">//Parent.id1 매핑</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span> <span class="c1">//Parent.id2 매핑</span>

	<span class="kd">public</span> <span class="nf">ParentId</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 기본 생성자</span>

	<span class="kd">public</span> <span class="nf">ParentId</span><span class="o">(</span><span class="nc">String</span> <span class="n">id1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id1</span> <span class="o">=</span> <span class="n">id1</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id2</span> <span class="o">=</span> <span class="n">id2</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//영속성 컨텍스트의 1차 캐시에서 key로 사용되기 위해 위해 필요한 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><code>@IdClass(A.class)</code> 애너테이션의 의미
<ul>
<li><strong>‘해당 애너테이션이 붙은 엔티티 클래스’의 각 속성(필드) 중, <code>@Id</code> 가 붙은 속성(필드)를 <code>A 식별자 클래스</code>의 속성(필드)와 매핑시키겠다는 의미이다.</strong></li>
<li>이때, 각 속성의 이름을 비교하여 매핑시킨다.</li>
<li>즉, 아래처럼 매핑된다.
<ul>
<li><strong>테이블의 기본키 칼럼 ↔ 식별자 클래스의 속성 ↔ 엔티티 클래스의 속성</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>식별자 클래스의 조건
<ul>
<li><strong>‘식별자 클래스의 속성명’과 ‘엔티티에서 사용하는 식별자의 속성명’이 같아야 한다.</strong>
<ul>
<li><code>Parent.id1</code> 과 <code>ParentId.id1</code> 끼리 매핑된다.</li>
<li><code>Parent.id2</code> 와 <code>ParentId.id2</code> 끼리 매핑된다.</li>
</ul>
</li>
<li><strong><code>Serializable</code> 인터페이스를 구현해야 한다.</strong></li>
<li><strong><code>equals</code> , <code>hashCode</code> 를 구현해야 한다.</strong></li>
<li><strong>기본 생성자가 있어야 한다.</strong></li>
<li><strong>식별자 클래스는 <code>public</code> 클래스이어야 한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>식별자 클래스의 필드
<ul>
<li><strong>식별자 클래스의 각 필드는 ‘복합키를 갖는 엔티티의 각 기본키 필드와 매핑’된다.</strong></li>
<li>복합키를 갖는 엔티티의 종류
<ul>
<li>엔티티의 기본키 필드가 객체형인 경우
<ul>
<li>해당 엔티티가 다른 엔티티와 연관관계를 맺는다는 뜻이다.</li>
<li><strong>따라서, 식별자 클래스의 필드는 ‘다른 엔티티의 기본키’를 담아야 한다.</strong></li>
<li>왜냐하면, 다른 엔티티를 구분해야 하기 때문이다.</li>
</ul>
</li>
<li>엔티티의 기본키 필드가 기본형인 경우
<ul>
<li><strong>식별자 클래스의 필드는 그대로 ‘해당 엔티티의 필드값’을 담는다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>복합 키를 사용하는 엔티티 저장하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId1</span><span class="o">(</span><span class="s">"myId1"</span><span class="o">);</span> <span class="c1">//식별자 설정</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId2</span><span class="o">(</span><span class="s">"myId2"</span><span class="o">);</span> <span class="c1">//식별자 설정</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"parentName"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<ul>
<li>위 코드는 parent 엔티티를 저장하는 코드이다. 여기서 이상한 점을 눈치챘는가?</li>
<li><strong>식별자 클래스인 <code>ParentId</code> 와 관련된 코드가 존재하지 않는다!</strong>
<ul>
<li><code>em.persist()</code> 를 호출시 영속성 컨텍스트에 엔티티를 등록하기 직전에, <strong>내부에서 <code>Parent.id1</code> , <code>Parent.id2</code> 값을 사용하여 식별자 클래스 <code>ParentId</code> 를 생성하고 영속성 컨텍스트의 키로 사용</strong>한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>복합 키를 사용하는 엔티티 조회하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"myId1"</span><span class="o">,</span> <span class="s">"myId2"</span><span class="o">);</span> <span class="c1">//복합키 생성</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">parentId</span><span class="o">);</span> <span class="c1">// 식별자 인스턴스로 조회하기</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p>복합키를 가진 부모 엔티티와 ‘선택적 비식별 연관관계’를 갖는 자식 클래스 추가</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">childId</span><span class="o">;</span>

	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumns</span><span class="o">({</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">,</span> <span class="n">referencedColumnName</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">),</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">,</span> <span class="n">referencedColumnName</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span>
	<span class="o">})</span>
	<span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li><code>@JoinColumns</code> 애너테이션
<ul>
<li>외래키 매핑시, 여러 칼럼을 매핑해야 할 때 <code>@JoinColumns</code> 를 사용한다.
<ul>
<li>위 경우 <strong>부모 테이블이 기본 복합키를 사용</strong>하므로, <strong>자식 테이블의 외래키도 ‘기본 복합키로 사용된 여러 칼럼’을 외래키</strong>로 사용해야 한다.</li>
</ul>
</li>
<li><code>name</code> 속성
<ul>
<li><code>CHILD</code> 테이블의 FK 칼럼명</li>
</ul>
</li>
<li><code>referencedColumnName</code> 속성
<ul>
<li><code>CHILD</code> 테이블의 FK 칼럼과 매핑될 ‘<code>PARENT</code> 테이블’의 칼럼명</li>
<li><code>name</code> 값과 <code>referencedColumnName</code> 값이 같다면, <code>referencedColumnName</code> 은 생략할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="codeembeddedidcode"><code>@EmbeddedId</code></h3>
<p><code>@EmbeddedId</code> 는 좀 더 객체지향적인 방법이다. 이것 역시, 예시를 통해 알아보자.</p>
<br/>
<ul>
<li>예시
<ul>
<li>
<p>가정: 테이블 상태는 위(<code>@IdClass</code> 설명 부분)와 같다.</p>
</li>
<li>
<p><strong>부모 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

	<span class="nd">@EmbeddedId</span>
	<span class="kd">private</span> <span class="nc">ParentId</span> <span class="n">parentId</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p><strong>부모 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">)</span> <span class="c1">// PARENT 테이블의 PARENT_ID1 칼럼과 매핑된다.</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span> <span class="c1">// PARENT 테이블의 PARENT_ID2 칼럼과 매핑된다.</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">ParentId</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 기본 생성자</span>

	<span class="kd">public</span> <span class="nf">ParentId</span><span class="o">(</span><span class="nc">String</span> <span class="n">id1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id1</span> <span class="o">=</span> <span class="n">id1</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id2</span> <span class="o">=</span> <span class="n">id2</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//영속성 컨텍스트의 1차 캐시에서 key로 사용되기 위해 위해 필요한 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><code>@Column</code>
<ul>
<li><code>@IdClass</code> 와는 다르게, 식별자 클래스의 필드에 <code>@Column</code> 을 붙여줘야 한다.</li>
<li>왜냐하면 ‘복합키를 쓰는 엔티티’에서 <code>@Column</code> 을 사용하지 않아, 각 필드를 어떤 칼럼과 매핑해야하는지 모르기 때문이다.</li>
<li><strong>즉 <code>@IdClass</code> 와는 다르게, <code>@Embeddable</code> 를 적용한 식별자 클래스는 식별자 클래스에 기본키를 직접 매핑한다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>식별자 클래스의 조건
<ul>
<li><code>@Embeddable</code> 애너테이션을 붙여야 한다.</li>
<li><code>Serializable</code> 인터페이스를 구현해야 한다.</li>
<li><code>equals</code> , <code>hashCode</code> 메서드를 오버라이딩해야 한다.</li>
<li>기본 생성자가 있어야 한다.</li>
<li>식별자 클래스는 <code>public</code> 클래스이어야 한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>복합키를 사용하는 엔티티 저장하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"myId1"</span><span class="o">,</span> <span class="s">"myId2"</span><span class="o">);</span> <span class="c1">// 키 생성</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span> <span class="c1">//식별자 설정</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"parentName"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<ul>
<li><code>@IdClass</code> 와는 다르게, <code>ParentId</code> 를 직접 생성해서 사용한다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>복합키를 사용하는 엔티티 조회하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"myId1"</span><span class="o">,</span> <span class="s">"myId2"</span><span class="o">);</span> <span class="c1">// 키 생성</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">parentId</span><span class="o">);</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="codeequalscode--codehashcodecode">복합 키와 <code>equals()</code> , <code>hashCode()</code></h3>
<ul>
<li>
<p>JPA는 <strong>영속성 컨텍스트에 엔티티를 보관할 때 ‘엔티티의 식별자’를 키로 사용</strong>한다.</p>
</li>
<li>
<p>식별자를 구분하기 위해, <code>equals</code> 와 <code>hashCode</code> 메서드를 사용하여 동등성 비교를 한다.</p>
</li>
<li>
<p>엔티티를 저장하는 공간인, (영속성 컨텍스트의) <strong>1차 캐시는 HashMap과 유사한 구조</strong>를 갖는다.</p>
</li>
<li>
<p><strong>따라서 어떤 엔티티를 저장하거나 조회할 때, 키에 해당하는 객체(여기선 식별자 객체)의 <code>equals</code> 와 <code>hashCode</code> 메서드가 필요하다.</strong></p>
<blockquote>
<p><code>equals</code> 와 <code>hashCode</code> 메서드에 대해선, <a href="https://taegyunwoo.github.io/java/Java_EqualsAndHashcode">이전에 다룬 포스팅</a>을 참고하자.</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="codeidclasscode-vs-codeembeddedidcode"><code>@IdClass</code> vs <code>@EmbeddedId</code></h3>
<ul>
<li><code>@EmbeddedId</code> 가 대체로 좋아보이지만, 반드시 그렇지는 않다.</li>
<li><code>@EmbeddedId</code> 는 특정 상황에서 JPQL이 좀더 길어질 수 있다.</li>
</ul>
<br/>
<h3 id="section-7">참고사항</h3>
<ul>
<li>복합키에는 <code>@GenerateValue</code> 를 사용할 수 없다.</li>
<li>복합 키를 구성하는 여러 칼럼 중 하나에도 사용할 수 없다!</li>
</ul>
<p><br/><br/></p>
<h2 id="section-8">복합 키: 식별 관계 매핑</h2>
<ul>
<li>위에서 비식별 관계를 매핑하는 방법에 대해 다뤘다.</li>
<li>이제 식별 관계를 매핑하는 방법을 알아보자.</li>
</ul>
<br/>
<h3 id="section-9">설명을 위한 기본 가정</h3>
<ul>
<li>테이블 상태는 아래 그림과 같다고 가정한 뒤, 설명을 계속하도록 하겠다.</li>
</ul>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2030.png" alt="Untitled" /></p>
<ul>
<li>위 그림은 부모, 자식, 손자까지 계속 기본키를 전달하는 식별관계이다.</li>
<li>식별 관계에서 자식·손자 테이블은 부모 테이블의 기본키를 포함해서 복합키를 구성한다.
<ul>
<li>따라서, <code>@IdClass</code> 나 <code>@EmbeddedId</code> 를 사용해서 식별자를 매핑해야 한다.</li>
</ul>
</li>
<li>이제 본격적으로 식별관계 매핑에 대해 알아보자.</li>
</ul>
<br/>
<h3 id="codeidclasscode---"><code>@IdClass</code> 와 식별 관계</h3>
<p>바로 예시 코드를 통해 알아보자.</p>
<ul>
<li>
<p><strong>부모 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">ChildId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// 식별자 클래스 설정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span> <span class="c1">// CHILD 테이블의 PARENT_ID와 매핑</span>
	<span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>

	<span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">childId</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="c1">//Child.parent와 매핑된다</span>
	<span class="c1">//**Parent 엔티티의 기본키 값을 담는다**</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">parent</span><span class="o">;</span> <span class="c1">//필드명이 같아야 한다.</span>

	<span class="c1">//Child.childId와 매핑된다</span>
	<span class="c1">//**Child 엔티티의 기본키 childId 값을 담는다**</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">childId</span><span class="o">;</span> <span class="c1">//필드명이 같아야 한다.</span>
	
	<span class="kd">public</span> <span class="nf">ChildId</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 기본 생성자</span>

	<span class="kd">public</span> <span class="nf">ChildId</span><span class="o">(</span><span class="nc">String</span> <span class="n">id1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id1</span> <span class="o">=</span> <span class="n">id1</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id2</span> <span class="o">=</span> <span class="n">id2</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//영속성 컨텍스트의 1차 캐시에서 key로 사용되기 위해 위해 필요한 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>손자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">GrandChildId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// 식별자 클래스 설정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumns</span><span class="o">({</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="o">})</span> <span class="c1">// 여러 칼럼으로 구성된 PK를 가져와, FK로 사용하므로 @JoinColumns 를 사용한다.</span>
	<span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>

	<span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>손자 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="c1">// GrandChild.child 와 매핑된다</span>
	<span class="c1">// **Child 엔티티의 기본키 값이 담긴다**</span>
	<span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">child</span><span class="o">;</span> <span class="c1">//기본 복합키이므로, 식별자 클래스 객체를 담는다</span>

	<span class="c1">// GrandChild.id 와 매핑된다</span>
	<span class="c1">// **GrandChild 엔티티의 기본키 id 값이 담긴다**</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>상세 설명
<ul>
<li>식별 관계는 기본키와 외래키를 같이 매핑해야 한다.</li>
<li>따라서, <code>@Id</code> 와 <code>@ManyToOne</code> 을 같이 사용한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="codeembeddedidcode---"><code>@EmbeddedId</code> 와 식별 관계</h3>
<p><code>@EmbeddedId</code> 로 식별 관계를 구성할 땐, <code>@MapsId</code> 를 사용해야 한다. 바로 예시를 통해 알아보자.</p>
<br/>
<ul>
<li>
<p><strong>부모 클래스</strong></p>
<blockquote>
<p>부모 클래스는 변경사항이 없다.</p>
</blockquote>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

	<span class="nd">@EmbeddedId</span>
	<span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">id</span><span class="o">;</span>

	<span class="nd">@MapsId</span><span class="o">(</span><span class="s">"parentId"</span><span class="o">)</span> <span class="c1">//ChildId.parentId 와 매핑 (연관관계 정보 전달)</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span> <span class="c1">// CHILD 테이블의 PARENT_ID와 매핑</span>
	<span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><strong>만약 자식 테이블의 칼럼 <code>PARENT_ID</code>가 단순히 PK 칼럼이라면, <code>parent</code> 필드를 <code>Child</code> 엔티티 클래스에서 선언할 필요가 없다. (물론 이런 경우에는 <code>parent</code> 필드가 기본 타입이다.)</strong>
<ul>
<li>왜냐하면 식별자 클래스를 통해, 매핑 설정을 할 수 있기 때문이다.</li>
</ul>
</li>
<li><strong>하지만 식별 관계인 경우(자식 테이블의 칼럼 <code>PARENT_ID</code>가 PK·FK 칼럼인 경우), <code>parent</code> 필드를 <code>Child</code> 엔티티 클래스에서 선언해야 한다.</strong>
<ul>
<li>왜냐하면 <strong>식별자 클래스에서 ‘pk 매핑 설정과 함께 연관관계를 설정’할수는 없기 때문에,</strong> <code>Child</code> 클래스에서 연관관계를 설정해야하기 때문이다.</li>
</ul>
</li>
<li><code>@MapsId(&quot;parentId&quot;)</code>
<ul>
<li>식별자 클래스의 <code>parentId</code> 필드에 아래 연관관계를 적용하겠다는 의미와 같다.
<ul>
<li><code>@ManyToOne</code> , <code>@JoinColumn</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>@EmbeddedId</code> 사용 시, 기본키·외래키 설정 위치</p>
<table>
<thead>
<tr>
<th>매핑 설정</th>
<th>설정 위치</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK 설정</td>
<td>식별자 클래스에서 설정한다.</td>
</tr>
<tr>
<td>FK 설정</td>
<td>먼저 엔티티 클래스에서 설정한다. <br/> 그 후, 식별자 클래스에게도 연관관계 정보를 전달한다.</td>
</tr>
</tbody>
</table>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="c1">// @MapsId가 전달해준 연관관계 매핑</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">parentId</span><span class="o">;</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">ChildId</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 기본 생성자</span>

	<span class="kd">public</span> <span class="nf">ChildId</span><span class="o">(</span><span class="nc">String</span> <span class="n">parentId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">parentId</span> <span class="o">=</span> <span class="n">parentId</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//영속성 컨텍스트의 1차 캐시에서 key로 사용되기 위해 위해 필요한 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>손자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

	<span class="nd">@EmbeddedId</span>
	<span class="kd">private</span> <span class="nc">GrandChildId</span> <span class="n">id</span><span class="o">;</span>

	<span class="nd">@MapsId</span><span class="o">(</span><span class="s">"childId"</span><span class="o">)</span> <span class="c1">// GrandChildId.childId 와 매핑 (연관관계 정보 전달)</span>
	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumns</span><span class="o">({</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
		<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="o">})</span>
	<span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>손자 식별자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

	<span class="c1">// @MapsId가 전달해준 연관관계 매핑</span>
	<span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">childId</span><span class="o">;</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">GrandChildId</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 기본 생성자</span>

	<span class="kd">public</span> <span class="nf">GrandChildId</span><span class="o">(</span><span class="nc">ChildId</span> <span class="n">childId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">childId</span> <span class="o">=</span> <span class="n">childId</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//영속성 컨텍스트의 1차 캐시에서 key로 사용되기 위해 위해 필요한 메서드</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>상세 설명
<ul>
<li>’식별 관계로 사용할 연관관계의 속성(필드)’에 <code>@MapsId</code> 를 적용하면 된다.</li>
<li><code>@IdClass</code> 와의 차이점
<ul>
<li><code>@IdClass</code> 는 엔티티의 연관관계 속성(필드)에 <code>@Id</code> 를 사용한다.</li>
<li><code>@EmbeddedId</code> 는 엔티티의 연관관계 속성(필드)에 <code>@MapsId</code> 를 사용한다.</li>
</ul>
</li>
<li><code>@MapsId</code> 의 의미
<ul>
<li><strong>‘외래키와 매핑한 연관관계’를 기본키에도 매핑하겠다는 뜻이다.</strong></li>
<li><strong>즉, 연관관계 정보를 식별자 클래스에게도 넘겨 매핑하겠다는 뜻이다.</strong></li>
<li><strong>따라서 속성 값으로 ‘식별자 클래스의 기본키 필드’를 지정하면 된다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">비식별 관계로 구현</h3>
<p>위에서 설명한 식별 관계를 비식별 관계로 변경하고, 이에 따라 코드가 어떻게 변화하는지 보자.</p>
<ul>
<li>
<p>테이블 상태</p>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2031.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>부모 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span> <span class="c1">// CHILD 테이블의 PARENT_ID와 매핑</span>
	<span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>손자 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

	<span class="nd">@ManyToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="c1">// getter, setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
<li>
<p>기본 복합키를 사용하지 않으니, 상당히 단순해졌다.</p>
<ul>
<li>식별자 클래스를 만들 필요가 없다.</li>
</ul>
</li>
<li>
<p>매핑도 매우 간단하다.</p>
</li>
</ul>
<br/>
<h3 id="section-11">일대일 식별관계</h3>
<p>일대일 식별 관계는 약간 특별하다. 바로 예제를 통해 알아보자.</p>
<br/>
<ul>
<li>
<p>테이블 상태</p>
<p><img src="/assets/img/2021-11-07-JPA_Mapping_Expert_2/Untitled%2032.png" alt="Untitled" /></p>
<ul>
<li><strong>일대일 식별관계는 ‘자식 테이블의 기본키 값으로 부모 테이블의 기본키 값만 사용’한다.</strong></li>
<li>그래서 <strong>부모 테이블의 기본키가 복합키가 아니면</strong>, <strong>자식 테이블의 기본 키는 복합 키로 구성하지 않아</strong>도 된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>부모 클래스 (<code>BOARD</code>)</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

	<span class="c1">//양방향</span>
	<span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"board"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">BoardDetail</span> <span class="n">boardDetail</span><span class="o">;</span>

	<span class="c1">// getter, setter, 편의메서드 생략</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>자식 클래스 (<code>BOARDDETAIL</code>)</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoardDetail</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">boardId</span><span class="o">;</span>

	<span class="nd">@MapsId</span> <span class="c1">// BoardDetail.boardId 와 매핑 (연관관계 정보 전달)</span>
	<span class="nd">@OneToOne</span>
	<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Board</span> <span class="n">board</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">content</span><span class="o">;</span>

	<span class="c1">// getter, setter, 편의메서드 생략</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
<li><strong><code>@MapsId</code> 를 통해, 자신의 PK 필드에 연관관계를 전달한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>상세 설명
<ul>
<li><strong><code>BoardDetail</code> 처럼 식별자가 단순히 칼럼 하나인 경우, <code>@MapsId</code> 를 사용하고, 속성값은 비워두면 된다.</strong></li>
<li>이때 <code>@MapsId</code> 는 <code>@Id</code> 를 사용해서 식별자로 지정한 <code>BoardDetail.boardId</code> 와 매핑된다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>일대일 식별관계를 사용하는 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
	<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">;</span>
	<span class="n">board</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="s">"제목"</span><span class="o">);</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>

	<span class="nc">BoardDetail</span> <span class="n">boardDetail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoardDetail</span><span class="o">();</span>
	<span class="n">boardDetail</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"내용"</span><span class="o">);</span>
	<span class="n">boardDetail</span><span class="o">.</span><span class="na">setBoard</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">boardDetail</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="section-12">식별, 비식별 관계의 장단점</h3>
<ul>
<li>식별 관계의 단점
<ul>
<li>부모 테이블의 키본키를 자식 테이블로 전파하면서, 자식 테이블의 기본키 칼럼이 점점 늘어난다.
<ul>
<li>결국 조인할 때, SQL이 복잡해지고 기본키 인덱스가 불필요하게 커질 수 있다.</li>
</ul>
</li>
<li>2개 이상의 칼럼을 합해서 복합 기본키를 만들어야 하는 경우가 많다.</li>
<li>비즈니스 의미가 있는 자연키 칼럼을 조합하여 기본키로 사용하는 경우가 많다.
<ul>
<li>식별 관계의 자연키 칼럼들이 자식에 손자까지 전파되면 변경하기 힘들다.</li>
<li>비즈니스 요구사항은 언제가는 바뀐다.</li>
<li>반면에, 비식별 관계에서는 주로 대리키를 기본키로 사용한다.</li>
</ul>
</li>
<li>부모 테이블의 기본키를 자식 테이블의 기본키로 사용하므로, 비식별 관계보다 테이블 구조가 유연하지 못하다.</li>
<li>일대일 관계를 제외한 식별 관계는 2개 이상의 칼럼을 묶은 복합 기본키를 사용한다.
<ul>
<li>따라서, 칼럼이 하나인 기본키를 매핑하는 것보다 많은 노력이 필요하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>식별 관계의 장점
<ul>
<li>기본 키 인덱스를 활용하기 좋다.</li>
<li>상위 테이블들의 기본키 칼럼을 자식 및 손자 테이블들이 가지고 있으므로, 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>정리
<ul>
<li>
<p><strong>웬만하면 비식별 관계를 사용하자.</strong></p>
</li>
<li>
<p><strong>그리고 기본키로 Long 타입의 대리키를 사용하자.</strong></p>
<ul>
<li>비즈니스가 변경되어도 유연하게 대처할 수 있다.</li>
<li><code>@GeneratedValue</code> 를 통해, 간편하게 대리키를 생성할 수 있다.</li>
<li>식별자 칼럼이 하나여서 쉽게 매핑할 수 있다.</li>
</ul>
</li>
<li>
<p><strong>‘선택적 비식별 관계’보단 ‘필수적 비식별 관계’를 사용하자.</strong></p>
<ul>
<li>선택적 비식별 관계는 NULL을 허용하므로, 조인할 때 <strong>외부조인</strong>을 사용해야 한다.</li>
<li>필수적 비식별 관계는 NULL을 허용하지 않으므로, 조인할 때 <strong>내부조인만</strong>을 사용할 수 있다.</li>
</ul>
<blockquote>
<p>외부조인: 연관되지 않은 것까지 포함하여 출력<br />
내부조인: 연관되지 않은 것은 제외하고 출력</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘</li>
  </ul>
  본 게시글은 위 교재를 기반으로 정리한 글입니다.
</div>
:ET