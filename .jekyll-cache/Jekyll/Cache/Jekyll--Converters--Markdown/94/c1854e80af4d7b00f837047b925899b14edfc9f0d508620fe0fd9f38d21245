I"^<p><br/><br/></p>
<h1 id="section">데드락</h1>
<h2 id="section-1">개요</h2>
<h3 id="section-2">데드락이란?</h3>
<ul>
<li>데드락이란, 둘 이상의 프로세스가 각각 다른 프로세스가 점유한 자원을 요구하면서, 모두 작업 수행을 할 수 없이 대기 상태로 놓이는 상태를 말한다.</li>
<li>데드락 == 교착상태</li>
</ul>
<br/>
<h3 id="section-3">데드락 예시</h3>
<ol>
<li>시스템은 2개의 Resource를 보유하고 있다.</li>
<li>프로세스 P1과 P2는 각각 한 개의 Resource를 점유한 상태이다.</li>
<li>각각의 프로세스가 데이터 처리를 위해, 또 다른 Resource를 요구하게 된다.</li>
<li>프로세스 P1과 P2는 교착상태에 빠지게 된다.</li>
</ol>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2071.png" alt="Untitled" /></p>
<br/>
<h3 id="section-4">시스템 모델</h3>
<ul>
<li>
<p>시스템은 유한한 수의 자원들로 구성된다.</p>
<ul>
<li>자원 종류: CPU cycles, memory space, I/O devices</li>
</ul>
</li>
<li>
<p>각 자원 타입(<img src="https://latex.codecogs.com/svg.image?R_i" alt="math" />)은 <img src="https://latex.codecogs.com/svg.image?W_i" alt="math" /> 개의 인스턴스를 갖는다.</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2072.png" alt="Untitled" /></p>
</li>
<li>
<p>프로세스는 아래와 같은 순서로만 자원을 사용할 수 있다.</p>
<ol>
<li><strong>Request (요청)</strong></li>
<li><strong>Use (사용)</strong></li>
<li><strong>Release (방출)</strong></li>
</ol>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-5">데드락 특징</h2>
<h3 id="section-6">데드락 발생 조건</h3>
<p>아래의 4가지 조건들이 <strong>동시</strong>에 일어나면 데드락(교착상태)이 발생한다.</p>
<ul>
<li>
<p><strong>Mutual exclusion (상호배제)</strong></p>
<ul>
<li>오직 한개의 프로세스가 자원을 점유할 수 있다.</li>
<li>다른 프로세스가 그 자원을 사용하려 할 경우, 그 프로세스는 자원의 사용이 끝날 때까지 지연되어야 한다.</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2073.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>Hold and wait (점유대기)</strong></p>
<ul>
<li>프로세스가 자원을 최소 한 개 점유하고, 다른 프로세스가 점유한 다른 자원을 얻기 위해서 기다린다.</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2074.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>No preemption (비선점)</strong></p>
<ul>
<li>자원을 선점할 수 없다. (아직 사용 중인 자원을 뺏기지 않는다.)</li>
<li>즉, 프로세스가 작업 종료 후에 자발적으로 자원을 방출한다.</li>
</ul>
</li>
<li>
<p><strong>Circular wait (순환 대기)</strong></p>
<ul>
<li>대기하고 있는 프로세스 집합 {<img src="https://latex.codecogs.com/svg.image?P_0,P_1,...,P_n" alt="math" />} 이 있다고 할 때</li>
<li><img src="https://latex.codecogs.com/svg.image?P_0" alt="math" /> 는 <img src="https://latex.codecogs.com/svg.image?P_1" alt="math" />이 점유하고 있는 자원을 기다린다.</li>
<li><img src="https://latex.codecogs.com/svg.image?P_1" alt="math" /> 는 <img src="https://latex.codecogs.com/svg.image?P_2" alt="math" />이 점유하고 있는 자원을 기다린다.</li>
<li><img src="https://latex.codecogs.com/svg.image?P_%7Bn-1%7D" alt="math" /> 는 <img src="https://latex.codecogs.com/svg.image?P_n" alt="math" />이 점유하고 있는 자원을 기다린다.</li>
<li><img src="https://latex.codecogs.com/svg.image?P_n" alt="math" /> 는 <img src="https://latex.codecogs.com/svg.image?P_0" alt="math" />이 점유하고 있는 자원을 기다린다.</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2075.png" alt="Untitled" /></p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="resource-allocation-graph-rag">자원 할당 그래프 (Resource-Allocation Graph: RAG)</h2>
<h3 id="rag">RAG란?</h3>
<ul>
<li>교착 상태를 정확하게 기술하는 그래프</li>
</ul>
<br/>
<h3 id="rag-">RAG 구성요소</h3>
<ul>
<li><strong>Vertex (정점, E)</strong>
<ul>
<li>프로세스</li>
<li>자원</li>
</ul>
</li>
<li><strong>Edge (간선, E)</strong>
<ul>
<li>
<p><strong>요청 간선</strong> : <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" />  → <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /></p>
</li>
<li>
<p><strong>할당 간선</strong> : <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> → <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /></p>
</li>
<li>
<p><strong>예약 간선</strong></p>
<blockquote>
<p>예약 간선은 포스팅 후반에 다룬다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="rag--">RAG 요소 표현</h3>
<ul>
<li>
<p><strong>프로세스</strong></p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2076.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>자원 타입 (4개 인스턴스를 갖음)</strong></p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2077.png" alt="Untitled" /></p>
</li>
<li>
<p><strong><img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> 의 인스턴스 요청</strong></p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2078.png" alt="Untitled" /></p>
</li>
<li>
<p><strong><img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> 의 인스턴스가 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 에 할당</strong></p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2079.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="rag--1">RAG 예시</h3>
<ul>
<li>P = {<img src="https://latex.codecogs.com/svg.image?P_1,P_2,P_3" alt="math" />}</li>
<li>R = {<img src="https://latex.codecogs.com/svg.image?R_1,R_2,R_3,R_4" alt="math" />}</li>
<li>E = {<img src="https://latex.codecogs.com/svg.image?P_1-%3ER_1,P_2-%3ER_3,R_1-%3EP_2,R_2-%3EP_2,R_2-%3EP_1,R_3-%3EP3" alt="math" />}</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2080.png" alt="Untitled" /></p>
<br/>
<h3 id="rag----">데드락과 RAG 예시 : 데드락 발생</h3>
<ul>
<li>데드락 찾기
<ul>
<li>자원의 인스턴스가 하나밖에 없는 경우
<ul>
<li>사이클 형성 시, 무조건 데드락이 발생한다.</li>
</ul>
</li>
<li>자원의 인스턴스가 여러개 있는 경우
<ul>
<li>사이클 형성 시, 데드락 발생 가능성이 있다.</li>
</ul>
</li>
<li>즉 인스턴스 여유없이, 사이클 형성시 데드락이 발생한다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2081.png" alt="Untitled" /></p>
<br/>
<h3 id="rag-----x">데드락과 RAG 예시 : 데드락 발생 X</h3>
<ul>
<li><strong>사이클이 존재한다고 반드시 교착상태가 발생한다는 것은 아니다.</strong></li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2082.png" alt="Untitled" /></p>
<br/>
<h3 id="section-7">정리</h3>
<ul>
<li>자원 할당 그래프에서 사이클이 없다면, 시스템은 교착 상태가 아니다.</li>
<li>만약 사이클이 있는 경우
<ul>
<li>자원 유형 당 하나의 인스턴스만 있다면 교착상태이다.</li>
<li>자원 유형 당 여러 개의 인스턴스가 있다면 교착 상태의 가능성이 있다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-8">데드락을 관리하는 여러 방법들</h3>
<ul>
<li>
<p>시스템이 결코 교착상태가 되지 않도록 보장하기 위해, 교착상태를 예방하거나 회피하는 프로토콜을 사용하는 방법</p>
</li>
<li>
<p>시스템이 교착상태가 되도록 허용한다음, 회복시키는 방법</p>
</li>
<li>
<p>문제를 무시하고 교착상태가 시스템에서 결코 발생하지 않는 척 하는 방법</p>
<blockquote>
<p>UNIX를 포함한 대부분의 OS에서 사용하는 방법이다.</p>
</blockquote>
</li>
</ul>
<p><br/><br/></p>
<h2 id="deadlock-prevention">데드락 핸들링: 데드락 예방 방법 (Deadlock Prevention)</h2>
<h3 id="section-9">데드락 예방이란?</h3>
<ul>
<li>자원 요청 방법을 제한하는 방식을 말한다.</li>
<li>데드락 발생 조건을 피하여 데드락을 예방하고자 한다.</li>
</ul>
<br/>
<h3 id="section-10">데드락 예방을 위한 조건</h3>
<ul>
<li><strong>Mutual Exclusion (상호배제)을 부정하기</strong>
<ul>
<li>애초에 자원에 대해 동시 접근하는 것이 불가능하기 때문에, 상호배제를 부정하는 것은 불가능하다.</li>
</ul>
</li>
<li><strong>Hold and Wait (점유 대기)를 부정하기</strong>
<ul>
<li>점유 대기를 부정하기 위해선, 프로세스가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.</li>
<li>또는 자원을 전혀 소유하지 않은 프로세스만 자원을 요청하게 해야한다.</li>
</ul>
</li>
<li><strong>No Preemption (비선점)을 부정하기</strong>
<ul>
<li>‘어떤 자원을 보유하고 있는 프로세스’가 ‘즉시 할당할 수 없는 다른 자원’을 요청하면, ’ 그 프로세스가 현재 보유하고 있는 모든 자원’을 방출하도록 한다.</li>
<li>프로세스는 ‘자신이 요청하고 있는 새로운 자원’과 ‘이전에 점유했던 옛 자원’을 다시 획득할 수 있을 때만 다시 시작된다.</li>
<li>예시
<ul>
<li>‘프로세스 A가 요청한 자원’을 프로세스 A가 오래 사용해야한다면, <strong>‘프로세스 A가 가지고 있던 자원’을 다른 프로세스가 사용할 수 있도록 모든 자원을 방출한 후</strong>, 요청자원을 할당한다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Circular Wait (순환 대기)를 부정하기</strong>
<ul>
<li>모든 자원 타입에 전체 순서를 부여하고, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="mutex--deadlock-">Mutex 와 Deadlock 예시</h3>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2083.png" alt="Untitled" /></p>
<ul>
<li>교착 상태가 발생한다.</li>
</ul>
<p><br/><br/></p>
<h2 id="deadlock-avoidance">데드락 핸들링: 데드락 회피 방법 (Deadlock Avoidance)</h2>
<h3 id="section-11">데드락 회피란?</h3>
<ul>
<li>시스템이 추가적인 사전 정보를 가용하도록(미리 알 수 있도록) 하여 데드락을 피하는 것을 말한다.</li>
</ul>
<br/>
<h3 id="section-12">데드락 회피를 위한 조건</h3>
<ul>
<li>각 프로세스가 필요한 각 자원의 최대 인스턴스를 선언한다.</li>
<li>교착상태회피 알고리즘은 자원할당 상태를 검사하여 순환대기 상태가 없도록 한다.</li>
<li>자원 할당 상태는 <strong>‘사용가능한 자원 수’</strong> 와 <strong>‘할당된 자원 수’</strong> 와 <strong>‘프로세스의 최대 요구 자원 수’</strong> 에 의해 정의된다.</li>
</ul>
<br/>
<h3 id="safe-state--">Safe State (안전 상태)</h3>
<ul>
<li>
<p>안전 상태란?</p>
<ul>
<li>‘&lt;<img src="https://latex.codecogs.com/svg.image?P_1,P_2,...,P_n" alt="math" />&gt;’ 가 시스템에 모든 프로세스로 구성되었다고 가정하자.</li>
<li><strong>이때, <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 요청하는 모든 자원이 ‘현재 사용 가능한 자원’과 ‘모든 프로세스가 소유한 자원’으로 충족되는 상태를 말한다.</strong></li>
<li>예시
<ul>
<li>전체 자원: 10</li>
<li>사용 중인 자원: 5</li>
<li>이때 각 프로세스가 요청할 수 있는 자원 수는 5를 넘을 수 없다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>데드락을 회피하기 위해선, 프로세스가 자원을 요청했을 때 시스템이 그 자원을 할당한 후에도 시스템을 <strong>안전 상태(safe state)</strong> 로 만드는지 확인해야 한다.</p>
</li>
<li>
<p>정리</p>
<ul>
<li>시스템이 안전 상태인 경우 ⇒ 교착 상태가 발생하지 않는다.</li>
<li>시스템이 안전하지 않은 상태일 경우 ⇒ 교착 상태가 발생할 가능성이 존재한다.</li>
<li>회피란 ⇒ 시스템이 안전하지 않은 상태로 들어가지 않도록 하는 것이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">회피 알고리즘</h3>
<ul>
<li>단일 인스턴스 자원일 때
<ul>
<li><strong>RAG 사용</strong> 하여 데드락 회피</li>
</ul>
</li>
<li>다중 인스턴스 자원일 때
<ul>
<li><strong>은행원 알고리즘을 사용</strong> 하여 데드락 회피</li>
</ul>
</li>
</ul>
<br/>
<h3 id="rag--2">회피 알고리즘: RAG 알고리즘</h3>
<ul>
<li>
<p>RAG의 간선 종류</p>
<ul>
<li>요청 간선</li>
<li>할당 간선</li>
<li>예약 간선</li>
</ul>
</li>
<li>
<p><strong>예약 간선</strong></p>
<ul>
<li>예약 간선은 프로세스 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 미래에 자원 <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" />를 요청하는 의미를 갖는다.</li>
<li>예약 간선은 점선으로 표시한다.</li>
</ul>
</li>
<li>
<p><strong>프로세스가 자원을 요청할 때, 예약 간선이 요청 간선으로 변환된다.</strong></p>
</li>
<li>
<p><strong>자원이 프로세스에 할당되면, 요청 간선이 할당 간선으로 변환된다.</strong></p>
</li>
<li>
<p><strong>자원이 프로세스에 의해 방출되면, 할당 간선은 예약 간선으로 재전환된다.</strong></p>
<ul>
<li>시스템에서 자원은 반드시 미리 예약되어야 한다.</li>
</ul>
</li>
<li>
<p>RAG 예시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2084.png" alt="Untitled" /></p>
</li>
<li>
<p>안전하지 않은 상태에서의 RAG 예시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2085.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>RAG 알고리즘</strong></p>
<ul>
<li>프로세스 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 자원 <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" />를 요청한다고 가정하자.</li>
<li><strong>이때 요청 간선 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> → <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> 를 할당 간선 <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> → <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 로 변환해도, 자원 할당 그래프에 사이클을 형성하지 않을 경우에만 자원 요청을 허용한다.</strong>
<ul>
<li>이것이 RAG 알고리즘이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-14">회피 알고리즘: 은행원 알고리즘</h3>
<ul>
<li>
<p>은행원 알고리즘이란?</p>
<ul>
<li>
<p>자원의 다중 인스턴스가 있을 경우에 사용한다.</p>
</li>
<li>
<p><strong>각 프로세스는 사용하는 모든 자원의 최대 사용할 개수를 미리 선언해야 한다.</strong></p>
<ul>
<li>예시</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2086.png" alt="Untitled" /></p>
</li>
<li>
<p><strong>프로세스가 자원을 요청할 때는 대기해야 할 수도 있다.</strong></p>
</li>
<li>
<p><strong>프로세스가 필요한 모든 리소스를 얻으면, 프로세스는 제한된 시간 내에 자원을 모두 반환해야 한다.</strong></p>
</li>
</ul>
</li>
<li>
<p>관련 데이터</p>
<ul>
<li><strong>n</strong>
<ul>
<li>프로세스의 수</li>
</ul>
</li>
<li><strong>m</strong>
<ul>
<li>자원의 종류 수</li>
</ul>
</li>
<li><strong>Available</strong>
<ul>
<li>각 종류별로 가용한 자원의 개수를 나타내는 벡터 (m 크기)</li>
<li>Available[j] = k 일 때, 현재 자원j를 k개 사용할 수 있다.</li>
</ul>
</li>
<li><strong>Max</strong>
<ul>
<li>각 프로세스가 최대로 필요로 하는 자원의 개수를 나타내는 행렬 (n*m 크기)</li>
<li>Max[i,j] = k 일 때, 프로세스i가 자원j를 최대 k개까지 요청할 수 있다.</li>
</ul>
</li>
<li><strong>Allocation</strong>
<ul>
<li>각 프로세스에게 현재 할당된 자원의 개수를 나타내는 행렬 (n*m 크기)</li>
<li>Allocation[i,j] = k 일 때, 프로세스i가 자원j를 최대 k개 사용 중이라는 것이다.</li>
</ul>
</li>
<li><strong>Need</strong>
<ul>
<li>각 프로세스가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬 (n*m 크기)</li>
<li>Need[i,j] = k 일 때, 프로세스i가 자원j를 k개 더 요청한다는 것이다.</li>
</ul>
</li>
<li>참고
<ul>
<li><strong>Need[i,j] = Max[i,j] - Allocation[i,j]</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>안전 상태 확인 알고리즘</strong>
<ul>
<li>안전 상태를 확인하는 알고리즘에 대해 먼저 알아보자.</li>
</ul>
<ol>
<li>
<p>Work와 Finish는 크기가 m과 n인 vector이다.</p>
<ul>
<li><code>Work = Available //초기화</code></li>
<li><code>for (i=0,1,...,n-1) { Finish[i] = false } //초기화</code></li>
</ul>
</li>
<li>
<p>아래 두 조건을 만족하는 i 값을 찾는다.</p>
<ul>
<li><code>Finish[i] == false</code>
<ul>
<li>프로세스i (<img src="https://latex.codecogs.com/svg.image?P_i" alt="math" />)가 끝나지 않은 상태를 의미한다.</li>
</ul>
</li>
<li><code>Need_(i) &lt;= Work</code>
<ul>
<li>프로세스i가 필요로 하는 자원이 가용 자원보다 작거나 같다는 의미이다.</li>
</ul>
</li>
</ul>
<p>위 조건에 맞는 i 값을 찾을 수 없다면 step 4로 이동한다.</p>
</li>
<li>
<p>아래처럼 설정한다.</p>
<ul>
<li><code>Finish[i] = true</code>
<ul>
<li>프로세스i를 끝날 수 있는 상태로 변경한다.</li>
</ul>
</li>
<li><code>Work = Work + Allocation_(i)</code>
<ul>
<li>프로세스i에 할당된 자원을 가용한 자원으로 만든다.</li>
</ul>
</li>
</ul>
<p>그리고 다시 step 2로 간다.</p>
</li>
<li>
<p>모든 i 값에 대해 <code>Finish[i] == true</code> 이면, 이 시스템은 안전 상태에 있다.</p>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li><strong>은행원 알고리즘</strong>
<ul>
<li>전제
<ul>
<li><code>Request_(i)</code> 는 프로세스 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" />의 요청 벡터이다.</li>
<li><code>Request_(i) = k</code> 라면, 프로세스 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 자원 <img src="https://latex.codecogs.com/svg.image?R_j" alt="math" /> 를 k개까지 요청한다는 것이다.</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>만일 <code>Request_(i) &lt;= Need_(j)</code> 라면, step 2로 이동한다.<br />
그렇지 않다면, 프로세스의 최대 요청 개수보다 더 많이 요청을 했으므로 에러로 처리한다.</p>
</li>
<li>
<p>만일 <code>Request_(i) &lt;= Available</code> 이라면 step 3으로 이동한다.<br />
그렇지 않다면, 요청에 대한 자원이 가용하지 않으므로 프로세스i는 대기해야 한다.</p>
</li>
<li>
<p>상태를 아래와 같이 바꿈으로써 자원을 프로세스i에게 할당해보려고 시도한다.</p>
<ul>
<li><code>Available = Available - Request_(i);</code></li>
<li><code>Allocation_(i) = Allocation_(i) + Request_(i);</code></li>
<li><code>Need_(i) = Need_(i) - Request_(i);</code></li>
</ul>
<p>위 3가지 항목들이 안전 상태인지 판단하는 기준이 된다.</p>
</li>
<li>
<p>안전하다면, 자원을 프로세스i에게 할당한다.<br />
안전하지 않다면, 자원할당은 원상태로 복귀하고 프로세스i는 요청이 만족될때까지 대기한다.</p>
</li>
</ol>
<ul>
<li>
<p>알고리즘 워크플로우</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2087.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-15">은행원 알고리즘 예시</h3>
<ul>
<li>
<p>전제</p>
<ul>
<li>프로세스
<ul>
<li>P0 ~ P4까지 총 5개의 프로세스</li>
</ul>
</li>
<li>자원
<ul>
<li>총 3 종류의 자원 (A, B, C)</li>
<li>A=10개_인스턴스</li>
<li>B=5개_인스턴스</li>
<li>C=7개_인스턴스</li>
</ul>
</li>
</ul>
</li>
<li>
<p>초기 상황</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2088.png" alt="Untitled" /></p>
<ul>
<li>
<p>Allocation 구하기</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2089.png" alt="Untitled" /></p>
</li>
<li>
<p>Need 구하기</p>
<ul>
<li>Need = Max - Allocation 이므로 아래가 성립한다.</li>
</ul>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2090.png" alt="Untitled" /></p>
</li>
</ul>
</li>
<li>
<p><strong>위 초기상태에서 &lt;P1, P3, P4, P2, P0&gt; 순서로 실행 시, 안전 상태가 될 수 있다.</strong></p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2091.png" alt="Untitled" /></p>
<ul>
<li>
<p>증명</p>
<ol>
<li>
<p>P1 실행 시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2092.png" alt="Untitled" /></p>
</li>
<li>
<p>P3 실행 시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2093.png" alt="Untitled" /></p>
</li>
<li>
<p>P4 실행 시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2094.png" alt="Untitled" /></p>
</li>
<li>
<p>P2 실행 시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2095.png" alt="Untitled" /></p>
</li>
<li>
<p>P0 실행 시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2096.png" alt="Untitled" /></p>
</li>
</ol>
<ul>
<li><strong>결론: 모든 프로세스가 Available 범위내에서 실행되었으므로 시스템은 처음부터 끝까지 안전 상태이다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><strong>&lt;P1, P3, P4, P2, P0&gt; 순서 이외로, &lt;P1,P3,P4,P0,P2&gt; 순서로 실행해도 시스템은 계속 안전 상태이다.</strong></p>
<blockquote>
<p>이것은 스스로 해보자.</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li><strong>Available 범위 내에서 프로세스를 실행할 수 있다고, 무조건 안전 상태인 것은 아니다.</strong>
<ul>
<li>
<p>P0 에게 미리 자원을 (0, 2, 0)으로 할당시켜줄수 있을까?</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2097.png" alt="Untitled" /></p>
<ul>
<li>P0에게 (0, 2, 0)을 할당한다면 위와 같이 될 것이다.</li>
<li>표면상, Available이 (2, 3, 0)인 상태에서 (0, 2, 0)를 사용하는 것은 문제가 되지 않는 것 같다.</li>
<li><strong>(0, 2, 0)를 할당하고 난 뒤, Available 값이 (2, 1, 0)으로 변화한다. 이 Available 값으로 실행을 할 수 있는 프로세스가 존재하지 않는다.</strong></li>
<li><strong>따라서 (0, 2, 0)를 요청하는 것이 Available 범위를 벗어나지 않는다고 해도, 들어줄 수 없다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="deadlock-detection">데드락 핸들링: 데드락 감지 방법 (Deadlock Detection)</h2>
<h3 id="section-16">대기 그래프</h3>
<ul>
<li>
<p>대기 그래프란</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2098.png" alt="Untitled" /></p>
</li>
<li>
<p>대기 그래프 예시</p>
<p><img src="/assets/img/2021-12-01-OS_DeadLock/Untitled%2099.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="section-17">데드락 탐지 오버헤드</h3>
<ul>
<li>교착상태가 자주 일어난다면, 데드락 탐지 알고리즘도 자주 돌려야 한다.
<ul>
<li><strong>이때 오버헤드가 커진다.</strong></li>
</ul>
</li>
<li>데드락 탐지 오버헤드 완화 대안
<ul>
<li>한 시간에 한번만 탐지한다.</li>
<li>CPU 이용률이 40%일 때만 탐지한다.</li>
<li>등…</li>
</ul>
</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET