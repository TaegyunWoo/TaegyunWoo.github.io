I"*<p><br/><br/></p>
<h1 id="section">개요</h1>
<h2 id="section-1">클러스터형 시스템</h2>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2019.png" alt="Untitled" /></p>
<ul>
<li>하나의 저장소를 여러 computer가 공유하며 사용한다.</li>
<li>각 computer는 서로 연결되어있다.</li>
</ul>
<p><br/><br/></p>
<h2 id="section-2">운영체제 구조</h2>
<h3 id="section-3">단일 프로그래밍과 다중 프로그래밍</h3>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2020.png" alt="Untitled" /></p>
<ul>
<li>단일 프로그래밍
<ul>
<li>한번에 하나의 프로그램만 사용 가능하다.</li>
</ul>
</li>
<li>다중 프로그래밍
<ul>
<li>한번에 여러 프로그램을 사용할 수 있다.</li>
<li>요즘 OS 방식이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-4">시분할</h3>
<ul>
<li>시분할은 다중 프로그래밍의 논리적 확장이다.</li>
<li>시분할은 사용자가 컴퓨터의 자원을 효율적으로 공유하는 것이다.</li>
<li><strong>CPU가 다수의 작업들을 매우 빈번하게 교대로 실행하여, 사용자들은 자신의 작업을 할 수 있다.</strong></li>
</ul>
<br/>
<h3 id="section-5">다중 프로그래밍 시스템에서의 메모리 배치</h3>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2021.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="section-6">운영체제 동작</h2>
<ul>
<li>현대 운영체제의 구동 방식은 인터럽트 구동 방식이다.</li>
</ul>
<br/>
<h3 id="section-7">인터럽트 종류</h3>
<ul>
<li><strong>하드웨어 생성 인터럽트</strong>
<ul>
<li>인터럽트 벡터를 통해 ISR 주소에 접근하는 등의 인터럽트 동작</li>
</ul>
</li>
<li><strong>소프트웨어 생성 인터럽트</strong>
<ul>
<li>예외 or 트랩에 의해 발생하는 인터럽트</li>
<li>예시
<ul>
<li>
<p>0으로 나누기, 유효하지 않은 메모리 접근</p>
</li>
<li>
<p><strong>운영체제 서비스 요청</strong></p>
<blockquote>
<p><strong>이중 동작 모드에서 자세히 설명한다.</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="dual-mode">이중 동작 모드 (Dual Mode)</h3>
<ul>
<li>
<p>이중 동작 모드를 통해, 운영체제와 다른 시스템 부분들을 보호한다.</p>
</li>
<li>
<p>모드 종류</p>
<ul>
<li><strong>사용자 모드</strong></li>
<li><strong>커널 모드</strong></li>
</ul>
</li>
<li>
<p><strong>하드웨어 모드 비트</strong></p>
<ul>
<li>하드웨어의 하나의 비트를 통해, 모드를 구분한다.</li>
<li>하드웨어 모드 비트를 통해, 시스템이 ‘사용자 코드’ 와 ‘커널 코드’를 실행하는지 구별해준다.</li>
</ul>
</li>
<li>
<p><strong>운영체제 서비스 요청 인터럽트 동작 방식</strong></p>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2022.png" alt="Untitled" /></p>
<blockquote>
<p>위 방식으로 ‘운영체제 서비스 요청’ 인터럽트를 처리한다.</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="section-8">타이머</h3>
<ul>
<li>
<p>타이머는 무한 루프나 자원을 계속 사용하는 프로세스를 방지하기 위해 사용한다.</p>
<ul>
<li>즉, OS에게 자원(CPU 등)을 돌려주지 않는 프로세스를 방지한다.</li>
</ul>
</li>
<li>
<p>타이머는 지정된 시간 후에 인터럽트를 설정한다.</p>
</li>
<li>
<p>타이머 인터럽트 발생시</p>
<ul>
<li><strong>운영체제가 제어한다. (제어권이 다시 OS로 돌아온다.)</strong>
<ul>
<li>운영체제가 자원을 돌려주지 않은 프로세스를 오류로 간주해 프로그램을 중단하거나,</li>
<li>아니면 프로그램에게 더 많은 시간을 할당해준다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-9">프로세스</h2>
<h3 id="section-10">프로세스란?</h3>
<ul>
<li>
<p>실행 중인 프로그램</p>
</li>
<li>
<p>시스템에서 작업의 단위</p>
</li>
<li>
<p>프로그램 vs 프로세스</p>
<ul>
<li>프로그램
<ul>
<li>수동적인 개체이다.</li>
</ul>
</li>
<li>프로세스
<ul>
<li>능동적인 개체이다.</li>
</ul>
</li>
<li><strong>즉 프로그램이 메모리에 올라가면, 그것이 프로세스가 된다.</strong></li>
</ul>
</li>
<li>
<p>프로세스는 업무 수행을 위한 자원이 필요하다.</p>
</li>
<li>
<p>프로세스 종료 후 재사용 가능한 자원은 회수한다.</p>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-11">운영체제의 관리 작업</h2>
<h3 id="section-12">프로세스 관리</h3>
<p>운영체제는 프로세스 관리와 관련된 아래 작업들을 수행한다.</p>
<ul>
<li>사용자(시스템) 프로세스 생성 및 제거</li>
<li>CPU에 프로세스와 쓰레드 스케줄링</li>
<li>프로세스 일시 중지와 재실행</li>
<li>프로세스 동기화를 위한 기법 제공</li>
<li>프로세스 통신을 위한 기법 제공</li>
<li>데드락 처리를 위한 기법 제공
<ul>
<li>데드락: 프로세스끼리 서로 끝나기를 기다리는 (교착)상태</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-13">메모리 관리</h3>
<p>운영체제는 메모리 관리와 관련된 아래 작업들을 수행한다.</p>
<ul>
<li>현재 사용 중인 메모리 부분과 누가 사용 중인지 추적</li>
<li>어떤 프로세스를 메모리에 적재하고 제거할 것인가 결정</li>
<li>필요에 따라 메모리 공간을 할당하고 회수</li>
</ul>
<br/>
<h3 id="section-14">파일 시스템 관리</h3>
<ul>
<li>파일 시스템 관리의 필요성
<ul>
<li>파일은 디렉터리로 분류되지만, 파일이 실제 HDD에 저장될 때 무작위 주소로 저장된다.</li>
<li>따라서, 이것을 시각적으로 정리하여 사용자에게 제공한다.</li>
</ul>
</li>
</ul>
<p>운영체제는 파일 시스템 관리와 관련된 아래 작업들을 수행한다.</p>
<ul>
<li>파일과 디렉터리의 생성 및 제거</li>
<li>파일과 디렉터리를 조작하기 위한 권한 제공</li>
<li>파일을 보조 저장장치로 매핑</li>
<li>안정적인 저장매체에 파일 백업
<ul>
<li>안정적인 저장매체: 비휘발성 저장매체</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-15">대용량 저장장치 관리</h3>
<p>운영체제는 대용량 저장장치 관리와 관련된 아래 작업들을 수행한다.</p>
<ul>
<li>안 쓰는 공간 관리</li>
<li>저장 장소 할당</li>
<li>디스크 스케줄링</li>
</ul>
<br/>
<h3 id="section-16">입출력 시스템 관리</h3>
<ul>
<li>사용자가 하드웨어의 특성을 잘 몰라도 되도록, <strong>사용자로부터 특정 하드웨어 장치의 특성을 숨기는 역할을 운영체제가 수행한다.</strong></li>
</ul>
<p>운영체제는 입출력 관리와 관련된 아래 작업들을 수행한다.</p>
<ul>
<li>버퍼링
<ul>
<li>자료 이동 중에 일시적인 자료 보관하는 것</li>
</ul>
</li>
<li>캐싱
<ul>
<li>성능을 위해 자료의 일부분을 보관하는 것</li>
</ul>
</li>
<li><strong>스풀링</strong>
<ul>
<li>
<p>프린터와 같은 장치에서, 한 작업의 출력이 다른 작업의 출력과 동시에 작업할 수 있도록 하는 것</p>
</li>
<li>
<p>스풀링이 없다면</p>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2023.png" alt="Untitled" /></p>
</li>
<li>
<p>스풀링이 있다면</p>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2024.png" alt="Untitled" /></p>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-17">캐싱</h2>
<h3 id="section-18">캐싱 과정</h3>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2025.png" alt="Untitled" /></p>
<h3 id="section-19">캐시 동기화</h3>
<ul>
<li>다중처리기(멀티-프로세서) 환경에서는 <strong>‘캐시 동기화(업데이트)’</strong> 를 통해 <strong>‘캐시의 일관성’</strong> 을 유지하여 모든 CPU가 자신의 캐시에 최신 값을 가지고 있어야 한다.</li>
<li>캐시의 일관성을 유지하는 것이 <strong>분산환경</strong>에서 더욱 복잡해진다.
<ul>
<li>여러 computer가 자신이 갖는 캐시를 최신 값으로 업데이트해야한다.</li>
<li>이것을 OS가 처리해야한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-20">보호와 보안</h2>
<h3 id="section-21">보호</h3>
<ul>
<li>컴퓨터 시스템이 정의한 <strong>자원</strong>에 대해 프로그램, 프로세스 또는 사용자들의 접근을 제어하는 기법</li>
</ul>
<br/>
<h3 id="section-22">보안</h3>
<ul>
<li>외부 또는 내부의 <strong>공격</strong>을 방어하는 것</li>
</ul>
<p><br/><br/></p>
<h2 id="section-23">커널에서 쓰이는 자료구조</h2>
<h3 id="section-24">커널에서 사용되는 자료구조 종류</h3>
<ul>
<li><strong>Singly Linked List</strong> (단방향 연결리스트)</li>
<li><strong>Doubly Linked List</strong> (양방향 연결리스트)</li>
<li><strong>Circular Linked List</strong> (원형 연결리스트)</li>
<li><strong>Binary Search Tree</strong> (이진 탐색트리)
<ul>
<li>왼쪽 서브트리 ≤ 자신</li>
<li>오른쪽 서브트리 ≥ 자신</li>
</ul>
</li>
<li><strong>HashFunction &amp; HashMap</strong> (해시함수 &amp; 해시맵)</li>
</ul>
<p><br/><br/></p>
<h2 id="p2p-">P2P 컴퓨팅</h2>
<h3 id="p2p--1">P2P 컴퓨팅이란</h3>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2026.png" alt="Untitled" /></p>
<ul>
<li>분산 시스템의 모델 중 하나이다.</li>
<li>P2P는 서버와 클라이언트를 구별하지 않는다.
<ul>
<li>즉, 모든 노드가 피어(동료)로 간주된다.</li>
</ul>
</li>
<li><strong>발견 프로토콜(discovery protocol)</strong>
<ul>
<li>클라이언트 피어는 원하는 서비스를 제공하는 노드를 찾는다.</li>
<li>서버 피어는 서비스 요청에 응답한다.</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="virtualization">가상화 (Virtualization)</h2>
<h3 id="section-25">가상화란</h3>
<ul>
<li>하나의 H/W 위에 <strong>여러 OS를 동시에 독립적으로 구동하는 것</strong>이다.</li>
</ul>
<p><img src="/assets/img/2021-09-14-OS_Summary2/Untitled%2027.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="real-time-embedded-systems">Real-Time Embedded Systems</h2>
<h3 id="real-time-embedded-system-">Real-Time Embedded System 이란</h3>
<ul>
<li>특별한 목적을 가진 시스템이다.</li>
<li><strong>반드시 정해진 제약조건에 맞춰 작동해야한다.</strong></li>
</ul>
<blockquote>
<p>Windows, Mac 등은 범용 시스템이다.</p>
</blockquote>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET