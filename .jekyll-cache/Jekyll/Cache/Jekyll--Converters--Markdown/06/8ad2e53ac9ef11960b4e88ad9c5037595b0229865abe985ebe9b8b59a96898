I",<p><br/><br/></p>
<h1 id="dynamic-programming-----">Dynamic Programming : 모든 쌍 최단 경로</h1>
<h2 id="section">개요</h2>
<h3 id="section-1">모든 쌍 최단 경로 문제란?</h3>
<ul>
<li>각 쌍의 점 사이의 최단 경로를 찾는 문제이다.</li>
<li>Ex) a에서 출발하여 b로 도착했을 때의, (a, b)의 최단경로</li>
<li>Ex) c에서 출발하여 f로 도착했을 때의, (c, f)의 최단경로 등..</li>
</ul>
<br>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2049.png" alt="모든 쌍 최단 경로 문제란?" /></p>
<p><br><br></p>
<h2 id="section-2">문제 해결 방법 - 다익스트라 알고리즘</h2>
<h3 id="section-3">시간복잡도</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%7CV%7C%7CE%7Clog%7CV%7C" alt="|V||E|log|V|" /></li>
</ul>
<br>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2050.png" alt="다익스트라 알고리즘" /></p>
<p><br><br></p>
<h2 id="section-4">문제 해결 방법 - 플로이드 알고리즘</h2>
<h3 id="section-5">시간복잡도</h3>
<ul>
<li>
<p><img src="https://latex.codecogs.com/svg.image?O(n%5E3)" alt="O(n^3)" /></p>
</li>
<li>
<p>다익스트라 시간복잡도 : <img src="https://latex.codecogs.com/svg.image?%7CV%7C%7CE%7Clog%7CV%7C" alt="|V||E|log|V|" /></p>
</li>
<li>
<p>플로이드 시간복잡도 : <img src="https://latex.codecogs.com/svg.image?O(n%5E3)" alt="O(n^3)" /></p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?%7CV%7C%7CE%7Clog%7CV%7C%3EO(n%5E3)" alt="|V||E|log|V|&gt;O(n^3)" /></p>
<ul>
<li>다익스트라 방식이 플로이드 방식보다 시간복잡도가 높으므로 <strong>플로이드 알고리즘을 사용하여 문제를 해결</strong>하는 것이 좋다.</li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-6">부분 문제 구하기</h2>
<h3 id="section-7">부분문제 정의</h3>
<ul>
<li>입력 점 : 1, 2, 3, 4, … , n</li>
</ul>
<br>
<ul>
<li>
<p><img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5Ek" alt="{D_{ij}}^k" /></p>
<ul>
<li>점i에서 점j까지 갈 수 있는 모든 경로 중 가장 짧은 경로의 거리</li>
<li><img src="https://latex.codecogs.com/svg.image?D_%7Bij%7D" alt="D_{ij}" /> : 2차원 배열</li>
<li><strong>i</strong> : 출발점</li>
<li><strong>j</strong> : 도착점</li>
<li><strong>k</strong> : i~j 까지의 최단거리에서 경유 할 수 있는 최대점</li>
<li>k≠0 이더라도 경유하는 점이 없을 수 있다.</li>
</ul>
<br>
<blockquote>
<p>Ex)
<img src="https://latex.codecogs.com/svg.image?(D_%7B16%7D)%5E3" alt="(D_{16})^3" /> 의 의미는
점1에서 출발하여, 점6에 도착하는 모든 경로에서<br />
‘경유를 안하거나’, ‘점1을 경유하거나’, ‘점2를 경유하거나’, ‘점3을 경유할때’<br />
중 가장 짧은 경로의 거리이다.</p>
</blockquote>
</li>
</ul>
<br>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5E0" alt="{D_{ij}}^0" /> 의 의미
<ul>
<li>k=0 : 경유하는 점이 없다.</li>
<li>따라서, 이것은 선분 (i, j)의 기본 가중치(거리)이다.</li>
</ul>
</li>
</ul>
<br>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5E1" alt="{D_{ij}}^1" /> 의 의미
<ul>
<li>
<p>경로1 : 점i와 점j까지 한번에 가는 경로의 거리 = <img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5Ek" alt="{D_{ij}}^k" /></p>
</li>
<li>
<p>경로2 : 점1을 경유하여 점i와 점j까지 가는 경로의 거리 = <img src="https://latex.codecogs.com/svg.image?%7BD_%7Bi1%7D%7D%5E0+%7BD_%7B1j%7D%7D%5E0" alt="{D_{i1}}^0+{D_{1j}}^0" /></p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5E1" alt="{D_{ij}}^1" /> 의미</p>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?min(%7BD_%7Bij%7D%7D%5Ek,&amp;space;%7BD_%7Bi1%7D%7D%5E0+%7BD_%7B1j%7D%7D%5E0)" alt="min({D_{ij}}^k,&amp;space;{D_{i1}}^0+{D_{1j}}^0)" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2051.png" alt="D_{ij}^1의 의미" /></p>
<br>
<blockquote>
<p>즉, <img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5E1" alt="{D_{ij}}^1" /> 은 가장 작은 부분 문제이다.</p>
</blockquote>
<br>
<ul>
<li>조건
<ul>
<li><strong>k≠i</strong> : k는 경유를 할 수도 있는 점을 뜻하므로, “시작점≠경유점”</li>
<li><strong>k≠j</strong> : k는 경유를 할 수도 있는 점을 뜻하므로, “도착점≠경유점”</li>
<li><strong>i≠j</strong> : “시작점≠도착점”</li>
</ul>
</li>
</ul>
<br>
<h3 id="section-8">부분 문제 원리</h3>
<ul>
<li>점의 개수가 3개 인 경우의 해 : (i, j)의 최단 경로
<ul>
<li>
<p>점i에서 점j로 직접가는 경우</p>
</li>
<li>
<p>점1을 경유하여 가는 경우</p>
</li>
<li>
<p>총 2가지의 경우 중, 짧은 것을 선택하면 된다.</p>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2052.png" alt="부분 문제 원리" /></p>
<blockquote>
<p>&lt;상향 방법 (bottom-up)&gt;<br />
점1 로부터 시작하여,
점2, 점3, 점4, … , 점n 까지 모든 점을 경유 가능한 점들로 고려하면서,
모든 쌍의 최단 경로의 거리를 계산한다.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>점의 개수가 4개 인 경우의 해 : (i, j)의 최단 경로
<ul>
<li>
<p>‘점i에서 점j로 직접가는 경우’</p>
</li>
<li>
<p>‘점2을 경유하여 가는 경우’</p>
</li>
<li>
<p>총 2가지의 경우 중, 짧은 것을 선택하면 된다.</p>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2053.png" alt="점의 개수가 4개인 경우의 해" /></p>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>점의 개수가 k개 인 경우의 해 : (i, j)의 최단 경로</p>
<ul>
<li>
<p>‘점i에서 점j로 직접가는 경우’</p>
</li>
<li>
<p>‘점k을 경유하여 가는 경우’</p>
</li>
<li>
<p>총 2가지의 경우 중, 짧은 것을 선택하면 됨</p>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2054.png" alt="점의 개수가 k개인 경우의 해" /></p>
</li>
</ul>
</li>
<li>
<p>정리</p>
<ul>
<li>즉, <img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5Ek=min(%7BD_%7Bij%7D%7D%5E%7Bk-1%7D,&amp;space;(%7BD_%7Bik%7D%7D%5E%7Bk-1%7D+%7BD_%7Bkj%7D%7D%5E%7Bk-1%7D))" alt="{D_{ij}}^k=min({D_{ij}}^{k-1},&amp;space;({D_{ik}}^{k-1}+{D_{kj}}^{k-1}))" /></li>
</ul>
</li>
</ul>
<p><br><br></p>
<h2 id="section-9">알고리즘</h2>
<h3 id="section-10">의사코드</h3>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2055.png" alt="의사코드" /></p>
<br>
<blockquote>
<p>단, 경로를 만드는 것이 불가능한 점간의 거리는 무한대이다.</p>
</blockquote>
<br>
<h3 id="section-11">절차 : 1번 라인</h3>
<ul>
<li>k : 경유할 수도 있는 점들의 개수</li>
<li>k를 점차 늘려간다.
<ul>
<li>왜냐하면 경유할 수 있는 모든 점들에 대해 결과를 구해야하기 때문이다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="section-12">절차 : 2번 라인</h3>
<ul>
<li>i : 시작점</li>
<li>i를 점차 늘려간다.
<ul>
<li>왜냐하면 점들의 가능한 모든 경로를 구해야 하기 때문이다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="section-13">절차 : 3번 라인</h3>
<ul>
<li>j : 도착점</li>
<li>j를 점차 늘려간다.
<ul>
<li>왜냐하면 각 출발점마다 모든 도착점에 대한 경로를 구해야 하기 때문이다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="section-14">절차 : 4번 라인</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?%7BD_%7Bij%7D%7D%5Ek=min(%7BD_%7Bij%7D%7D%5E%7Bk-1%7D,&amp;space;(%7BD_%7Bik%7D%7D%5E%7Bk-1%7D+%7BD_%7Bkj%7D%7D%5E%7Bk-1%7D))" alt="{D_{ij}}^k=min({D_{ij}}^{k-1},&amp;space;({D_{ik}}^{k-1}+{D_{kj}}^{k-1}))" /></li>
<li>위와 같은 부분문제 공식을 적용한다.</li>
</ul>
<br>
<h3 id="section-15">주의사항</h3>
<ul>
<li>
<p>선분들의 <strong>가중치 합이 음수</strong>가 되는 것이 없어야 한다.</p>
</li>
<li>
<p>이것을 <strong>음수 사이클</strong>이라고 한다.</p>
</li>
</ul>
<p><br><br></p>
<h2 id="section-16">수행 예시</h2>
<h3 id="section-17">입력</h3>
<ul>
<li>초기값
<ul>
<li>배열 D에는 각 점들간의 기본가중치 값이 들어있다.</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-07-23-ALGORITHM_DP_AllPairsShortestPaths/Untitled%2056.png" alt="수행 예시 (입력)" /></p>
<br>
<h3 id="k1--">k=1 일 경우</h3>
<ul>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B2%5D%5B3%5D=min(D%5B2%5D%5B3%5D,D%5B2%5D%5B1%5D+D%5B1%5D%5B3%5D)=min(1,%5Cinfty)=1" alt="D[2][3]=min(D[2][3],D[2][1]+D[1][3])=min(1,\infty)=1" /></p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B2%5D%5B4%5D=min(D%5B2%5D%5B4%5D,D%5B2%5D%5B1%5D+D%5B1%5D%5B4%5D)=min(%5Cinfty,%5Cinfty)=%5Cinfty" alt="D[2][4] = min(D[2][4],D[2][1]+D[1][4])=min(∞,∞)=∞" /></p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B2%5D%5B5%5D=min(D%5B2%5D%5B5%5D,D%5B2%5D%5B1%5D+D%5B1%5D%5B5%5D)=min(4,%5Cinfty)=4" alt="D[2][5] = min(D[2][5],D[2][1]+D[1][5])=min(4,∞)=4" /></p>
</li>
<li>
<p>…..</p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B4%5D%5B2%5D=min(D%5B4%5D%5B2%5D,D%5B4%5D%5B1%5D+D%5B1%5D%5B2%5D)=min(%5Cinfty,2)=2" alt="D[4][2] = min(D[4][2],D[4][1]+D[1][2])=min(∞,2)=2" />
이때, 배열이 갱신된다.</p>
<blockquote>
<p>경유하는 경로가 더 짧을 때, 배열의 값이 갱신된다.</p>
</blockquote>
</li>
<li>
<p>…..</p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B5%5D%5B4%5D=min(D%5B5%5D%5B4%5D,D%5B5%5D%5B1%5D+D%5B1%5D%5B4%5D)=min(1,%5Cinfty)=1" alt="D[5][4] = min(D[5][4],D[5][1]+D[1][4])=min(1,∞)=1" /></p>
</li>
</ul>
<blockquote>
<p>&lt; <img src="https://latex.codecogs.com/svg.image?%7BD_%7B12%7D%7D%5E1" alt="{D_{12}}^1" /> 부터 조사하지 않는 이유 &gt;<br />
‘k≠i’, ‘k≠j’, ‘i≠j’ 해당 조건에 위배되기 때문이다.</p>
</blockquote>
<br>
<h3 id="k2--">k=2 일 경우</h3>
<ul>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B1%5D%5B3%5D=min(D%5B1%5D%5B3%5D,D%5B1%5D%5B2%5D+D%5B2%5D%5B3%5D)=min(2,5)=2" alt="D[1][3] = min(D[1][3],D[1][2]+D[2][3])=min(2,5)=2" /></p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B1%5D%5B4%5D=min(D%5B1%5D%5B4%5D,D%5B1%5D%5B2%5D+D%5B2%5D%5B4%5D)=min(5,%5Cinfty)=5" alt="D[1][4] = min(D[1][4],D[1][2]+D[2][4])=min(5,∞)=5" /></p>
</li>
<li>
<p>…..</p>
</li>
<li>
<p><img src="https://latex.codecogs.com/svg.image?D%5B5%5D%5B4%5D=min(D%5B5%5D%5B4%5D,D%5B5%5D%5B2%5D+D%5B2%5D%5B4%5D)=min(1,%5Cinfty)=1" alt="D[5][4] = min(D[5][4],D[5][2]+D[2][4])=min(1,∞)=1" /></p>
</li>
</ul>
<blockquote>
<p>이러한 과정을 k=5일때까지 반복한다.</p>
</blockquote>
<p><br><br></p>
<h2 id="section-18">시간 복잡도</h2>
<h3 id="section-19">시간복잡도</h3>
<ul>
<li><img src="https://latex.codecogs.com/svg.image?O(n%5E3)" alt="O(n^3)" /></li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 임태수 교수님 (2021)</li>
    <li>양성봉, 『알기 쉬운 알고리즘』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET