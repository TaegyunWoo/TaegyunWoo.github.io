I"|<p><br/><br/></p>
<h1 id="section">프로세스 동기화 방법</h1>
<h2 id="section-1">배경</h2>
<h3 id="section-2">개요</h3>
<ul>
<li>프로세스들은 기본적으로 병렬 수행된다.
<ul>
<li>하지만 언제든 인터럽트가 걸릴 수 있다.</li>
</ul>
</li>
<li>병렬수행하다 보면 <strong>공용데이터 값에 불일치 문제</strong>가 발생할 수 있다.
<ul>
<li>따라서 불일치 문제를 해결할 방법들이 필요하다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-3">버퍼 문제</h3>
<ul>
<li>생산자·소비자 문제에서 모든 버퍼를 다 채우면 발생하는 문제가 존재한다.
<ul>
<li>솔루션 1
<ul>
<li>(BufferSize-1)개의 버퍼만을 사용하여 문제를 해결할 수 있다.</li>
<li>자세한 것은 아래 포스팅 글을 참고하자.</li>
<li><a href="https://taegyunwoo.github.io/datastructure/DATASTRUCTURE_Queue#11">[데이터구조] 큐</a>, <a href="https://taegyunwoo.github.io/os/OS_Process2#10">[OS] 프로세스 - 2</a></li>
</ul>
</li>
<li>솔루션 2
<ul>
<li>정수 카운터를 통해서 버퍼가 다 찼는지 살펴보면 문제를 해결할 수 있다.</li>
<li>계속해서 좀 더 자세히 알아보자.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="counter----">버퍼 문제: 정수 카운터(counter)를 통한 버퍼 문제 해결</h2>
<h3 id="section-4">동작 방식</h3>
<ul>
<li>
<p><strong>counter</strong></p>
<ul>
<li>버퍼를 얼마나 사용 중인지 개수를 센다.</li>
</ul>
</li>
<li>
<p>시각화</p>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2063.png" alt="Untitled" /></p>
</li>
<li>
<p>Producer (생산자) 코드</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">//버퍼가 Full 상태일 때</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 아무것도 수행하지 않는다.*/</span>
	<span class="p">}</span>

	<span class="c1">//버퍼에 데이터를 넣을 수 있을 때</span>
	<span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_produced</span><span class="p">;</span>
	<span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
	<span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</li>
<li>
<p>Consumer (소비자) 코드</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">//버퍼가 Empty 상태일 때</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 아무것도 수행하지 않는다.*/</span>
	<span class="p">}</span>

	<span class="c1">//버퍼에서 데이터를 가져올 수 있을 때</span>
	<span class="n">next_consumed</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>
	<span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
	<span class="n">counter</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<h3 id="counter------">Counter로 버퍼 사용시 발생하는 문제: 경쟁 상황</h3>
<ul>
<li><code>counter++</code> 를 기계명령어로 변환시
<ul>
<li><code>register1 = counter</code></li>
<li><code>register1 = register1 + 1</code></li>
<li><code>counter = register1</code></li>
</ul>
</li>
<li><code>counter--</code> 를 기계명령어로 변환시
<ul>
<li><code>register2 = counter</code></li>
<li><code>register2 = register2 - 1</code></li>
<li><code>counter = register2</code></li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><strong>문제 상황: 프로세스 병렬처리로 인해, 명령어 실행 순서가 섞였을 때</strong>
<ul>
<li>가정: counter=5인 상태</li>
<li>Step 0 - producer
<ul>
<li><code>register1 = counter</code> 실행</li>
<li>결과: ‘register1 = 5’</li>
</ul>
</li>
<li>Step 1 - producer
<ul>
<li><code>register1 = register1 + 1</code> 실행</li>
<li>결과: ‘register1 = 6’
<ul>
<li>아직 register1의 값(6)을 counter 변수에 저장하지는 않았다.</li>
</ul>
</li>
</ul>
</li>
<li>Step 2 - consumer
<ul>
<li><code>register2 = counter</code> 실행</li>
<li>결과: ‘register2 = 5’
<ul>
<li>아직 counter가 5이므로, register2에 5가 저장된다.</li>
</ul>
</li>
</ul>
</li>
<li>Step 3 - consumer
<ul>
<li><code>register2 = register2 - 1</code> 실행</li>
<li>결과: ‘register2 = 4’
<ul>
<li>아직 register2의 값(4)을 counter 변수에 저장하지는 않았다.</li>
</ul>
</li>
</ul>
</li>
<li>Step 4 - producer
<ul>
<li><code>counter = register1</code> 실행</li>
<li>결과: ‘counter = 6’
<ul>
<li>이제서야 counter에 register1의 값(6)을 저장하므로, 6이 저장된다.</li>
</ul>
</li>
</ul>
</li>
<li>Step 5 - consumer
<ul>
<li><code>counter = register2</code> 실행</li>
<li>결과: ‘counter = 4’
<ul>
<li>이제서야 counter에 register2의 값(4)을 저장하므로, 4이 저장된다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>결론</strong>
<ul>
<li>프로세스가 병렬처리되지 않았다면(정상적으로 수행되었다면) 최종적으로 counter의 값이 5이어야 한다.</li>
<li><strong>하지만 공유데이터(counter)를 병렬적으로 사용하여, 잘못된 결과가 나왔다.</strong></li>
<li><strong>즉, 기계명령어 실행 순서에 의해 값이 달라졌다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>위와 같은 문제상황을 <strong>경쟁상황(Race Condition)</strong> 이라고 한다.
<ul>
<li>경쟁상황이란?
<ul>
<li>동시에 여러 프로세스가 동일한 자료를 접근하는 상황이다.</li>
<li>실행결과가 접근한 순서에 의존한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="section-5">임계 구역 문제</h2>
<h3 id="section-6">임계 구역이란?</h3>
<ul>
<li>서로 다른 프로세스가 공유하는 변수·테이블·파일 등을 변경하는 작업을 포함하는 코드이다.</li>
<li>즉, 공유영역을 말한다.</li>
<li>임계 구역 == Critical Section (CS)</li>
</ul>
<blockquote>
<p>위에서 살펴본 ‘버퍼의 counter 문제’ 역시 임계구역에서 발생한 문제이다.</p>
</blockquote>
<br/>
<h3 id="section-7">임계 구역 문제</h3>
<ul>
<li>위에서 살펴본 경쟁상황(Race Condition) 역시, 임계 구역 문제 중 하나이다.</li>
<li>임계 구역 문제 해결방법
<ul>
<li><strong>하나의 프로세스가 CS(임계 구역) 내에 있으면, 다른 프로세스들은 CS에 들어오지 못한다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-8">임계 구역 구조</h3>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2064.png" alt="Untitled" /></p>
<ul>
<li><strong>Entry Section (CS 진입구역)</strong>
<ul>
<li>CS(임계영역) 진입 허가 요청을 하는 부분이다.</li>
</ul>
</li>
<li><strong>Exit Section (CS 퇴장구역)</strong>
<ul>
<li>CS(임계영역) 퇴장 시, CS를 나왔다는 Signal을 보내는 부분이다.</li>
</ul>
</li>
<li><strong>Remainder Section (나머지 구역)</strong>
<ul>
<li>CS와 관계없는 나머지 영역이다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-9">임계 구역 문제 해결을 위한 조건들</h3>
<p>CS에서 발생할 수 있는 문제를 해결하기 위해선, 아래 조건들을 반드시 모두 만족해야 한다.</p>
<ul>
<li><strong>Mutual Exclusion (상호 배제)</strong>
<ul>
<li>프로세스 <img src="https://latex.codecogs.com/svg.image?P_i" alt="math" /> 가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 임계구역 내 실행이 불가능하다.</li>
</ul>
</li>
<li><strong>Progress (진행)</strong>
<ul>
<li>조건
<ul>
<li>임계구역에서 실행하는 프로세스가 없다.</li>
<li>임계구역으로 진입하려는 프로세스가 존재한다.</li>
</ul>
</li>
<li>위 두가지 조건이 만족할 경우, 임계구역으로 진입하는 프로세스의 선택이 무한대로 연기되면 안된다.</li>
<li><strong>즉 CS에 진입한 프로세스가 계속 없으면 안된다.</strong></li>
</ul>
</li>
<li><strong>Bounded Waiting (한정된 대기)</strong>
<ul>
<li>프로세스가 임계구역 진입을 요청하고 그 요청이 허용될 때까지, 다른 프로세스들이 임계구역에 진입하는 횟수에 제한이 있다.</li>
<li><strong>즉 무한대기 방지를 위해, 대기 가능한 프로세스 개수를 제한할 수 있다.</strong></li>
</ul>
</li>
</ul>
<br/>
<h3 id="cs--">운영체제에서의 CS 영역 관리</h3>
<ul>
<li>시스템 종류
<ul>
<li>Preemptive (선점형 시스템)</li>
<li>Non-preemptive (비선점형 시스템)</li>
</ul>
</li>
<li>선점형 시스템에서 CS를 다루는 것이 비선점형 시스템보다 어렵다.
<ul>
<li>하지만 현대의 멀티 코어 멀티 프로그래밍 시스템에서는 Preemptive가 필수이다.</li>
<li>따라서 잘 알아두어야 한다!</li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="sw-cs---petersons-algorithm">S/W적 CS 문제 해결: Peterson’s Algorithm</h2>
<h3 id="petersons-algorithm-">Peterson’s Algorithm 이란?</h3>
<ul>
<li><strong>S/W적 해결 방법이다.</strong></li>
<li>프로세스 2개가 경쟁하는 상황에서 사용되는 솔루션이다.</li>
<li>동작 개요
<ul>
<li>가정: <code>load</code> 와 <code>store</code> 기계 명령어를 수행할 땐, 인터럽트가 걸리지 않는다.</li>
<li>사용되는 변수
<ul>
<li><code>int turn</code>
<ul>
<li>차례를 나타내는 변수</li>
<li>0 또는 1 이 저장된다.</li>
<li>임계 구역에 들어갈 프로세서가 P0인지, P1인지 결정한다.</li>
</ul>
</li>
<li><code>Boolean flag[2]</code>
<ul>
<li>프로세스가 임계구역에 들어갈 준비가 되었는지 나타내는 변수</li>
<li><code>flag[0]=true</code> : P0(프로세스0)이 임계 구역에 들어갈 준비가 되었음을 의미</li>
<li><code>flag[1]=true</code> : P1(프로세스1)이 임계 구역에 들어갈 준비가 되었음을 의미</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="petersons-algorithm--">Peterson’s Algorithm 동작 예시</h3>
<ul>
<li>아래 코드는 프로세스i(<img src="https://latex.codecogs.com/svg.image?P_i" alt="math" />)에 대한 동작 코드이다.
<ul>
<li>프로세스 종류: <img src="https://latex.codecogs.com/svg.image?P_i,P_j" alt="math" /></li>
</ul>
</li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>

	<span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="c1">//프로세스i가 CS에 진입할 준비됨</span>
	
	<span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="c1">//위에서 프로세스i가 준비되었음을 알리고, 프로세스j 차례로 돌려준다.</span>
	<span class="c1">//이때, flag[j]가 true라면 CS영역를 프로세스j가 먼저 사용하게 된다.</span>
	<span class="c1">//즉, 프로세스i가 CS영역을 쓰기 전에 프로세스j가 쓰고 싶어하는지 확인하고 양보한다.</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span><span class="o">==</span><span class="n">j</span><span class="p">);</span>
	<span class="c1">//flag[j]: 프로세스j가 진입될 준비가 되었는가?</span>
	<span class="c1">//turn==j: 프로세스j가 실행될 순서인가?</span>
	<span class="c1">// 위 두가지가 모두 참이라면, 프로세스j가 CS에서 실행 중이라는 것이다.</span>
	<span class="c1">// 그러므로 프로세스i가 CS에 진입하지 못하고 대기한다. (무한루프)</span>

	<span class="c1">// [CS 영역]</span>

	<span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="c1">//CS 영역을 사용하고 난 뒤, CS영역을 사용완료했다고 알린다.</span>

	<span class="c1">// [나머지 영역]</span>

<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>
<br/>
<ul>
<li>피터슨 알고리즘과 CS문제 해결 조건
<ul>
<li><strong>Mutual Exclusion (상호배제)</strong>
<ul>
<li>상대방이 실행 중(<code>flag[j] &amp;&amp; turn==j</code>)일 땐, 진입하지 못한다.</li>
<li>따라서 위 코드는 상호배제 조건에 만족한다.</li>
</ul>
</li>
<li><strong>Progress (진행)</strong>
<ul>
<li>상대방이 준비되지 않으면 언제든지 진입할 수 있다.</li>
<li>따라서 위 코드는 진행 조건에 만족한다.</li>
</ul>
</li>
<li><strong>Bounded-waiting (한정된 대기)</strong>
<ul>
<li>둘이 준비되어도 한 프로세스가 끝나야 진입할 수 있다.</li>
<li>따라서 위 코드는 한정된 대기 조건에 만족한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h2 id="hw-cs---testandset-insturction">H/W적 CS 문제 해결: test_and_set Insturction</h2>
<h3 id="hw-">H/W적 해결</h3>
<ul>
<li>위에서 살펴본 피터슨 알고리즘과 같은 <strong>소프트웨어적 해결방법에는 한계</strong>가 있다.
<ul>
<li>단일 프로세서 시스템에서의 S/W적 해결방법
<ul>
<li>임계영역 실행 시, 인터럽트 금지를 통해 CS 문제를 해결한다.</li>
<li>따라서 굳이 H/W적 해결방법을 사용하지 않아도 된다.</li>
</ul>
</li>
<li>멀티 프로세서 시스템에서의 S/W적 해결방법
<ul>
<li>인터럽트 금지를 사용할 수 없다. 왜냐하면, 모든 처리기에 인터럽트 불능 메시지를 전달해야하기 때문이다.</li>
<li>즉 임계영역 실행 시, 단순히 인터럽트를 금지하는 방식으로 문제를 해결하는 것은 비효율적이다.</li>
<li><strong>따라서, Locking 기법으로 CS문제를 해결해야 한다. ⇒ H/W적 해결을 해야한다.</strong></li>
</ul>
</li>
</ul>
</li>
<li>따라서 H/W적 해결 방법을 사용해야 한다.</li>
</ul>
<br/>
<ul>
<li>H/W적 해결의 핵심
<ul>
<li><strong>원자적 기계 명령어 사용</strong>
<ul>
<li>인터럽트가 되지 않는 특수한 명령어를 사용한다.</li>
</ul>
</li>
<li><strong>Locking</strong>
<ul>
<li>프로세스가 CS를 사용하면, 자물쇠를 걸어 다른 프로세스가 진입하지 못하게 막는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>Locking 기법의 기본 방식</p>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2065.png" alt="Untitled" /></p>
<ul>
<li><code>acquire lock</code>
<ul>
<li>lock을 얻는 부분</li>
<li>lock을 얻어야만 CS영역에 진입할 수 있다.</li>
</ul>
</li>
<li><code>release lock</code>
<ul>
<li>lock을 반환하는 부분</li>
<li>CS 실행 완료 시, lock을 돌려준다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="testandset-instruction-">test_and_set Instruction 이란?</h3>
<ul>
<li>
<p>정의</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="nf">test_and_set</span> <span class="p">(</span><span class="n">boolean</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">boolean</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
</li>
<li>
<p>상세설명</p>
<ul>
<li>위 코드는 원자적으로 실행된다. 즉, 인터럽트가 없다.</li>
<li>현재 <code>*target</code> 이 false일 때
<ol>
<li><code>rv</code>를 false로 설정한다.</li>
<li><code>*target</code> 를 true로 설정한다.</li>
<li><code>rv</code> 값을 반환한다.</li>
</ol>
</li>
<li>현재 <code>*target</code> 이 true일 때
<ol>
<li><code>rv</code>를 true로 설정한다.</li>
<li><code>*target</code> 를 true로 설정한다.</li>
<li><code>rv</code> 값을 반환한다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="testandset-instruction--">test_and_set Instruction 사용 예시</h3>
<ul>
<li>
<p>아래는 test_and_set Instruction을 사용하는 예시 코드이다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span>
	<span class="c1">//만약 &amp;lock이 true라면, 무한루프에 빠진다.</span>
	<span class="c1">//만약 &amp;lock이 false라면, 무한루프를 탈출한다.</span>
	<span class="c1">//이렇게 무한루프로 CS진입을 막는 것을 Busy Waiting이라고 한다.</span>

	<span class="c1">// [CS영역]</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="c1">//cs영역 실행 완료 시, lock을 반환한다.</span>

	<span class="c1">// [나머지 영역]</span>

<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>
</li>
</ul>
<br/>
<ul>
<li>상세 설명
<ul>
<li>x가 false이면 (CS 미사용이면) x가 true로 set되고, while루프를 벗어난다.</li>
<li>x가 true면 (CS 사용이면) x가 true로 set되고, while루프에 머문다.</li>
<li><strong>결국 lock이라는 변수 하나로 CS 접근 허용을 제어한다.</strong></li>
</ul>
</li>
</ul>
<p><br/><br/></p>
<h2 id="hw-cs---compareandswap-instruction">H/W적 CS 문제 해결: compare_and_swap Instruction</h2>
<h3 id="compareandswap-instruction-">compare_and_swap Instruction 이란?</h3>
<blockquote>
<p>위에서 살펴본 test_and_set Instruction 와 전체 메커니즘은 유사하다.<br />
단순히 반환값으로 boolean형에서 int형을 사용하는 것 뿐이다.<br />
그러므로 간단히 살펴만 보자.</p>
</blockquote>
<ul>
<li>
<p>정의</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
</li>
<li>
<p>상세 설명</p>
<ul>
<li>위 코드는 원자적으로 실행된다. 즉, 인터럽트가 없다.</li>
<li>전달받은 <code>*value</code> 의 값을 그대로 반환한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="compareandswap-instruction--">compare_and_swap Instruction 사용 예시</h3>
<ul>
<li>
<p>아래는 compare_and_swap Instruction을 사용하는 예시 코드이다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="c1">//Busy Waiting</span>

	<span class="c1">// [CS영역]</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// [나머지 영역]</span>

<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>
</li>
</ul>
<p><br/><br/></p>
<h2 id="hw-cs---mutex-locks">H/W적 CS 문제 해결: Mutex Locks</h2>
<h3 id="mutex-locks-">Mutex Locks의 배경</h3>
<ul>
<li>기존 Lock을 사용하는 방식들은 좀 복잡하다.</li>
<li>비교적 Mutex는 가장 단순하다.</li>
</ul>
<h3 id="mutex-locks--1">Mutex Locks 이란?</h3>
<ul>
<li>사용하는 주요 함수
<ul>
<li><code>acquire()</code>
<ul>
<li>lock 획득</li>
</ul>
</li>
<li><code>release()</code>
<ul>
<li>lock 반환</li>
</ul>
</li>
</ul>
</li>
<li>Mutex Locks의 문제점
<ul>
<li>다른 Lock 방식에 비해, 더 간단하기는 하다.</li>
<li>하지만 다른 Lock 방식들과 마찬가지로, <strong>Busy Waiting 방식</strong>을 사용한다.
<ul>
<li><strong>Busy Waiting: while문을 계속 돌며, CS 진입을 대기하는 것</strong></li>
<li>Busy Waiting == spinlock</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>정의
<ul>
<li>
<p><code>acquire()</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">acquire</span><span class="p">()</span> <span class="p">{</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">);</span> <span class="c1">//Busy Waiting</span>

	<span class="n">available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
</li>
<li>
<p><code>release()</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">release</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="mutex-locks--">Mutex Locks 사용 예시</h3>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2066.png" alt="Untitled" /></p>
<p><br/><br/></p>
<h2 id="hw-cs---semaphore-">H/W적 CS 문제 해결: Semaphore (세마포어)</h2>
<h3 id="semaphore-">Semaphore (세마포어)란?</h3>
<ul>
<li>Busy Waiting이 필요없는 동기화 기법이다.</li>
<li>사용하는 변수
<ul>
<li><code>int S</code></li>
</ul>
</li>
<li>사용하는 함수
<ul>
<li>
<p><code>wait()</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//Busy Waiting</span>
	<span class="n">S</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>CS 진입 시도 함수</li>
</ul>
</li>
<li>
<p><code>signal()</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Signal</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">S</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>CS 퇴장 함수</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="semaphore--1">Semaphore 종류</h3>
<ul>
<li>
<p><strong>Counting Semaphore (카운팅 세마포어)</strong></p>
<blockquote>
<p>이진 세마포어 이후에 설명하는 세마포어는 모두 이것을 의미한다.</p>
</blockquote>
</li>
<li>
<p><strong>Binary Semaphore (이진 세마포어)</strong></p>
<ul>
<li>이것은 Mutex Locks와 같다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-10">이진 세마포어 예시</h3>
<ul>
<li>프로세스
<ul>
<li>P1</li>
<li>P2</li>
</ul>
</li>
<li>가정
<ul>
<li><img src="https://latex.codecogs.com/svg.image?S_1" alt="math" /> 이 <img src="https://latex.codecogs.com/svg.image?S_2" alt="math" /> 보다 먼저 수행되어야 한다.</li>
<li><code>synch</code> 변수 초기값 = 0</li>
</ul>
</li>
</ul>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2067.png" alt="Untitled" /></p>
<ul>
<li>상세 설명
<ul>
<li>
<p>Busy Waiting의 필요성을 극복하기 위해, <code>waiting()</code> , <code>signal()</code> 세마포어 연산 정의를 변경했다.</p>
<ul>
<li>즉 세마포어로 Busy Waiting을 해결했다.</li>
</ul>
</li>
<li>
<p>Busy Waiting 해결 방법</p>
<ul>
<li>프로세스가 <code>wait()</code> 연산을 실행하고, 세마포어 값이 양수가 아니면, 프로세스를 Busy Waiting 대신 블록(중지) 시킬 수 있다.</li>
</ul>
<blockquote>
<p>이 후에 좀 더 자세히 알아보자.</p>
</blockquote>
</li>
<li>
<p>자원이 방출되면 블록된 프로세스를 실행한다.</p>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="busy-waiting--">세마포어를 통해, Busy Waiting하지 않는 방법</h3>
<ul>
<li>
<p>세마포어 큐를 이용한 연산을 통해, 프로세스를 블로킹(중지)할 수 있다.</p>
<ul>
<li>
<p>세마포어 큐란?</p>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2068.png" alt="Untitled" /></p>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2069.png" alt="Untitled" /></p>
</li>
</ul>
</li>
<li>
<p>세마포어 큐를 이용한 연산</p>
<ul>
<li><strong>block</strong>
<ul>
<li>호출한 프로세스를 중지(block)시키고 대기 큐에 넣는다.</li>
</ul>
</li>
<li><strong>wakeup</strong>
<ul>
<li>대기 큐에 있는 프로세스를 꺼내어 준비완료 큐에 넣는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>동작 예시</p>
<p><img src="/assets/img/2021-11-25-OS_SynchronizationTools/Untitled%2070.png" alt="Untitled" /></p>
</li>
</ul>
<br/>
<h3 id="deadlock">Deadlock</h3>
<ul>
<li>Deadlock이란?
<ul>
<li>교착 상태</li>
<li>둘 이상의 프로세스가 ‘다른 프로세스가 점유하고 있는 자원’을 서로 기다릴 때, 무한 대기 상태에 빠지는 것을 의미한다.</li>
</ul>
</li>
</ul>
<br/>
<h3 id="starvation">Starvation</h3>
<ul>
<li>Starvation이란?
<ul>
<li>기아 상태</li>
<li>세마포어 큐에서 LIFO 순서로 제거할 경우에 발생한다.
<ul>
<li>LIFO 구조인 경우, 가장 먼저 들어온 프로세스가 영원히 기다릴 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-11">우선순위 역전</h3>
<ul>
<li>‘우선 순위가 높은 프로세스’가 CS 영역을 사용하고자 할 때, ‘우선 순위가 낮은 프로세스’가 CS 영역을 이미 사용 중이라면, ‘우선 순위가 높은 프로세스’는 우선순위가 높더라도 기다려야 한다.</li>
</ul>
<br/>
<ul>
<li>예시
<ul>
<li>가정
<ul>
<li>L : 우선순위 가장 낮은 프로세스</li>
<li>M : 중간 우선순위 프로세스</li>
<li>H : 우선순위 가장 높은 프로세스</li>
</ul>
</li>
</ul>
<ol>
<li>L 이 CS 영역을 사용하고 있다.
<ul>
<li>CPU 점유 = L</li>
</ul>
</li>
<li><strong>이때 H가 CS 영역을 사용하고자 하지만, CS영역이 사용 중이라 블록된다.</strong>
<ul>
<li>CPU 점유 = L</li>
</ul>
</li>
<li>M이 CPU를 사용하고자 하여, 할당받는다. (CS 영역 사용 X)
<ul>
<li>CPU 점유 = M</li>
<li><strong>이때 CS영역을 사용 중이던 L은 M에게 CPU제어권을 뺏기고 기다린다.</strong></li>
<li><strong>이것 때문에 H는 M까지 기다려야 한다.</strong></li>
</ul>
</li>
<li>M의 작업이 끝나고, CPU는 L에게 할당된다.
<ul>
<li>CPU 점유 = L</li>
<li>L의 작업이 끝나야, H에게 CS 영역을 줄 수 있으므로</li>
</ul>
</li>
<li>L의 작업이 끝나고나서야, H가 CS 영역에 진입한다.
<ul>
<li>CPU 점유 = H</li>
</ul>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>문제 해결 방법: 우선순위 상속
<ul>
<li>‘낮은 우선순위 프로세스’가 ‘높은 우선순위 프로세스’의 우선순위를 상속받아, CS를 실행한 후 Lock을 풀고 원래 우선순위로 복귀하는 것이다.</li>
<li>예시
<ol>
<li>L 이 CS 영역을 사용하고 있다.
<ul>
<li>CPU 점유 = L</li>
</ul>
</li>
<li>이때 H가 CS 영역을 사용하고자 하지만, CS영역이 사용 중이라 블록된다.
<ul>
<li>CPU 점유 = L</li>
</ul>
</li>
<li><strong>L 이 H의 우선순위를 상속받아, M보다 우선순위가 높아졌다.</strong></li>
<li><strong>M이 CPU를 사용하고자 한다. 하지만 할당받을 수 없다.</strong>
<ul>
<li>CPU 점유 = L</li>
<li><strong>M보다 L의 우선순위가 높기 때문에</strong></li>
</ul>
</li>
<li><strong>L의 작업이 끝나고, CPU는 H에게 할당된다. 그리고 H는 CS영역을 사용할 수 있게 된다.</strong>
<ul>
<li>CPU 점유 = H</li>
<li>L의 작업이 끝나서, lock을 돌려준다.</li>
</ul>
</li>
<li>H의 작업이 끝나고나서야, M이 CPU를 점유한다.
<ul>
<li>CPU 점유 = M</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="section-12">세마포어의 문제점</h3>
<ul>
<li><code>signal()</code> 과 <code>wait()</code> 의 순서가 바뀌면, Deadlock이나 Starvation에 빠질 수 있다.</li>
</ul>
<p><br><br></p>
<hr />
<br>
<div style="font-style: italic;color: gray;">
  <ul>
    <li>성결대학교 컴퓨터 공학과 강영명 교수님 (2021)</li>
    <li>Siberschatz et. al., 『Operating System Concepts 10th Ed.』</li>
  </ul>
  본 게시글은 위 강의 및 교재를 기반으로 정리한 글입니다.
</div>
:ET